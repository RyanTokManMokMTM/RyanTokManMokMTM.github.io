<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>[LeetCode] Remove All Adjacent Duplicates in String II(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode1209/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>stack</tag></tags><content type="html"> LeetCode 1209 - Remove All Adjacent Duplicates in String II You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.
example
Input: s = "abcd", k = 2 Output: "abcd" Explanation: There's nothing to delete. Input: s = "deeedbbcccbdaa", k = 3 Output: "aa" Explanation: First delete "eee" and "ccc", get "ddbbbdaa" Then delete "bbb", get "dddaa" Finally delete "ddd", get "aa" Input: s = "pbbcggttciiippooaais", k = 2 Output: "ps" How can we solve this problem? 這題就是要我們刪除掉在String裡面某些相鄰且相同並重複了k次的Characters。例如: aeee,k=3，輸出a。如果我們要解決這個問題就要知道目前string裡面有哪些subString符合條件，但是這裡要注意一個問題就是有些Substring被移除後，會使前(刪除Str)後2個substring符合條件。例如:aeeeaa,但我們刪除eee後,aaa也會符合條件，因此會被移除。
哪我們要怎麼知道哪些characters符合條件呢?
這裡我們可以使用Stack/Array來幫組我們解題。為什麼是用Stack? 因為我們只需要關注當前str[i]是否與前一個str[i-1]一致,如果是一致的我們會加入到Stack.top的Counter裡面。只要Counter的值為k我們就知道是符合條件的String，移除即可。最後，把Stack/Array裡面剩餘的元素串接就可以得出最後答案(注:Stack元素串接需要Reverse結果)。
Solution: class Solution { public: string removeDuplicates(string s, int k) { if(s.length() &lt; k) return s; string res; vector&lt;pair&lt;char,int>> counter; //O(n) for(auto str : s){ //how many same character if(counter.empty() || counter.back().first != str) counter.push_back({str,1}); else{ counter.back().second++; } if(counter.back().second == k) counter.pop_back(); } // for(auto e:vc) cout &lt;&lt; e; //O(i*k &lt;= n ) => O(n); for(int i = 0;i&lt;counter.size();i++){ for(int j = 0;j&lt;counter[i].second;j++) res+=counter[i].first; } cout &lt;&lt; res &lt;&lt;endl; return res; } };</content></entry><entry><title>[Leetcode] Implement Stack using Queues(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode225/</url><categories><category>leetcode</category></categories><tags><tag>stack</tag><tag>queue</tag><tag>design</tag></tags><content type="html"> LeetCode 225 - Implement Stack using Queues Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes:
You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&rsquo;s standard operations. example
Input ["MyStack", "push", "push", "top", "pop", "empty"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False How can we solve this problem? 這題就是要我們用Queue來模擬Stack。做這題之前我們要先知道Queue和Stack的差異。
Queue是First In First Out, 也就是先進去的element會先被拿出來 Stack是First In Last Out, 也就是先進去的element最後才會被拿出來 push(int x):
如果要用Queue來模擬Stack就要注意在Queue中的最後一個元素會是Stack的第一個元素。所以，這題我們可以用比較簡單粗暴的方式來解決。因為我們已經知道後進(Last In)Stack的值會是第一個元素。因此,我們可以直接用一個variable保存最後插入進Queue的element即可。
pop()
如果我們要移除element，就必須要將Queue的最後一個元素搬到最前面，同時因為最前面的元素會被移除，所以我們用於保存最後插入進Queue的variable所記錄的值也必須被改變，變成Queue的倒數第二個element。因此我們要先將Queue中最後的2個element搬到最前面，第一個便是我們stack的top,而第二個是我們要pop的element。最後，我們記錄完top的值後，插入到Queue的尾巴，並返回要Queue的front即可。
clear(): 只需將空的Queue取代成當前不是空的Queue即可。
empty():
只需檢查Queue是否為empty()即可。
Solution: class MyStack { public: queue&lt;int> q; int t; // queue&lt;int> q2; MyStack() { } //O(N) void push(int x) { // q2.push(x); // while(!q.empty()){ // q2.push(q.front());q.pop(); // } // q = q2; // clear(q2); q.push(x); t = x; } //O(1) int pop() { // if(empty()) return -1; // int value = q.front();q.pop(); //get the last 2 elements int size = q.size(); while(size-- > 2) { q.push(q.front()); q.pop(); } //getting the 2th top value in stack t = q.front(); q.push(q.front()); //push it at the back of the queue q.pop(); //getting the 1th top value in stack int popVal = q.front(); q.pop(); return popVal; } void clear(queue&lt;int>&amp; q){ queue&lt;int> empty; swap(empty, q); } int top() { // if(empty()) return -1; // return q.front(); return t; } bool empty() { return q.empty() ? true : false; } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */</content></entry><entry><title>[Leetcode] Max Number of K-Sum Pairs(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode1679/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>map</tag><tag>two-pointer</tag></tags><content type="html"> LeetCode 1679 - Max Number of K-Sum Pairs You are given an integer array nums and an integer k.
In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.
Return the maximum number of operations you can perform on the array.
example
Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. Input: nums = [3,1,3,4,3], k = 6 Output: 1 Explanation: Starting with nums = [3,1,3,4,3]: - Remove the first two 3's, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation. How can we solve this problem? 這題就是要移除Array中2個elements加起來等於k的操作有幾次。
第一個解法，我們可以使用sorting以及two-pointer approach來解決。先將array排序，然後設置i為0,j為n-1,直接使用iteration找出nums[i]+nums[j] = k的數，然後answer+1即可。
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { //sort sort(nums.begin(),nums.end()); //O n log n int ans = 0; int i = 0,j = nums.size()-1; while(i &lt; j){ if(nums[i] + nums[j] == k) { ans++; i++; j--; }else if(nums[i] + nums[j] > k)j--; else i++; } return ans; } }; 第二種解法是透過map來記錄。首先，會透過x = k - nums[i]得出一個數，如果這個數不存在map裡面或者map[x] &lt;= 0就代表沒有，就把目前的nums[i]加入到map。如果存在，就將answer+1並且從map中移除map[x]的數量(map[x]--)。
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { unordered_map&lt;int,int> temp; int ans = 0; for(int i = 0;i&lt;nums.size();i++){ int sum = k - nums[i]; if(temp[sum] > 0){ //exist this value; //for example:[3,1,3,4,3] //3,1,3(we are here) 6-3=3 and 3:1 and we found a pair(3,3)=6 ,and remove the existing value ans++; temp[sum]--; }else temp[nums[i]]++; } return ans; } };</content></entry><entry><title>[Leetcode] Shortest Unsorted Continuous Subarray(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode581/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 581 - Shortest Unsorted Continuous Subarray Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.
Return the shortest such subarray and output its length.
example:
Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Input: nums = [1,2,3,4] Output: 0 Input: nums = [1] Output: 0 How can we solve this problem? 這題比較難懂一點點，這裡先做一下題目的解釋。這題主要先問的是在輸入的Array裡面找到一個最小需要排序的Sub-array。
從例子[2,6,4,8,10,9,15]中，我們可以很明顯的看到[6,4,8,10,9]並不是ascending order(順序),而這個sub-array要進行排序的話，所有elements都需要進行排序，所以，他的length是5。
再舉另外一個例子[1,3,2,3,3]，這個Array我們可以看到[3,2,3,3]並不是順序的，但是在這個sub-array裡面,只有[3,2]需要排序,所以，他的結果會是2。
那我們應該要怎麼解呢? 一個最簡單的解法是定義一個額外的array，而這個array的element跟原來的一樣，但是已經被排序過的。因此，只要比較原本的array和排序過的array有幾個element的位置不一樣就知道結果了。但Time Complexity是是O(n log n) - 排序的時間，而Space Complexity則是O(n)
Solution: vector&lt;int> temp = nums; sort(temp.begin(),temp.end()); //n log n int start = nums.size() - 1; int end = 0; //finding the starting point which is not as same as the sorted array //finding the ending print which is not as same as the sorted array for(int i =0;i&lt;nums.size();i++){ if(nums[i] != temp[i]){ start = min(i,start); // end = max(end,i); } } return end - start >= 0 ? end - start + 1 : 0; 另外一種解法是通過Two-pointer approach來解。我們先要找到左手邊有問題的地方的最小值(1,4,7,5,3,6 最小值為3)以及右手邊有問題的地方的最大值(1,4,7,5,3,6 最大值為7)。然後,要找出左手邊第一個被影響的index(nums[index] > 最小值)。同理也要找出右手邊第一個被影響的最index(nums[index] &lt; 最大值)。這樣我們就能找出有問題的區間[left,right]，在根據left,right得出最終結果。 Solution: 解法二:
int start = INT_MAX; int end = INT_MIN; for(int i = 1;i&lt;nums.size();i++){ if(nums[i] &lt; nums[i-1]) start = min(nums[i],start); } for(int i = nums.size() - 2;i>=0;i--){ if(nums[i] > nums[i + 1]) end = max(nums[i],end); } int left,right; //scanning the value from the left to the right that is less than maximum value for(left = 0;left&lt;nums.size();left++){ //finding the descending point if(start &lt; nums[left]) break; } //scanning the value from the right to the left that is less than minimum value for(right = nums.size() - 1;right >= 0;right--){ if(end > nums[right]) break; } //we need to find out the right-most point return right - left >= 0 ? right - left + 1 : 0;</content></entry><entry><title>[Leetcode] Sort Array By Parity(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode905/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 905 - Sort Array By Parity Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
Return any array that satisfies this condition.
example:
Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Input: nums = [0] Output: [0] How can we solve this problem? 這個問題很簡單，就是把偶數移動到Array的前面，基數移動到後面。我們這裡可以使用Two-pointer approach, i為尋找前面的基數，而j 為尋找後面的偶數，只要nums[i]為基數,nums[j]為偶數就進行交換。
=j`就結束 -- Solution: class Solution { public: vector&lt;int> sortArrayByParity(vector&lt;int>&amp; nums) { int i = 0; int j = nums.size() - 1; //O(n) while(i &lt; j){ //i is even skip //j is odd skip //i is odd and j is even swap if(nums[i] % 2 == 0) i++; else if(nums[j] % 2 == 1) j--; else swap(nums[i++],nums[j--]); } return nums; } };</content></entry><entry><title>[Leetcode] Backspace String Compare(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode844/</url><categories><category>leetcode</category></categories><tags><tag>string</tag></tags><content type="html"> LeetCode 844 - Backspace String Compare Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
example:
Input: s = "ab#c", t = "ad#c" Output: true Explanation: Both s and t become "ac". Input: s = "ab##", t = "c#d#" Output: true Explanation: Both s and t become "". Input: s = "a#c", t = "b" Output: false Explanation: s becomes "c" while t becomes "b". How can we solve this problem? 這題主要要什麼比較2個String移除於#前的字符後是否為相同的String，就相當於Backspace(#) 字符。 這題有2種解法:
要使用到額外的空間，保存2個移除字符後的String再進行比較。 透過pointerr的方式來決定哪個位置是要被移除的，然後將之後的字符將其進行取代，最後在比較倆者在r長度內的字符是否相同，即可。可見下圖為例: Solution: class Solution { public: bool backspaceCompare(string s, string t) { int slen = s.length(); int tlen = t.length(); int i = 0; int rpSStrIndex = 0; while(i &lt; slen ){ if(s[i] == '#') { if(rpSStrIndex > 0) rpSStrIndex--; } else s[rpSStrIndex++] = s[i]; i++; } i = 0; int rpTStrIndex = 0; while(i &lt; tlen){ if(t[i] == '#' ){ if(rpTStrIndex > 0) rpTStrIndex--; } else t[rpTStrIndex++] = t[i]; i++; } cout &lt;&lt; rpSStrIndex &lt;&lt; rpTStrIndex; //there length is not same if(rpSStrIndex != rpTStrIndex) return false; //compare each string between replaced Index for(i = 0;i&lt;rpSStrIndex;i++){ if(s[i] != t[i]) return false; } return true; } };</content></entry><entry><title>[Leetcode] Trim a Binary Search Tree(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode669/</url><categories><category>leetcode</category></categories><tags><tag>binary Search Tree</tag><tag>binary Tree</tag><tag>recursion</tag></tags><content type="html"> LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.
Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.
example
Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] How can we solve this problem? 這題就是要我們將一顆BST的少於low的部分以及大於heigh的部分移除。這題打算使用遞歸來解決。我們只要將比low小的Node的右子樹接到他的父節點，並取代比low還小的Node，而比heigh大的Node的左子樹接到他的父節點，並取代比heigh還大的Node即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { //space : O(tree node size for all nodes value are between low and height) //time : O(tree node size for all nodes) return TrimBST(root,low,high); } TreeNode* TrimBST(TreeNode* root,int low,int height){ if(!root) return nullptr; //if the root value is less than height ,go right sub-tree //if the root value is greater than low ,go left sub-tree if(root->val &lt; low){ // root->left = nullptr; return TrimBST(root->right,low,height); }else if(root->val > height){ // root->right = nullptr; return TrimBST(root->left,low,height); } //left root->left = TrimBST(root->left,low,height); //right root->right = TrimBST(root->right,low,height); // cout &lt;&lt; root->val &lt;&lt; "\n"; return root; } };</content></entry><entry><title>[Leetcode] Search in a Binary Search Tree(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode700/</url><categories><category>leetcode</category></categories><tags><tag>binary search tree</tag><tag>recursion</tag><tag>binary Tree</tag></tags><content type="html"> LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
example
Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5 Output: [] How can we solve this problem? 在解決問題之前，我們需要知道什麼是Binary Search Tree。根據BST的定義:
Binary Search Tree 基於Binary Tree left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value Binary Search Tree的key/value都是unique的 現在我們知道什麼是BST了。這個問題是要在BST中找val，我們通過以下幾個條件以及遞歸幫我們求解:
left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value 如果val是小於root,就移動到左子樹(left sub-tree)，否者移動到右子樹(right sub-tree),直到找到val並返回root的pointer或者沒有找到返回null
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(root == nullptr) return root; //check val if(root->val > val){ //go to left return searchBST(root->left,val); // }else if(root->val &lt; val){ return searchBST(root->right,val); }else{ return root; } } };</content></entry><entry><title>[Leetcode] Shift 2D Grid(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode1260/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag></tags><content type="html"> LeetCode 1260 - Shift 2D Grid Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times.
example
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] How can we solve this problem? 其實這個問題很簡單，我們只需要關心grid的最後得column，因為最後一個Column被right-shift到第一個Column的時候，最後一個element會被移動到0th。其餘的column只要right-shift by 1 step即可。 我們可以參考以下數學公式:
n是row size 以及 m 是 column size
left-shifting : currentColum + k % n, moving by k step shifting row : (j + k) / n), if it is in the last column, (j + k) / m will be 1. Otherwise will be 0 total row shifting step : (i + (j + k) / n)) % m. For example, suppose n = 3 , j = 2 , m = 3 and i = 2: (2 + ((2+1)/3)) % 3 = 0 so that it will move to [0][0] Solution: class Solution { public: vector&lt;vector&lt;int>> shiftGrid(vector&lt;vector&lt;int>>&amp; grid, int k) { //just be careful the last element on [m-1][n-1] //n - k int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); for(int i = 0 ;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ //here we need to know how many time does the colums j pass the col 0,then we need to movie the i of that time // (j + k) % m => total time walk passed int moveJ = (j + k) % m; //if current moving j is the last one int walkPassedZeorTimes = (j + k)/m; int moveI = (i + walkPassedZeorTimes) % n; res[moveI][moveJ] = grid[i][j]; } } return res; } };</content></entry><entry><title>[Leetcode] Spiral Matrix II(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode59/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 59 - Spiral Matrix II Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
example
Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Input: n = 1 Output: [[1]] How can we solve this problem? 這題跟Spiral Matrix做法差不多，我們不難發現他的移動模式就是(右→下↓左←上)，我們只需要通過幾個變數來限制移動的步數。另外，這題需要我們返回一個n*n的array，所以，需要額外定義一個counter來記錄每次插入的數值為多少，因此，只要counter 到達n*n的大小就知道是否完成插入所需的值。
YES! You Can! Let me explain how it works. According to the example, we can find out its moving pattern(`top-left to top-right`,`top-right to bottom-right`,`bottom-right to bottom-left` and `bottom-left to top left`), it always follows these 4 moving patterns, so that we can define a boundary of row and column to limit pointer moving to has inserted a number. Until reaching n2, it will break the loop and return the answer. -- Solution: 2, then return the answer -- class Solution { public: vector&lt;vector&lt;int>> generateMatrix(int n) { //total step n^2 vector&lt;vector&lt;int>> res(n,vector&lt;int>(n,0)); int c = 1; int upperRow = 0,lowerRow = n - 1; int upperCol = 0,lowerCol = n - 1; while(c &lt;= n*n){ //moving left if(upperCol &lt;= lowerCol){ //n step for(int i = upperCol;i&lt;=lowerCol;i++){ res[upperRow][i] = c++; } } upperRow ++; //moving down //moving down if(upperRow &lt;= lowerRow){ for(int i = upperRow;i&lt;=lowerRow;i++){ res[i][lowerCol] = c++; } } lowerCol--; //moving right if(lowerCol >= upperCol){ for(int i = lowerCol;i>=upperCol;i--){ res[lowerRow][i] = c++; } } lowerRow --; //moving up if(lowerRow >= upperRow){ for(int i = lowerRow;i>=upperRow;i--){ res[i][upperCol] = c++; } } upperCol ++; } return res; } };</content></entry><entry><title>[Leetcode] Game of Life(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode289/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 289 - Game of Life According to Wikipedia&rsquo;s article: &ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&rdquo;
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.
example
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] How can we solve this problem? 要解決這個，我們需要知道目前的cell的狀態(活/死)。要知道目前cell的狀態，我們可以用過條件判斷他身邊的cells(最多9個細胞)即可。
Solution: class Solution { public: void gameOfLife(vector&lt;vector&lt;int>>&amp; board) { int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); //O(N^2 for checking each cells) : time //O(N^2 for storing new cells states) : space for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ int total = checkState(board,i,j,n,m); if(board[i][j] == 1) res[i][j] = (total &lt; 2 || total > 3 ) ? 0 : 1; else res[i][j] = total == 3 ? 1 : 0; } } board = res; } int checkState(vector&lt;vector&lt;int>>&amp; board,int i,int j,int n,int m){ // //neighbors bounds // int rowStart = (i - i) &lt; 0 ? 0 : i - 1; // int rowEnd = (i + 1) > n - 1 ? n - 1 : i + 1; // int colStart = (j - 1) &lt; 0 ? 0 : j - 1; // int colEnd = (j + 1) > m - 1 ? m - 1 : j + 1; int livesCells = 0; //top left if(i - 1 >= 0 &amp;&amp; j -1 >= 0){ livesCells += board[i-1][j-1]; } //top if(i - 1 >= 0){ livesCells += board[i-1][j]; } //top right if(i - 1 >= 0 &amp;&amp; j + 1 &lt; m){ livesCells += board[i-1][j + 1]; } //left if(j - 1 >= 0){ livesCells += board[i][j - 1]; } //right if(j + 1 &lt; m){ livesCells += board[i][j + 1]; } //bottom left if(i + 1 &lt; n &amp;&amp; j - 1 >= 0){ livesCells += board[i+1][j-1]; } //bottom if(i + 1 &lt; n ){ livesCells += board[i+1][j]; } //bottom right if(i + 1 &lt; n &amp;&amp; j + 1 &lt; m){ livesCells += board[i+1][j+1]; } return livesCells; } };</content></entry><entry><title>[Leetcode] Baseball Game(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode682/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 682 - Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&rsquo; scores.
At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:
An integer x - Record a new score of x. &ldquo;+&rdquo; - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. &ldquo;D&rdquo; - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. &ldquo;C&rdquo; - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. example
Input: ops = ["5","2","C","D","+"] Output: 30 Explanation: "5" - Add 5 to the record, record is now [5]. "2" - Add 2 to the record, record is now [5, 2]. "C" - Invalidate and remove the previous score, record is now [5]. "D" - Add 2 * 5 = 10 to the record, record is now [5, 10]. "+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Input: ops = ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation: "5" - Add 5 to the record, record is now [5]. "-2" - Add -2 to the record, record is now [5, -2]. "4" - Add 4 to the record, record is now [5, -2, 4]. "C" - Invalidate and remove the previous score, record is now [5, -2]. "D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. "9" - Add 9 to the record, record is now [5, -2, -4, 9]. "+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. "+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. How can we solve this problem? 這題就是一個簡單的籃球比賽模擬。我們只要關心遊戲rule，並透過額外的container(array/stack)進行分數保存即可。
Solution: class Solution { public: int calPoints(vector&lt;string>&amp; ops) { //ops : + D C x // vector&lt;int> s; //or using a stack stack&lt;int> sk; //O(n) //O(n) for(auto i : ops) { if(i == "+"){ int a = sk.top(); sk.pop(); int b = sk.top(); sk.push(a); sk.push(a+b); }else if(i == "D"){ sk.push(sk.top() * 2); }else if(i == "C"){ sk.pop(); }else{ sk.push(stoi(i)); } } int res = 0; //O(n) while(!sk.empty()){ res += sk.top();sk.pop(); } return res; } };</content></entry><entry><title>[Note]Creational Singleton Pattern</title><url>https://ryantokmanmokmtm.github.io/post/creational-singleton-pattern/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Singleton Pattern(單例模式)呢? 定義:一個Class在系統中只會存在一個實例(instance),整個系統中只提供1個可使用的instance,以確保唯一性,並節省系統資源。
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
class的建構子(constructor)對外隱藏,外部無法通過constructor進行實例化，但會提供一個靜態(static)方法，以獲取這個class的唯一實例。 TaskManager
//Constructor 對外隱藏，並提供一個靜態Static 讓外部只透過這個存取 class TaskManager{ private: TaskManager(); void displayProcess(); void displayServices(); static TaskManager* taskManager = nullptr; //保存唯一Instance public: //外部只能透過靜態Static 方法存取 並new一個TaskManger的Instance 如果是null的 //此方法為工廠 static TaskManager* getInstance(){ if(taskManager == nullptr){ taskManager = new TaskManager(); } return TaskManager; } } LoadBalance
//LoadBalance 🌰 //用於計算服務器負載，所以必須使用單例 class LoadBalance{ public: static LoadBalance* getInstance(){ if(loadBalance == nullptr){ loadBalance = new LoadBalance(); } return LoadBalance; } private: static LoadBalance* loadBalance; LinkedList* serverList = nullptr; LoadBalance(); void addServer(std::string server){ serverList->add(server);//add a server } std::string getServer(){ int i = random()% serverList->length(); //random get server return serverList->get(i); } } int main(){ LoadBalance *balancer1,*balancer2,*balancer3,*balancer4; balancer1 = LoadBalance::getInstance(); //獲取LoadBalance，這裡會先new 再return balancer2 = LoadBalance::getInstance(); //獲取LoadBalance balancer3 = LoadBalance::getInstance(); //獲取LoadBalance balancer4 = LoadBalance::getInstance(); //獲取LoadBalance //以上4個balancer 都應該為同一記憶體 if(balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) printf("Balancer is nnique"); //add server balancer1->addServer("server1"); balancer1->addServer("server2"); balancer1->addServer("server3"); balancer1->addServer("server4"); for(int i = 0;i&lt;10;i++){ printf("server %d",balancer1->getServer()); } return; } Singleton的問題 因為外部不能實例化，哪應該什麼時候實例化它呢?
從上面例子可以觀察到，第一次使用到getInstance()的時候,會先判斷是否為空,是的話會先實例化並保存pointer,然後再返回Instance。
如果在多線程(Multi-threading)下，同時call getInstance() 會這樣呢?
沒錯!就會導致違反了Sington的目的，導致系統錯誤的嚴重後果。
假如TA和TB 2個Thead 同時call getInstance(),此時這個instance是為null，所以他們都會同時滿足if(instance == null),並進行new instance,導致系統記憶體中會有2個Instance.
哪要如何解決呢?
以下提供了2個方法來解決
餓漢式 在定義class的時候就先把static variable先給實例化，因此，在加載時候就已經被實例化了。 可以想象成不管要不要用(吃)，先實例化了再說(把食物買了再說) (就怕自己會餓死 xD 問題: 可能會浪費資源，因為有可能會出現不使用的情況出現。 懶漢式 要使用的時候，先檢測是否存在，再實例化(就是上面例子一樣) 問題 1: 在多線程的情況下，會變得不安全。為了確保線程安全，就必須要用到Mutex進行保護(會增加開銷) 問題 2: 雖然有加上鎖，但是有可能線程會一起進入if 判斷，等一個thread解鎖了，另外一個還是會重新new 新的一個。因此，要在裡面加多一個if來判斷是否為null。這個稱為double-Check Locking 能克服餓漢式 以及 懶漢式的方法:
在Class內部定義static class來進行實現
因為static Singleton* instance 並不是Class Singleton的成員(Member)，所以在加載時候，不會被實例化，只有呼叫了getInstance 的時候才會被實例化。
class Singleton { private: Singleton() {} static class HolderClass { private: static Singleton* instance = new Singleton(); } public: static Singleton getInstance() { return HolderClass::instance } } } 優點 為系統提供了唯一的Instance 因只有一個Instance,能節省系統資源 在Singleton 模式中，除了唯一的，也可以提供指定數量的Instance，以解決分享過多造成的性能問題 缺點 難以擴展，因為Singleton 不是由 Abstract Class實現 違背原則 有點違反單一職責原則(Single-responsibility Principe) 因又是工廠的角色(new instance),又是Product的角色(返回Static 獲取實例) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Leetcode] Top K Frequent Elements(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode347/</url><categories><category>leetcode</category></categories><tags><tag>map</tag><tag>priority queue</tag><tag>array</tag></tags><content type="html"> LeetCode 347 - Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
example
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] How can we solve this problem? 這一題需要我們返回K個數量最多的element。所以，我們可以使用map記錄我們array中element的個數，然後在把他們以&lt;frequency,element>存到priority queue/max queue，最後只要返回priority queue中的k個element即可。
Solution: class Solution { public: vector&lt;int> topKFrequent(vector&lt;int>&amp; nums, int k) { vector&lt;int> res; unordered_map&lt;int,int> map; priority_queue&lt;pair&lt;int,int>> q; for(auto i : nums) map[i]++; //counter numbers for(auto it : map) q.push({it.second,it.first}); //according to the second for priority while(k-- > 0) { res.push_back(q.top().second); q.pop(); } return res; } };</content></entry><entry><title>[Leetcode] Kth Largest Element in a Stream(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode703/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 703 - Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. example:
Input ["KthLargest", "add", "add", "add", "add", "add"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 How can we solve this problem? 首先，我們要知道這個問題在問什麼。很簡單，這個問題問的是array中k個大元素。舉例 [1,2,3,4,5 ] k=3，需要我們求出三個最大的element，所以會是[3,4,5]。因此。我們只需要關心最大的K的element即可，其他都可以拋棄掉。
th largest element in the array, so we just need to know what the largest kth elements are. For example `[1,2,3,4,5 ] k=3`, the largest 3 elements are `[3,4,5]` right?. Therefore, we just need to consider the top k elements in the array and the other elements will be discarded. -- Solution: class KthLargest { private: priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; int k; public: KthLargest(int k, vector&lt;int>&amp; nums) { for(auto e : nums) { q.push(e); if(q.size() > k) q.pop(); } this->k = k; } int add(int val) { q.push(val); if(q.size() > k) q.pop(); return q.top(); } };</content></entry><entry><title>長庚大學-畢業專題獎項</title><url>https://ryantokmanmokmtm.github.io/achievement/my-first-reward/</url><categories><category>CGU</category><category>Reward</category></categories><tags/><content type="html"> Reward 這是我跟組員們一起討論、辛苦了多個日夜，能一起做寫程式，分享知識的感覺真的很棒>&lt;。雖然不知道以後還沒有機會一起合作，但還是非常感謝他們願意陪我躲在實驗室裡面一整天(╥╯^╰╥)。希望他們能好好生活，好好學習！
My Teammates</content></entry><entry><title>[Note]Creational Abstract Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-abstract-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Abstract Factory(抽象工廠)呢? 定義: 又稱為Kit模式。提供一個創建系列相關或者互相依賴的Interface，而無需指定其具體的class
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過定義不同組件的Abstraction類,並把Abstraction類組合在一起。通過繼承抽象工廠的方式，定義不同的工廠類，生成不同的Product。 由以下例子可見，有2組不同的UI分別是Summary以及Spring，他們都分包實現了Abstraction 類，然後在透過實現各自的工廠類，生成Summary以及Spring的Product //🌰UI //Button TextField ComboBox //Abstract Class UI class Button{ public: virtual void display() = 0; } class TextField{ public: virtual void display() = 0; } class ComboBox{ public: virtual void display() = 0; } //Abstract Class Factory //用於把不同類型的UI/主題Group 在一起 class UIFactory { public: virtual Button* createButton() = 0; virtual TextField* createTextField() = 0; virtual ComboBox* createComboBox() = 0; } //Spring class SpringButton : public Button{ public: void Draw(){ //Draw Spring style Button } } class SpringTextField : public TextField{ public: void Draw(){ //Draw Spring stype TextField } } class SpringComboBox : public ComboBox{ public: void Draw(){ //Draw Spring stype ComboBox } } //Summer class SummerButton : public Button{ public: void Draw(){ //Draw Summer style Button } } class SummerTextField : public TextField{ public: void Draw(){ //Draw Summer style TextField } } class SummerComboBox : public ComboBox{ public: void Draw(){ //Draw Summer style ComboBox } } //Factory class SpringFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SpringButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SpringTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SpringComboBox(); return ComboBox; }; } //SummerFactory class SummerFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SummerButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SummerTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SummerComboBox(); return ComboBox; }; } int main(){ //就是透過工廠生成接口生成不同的工廠 //再透過不同的工廠調用其生產的product //Summer 工廠 UIFactory* factory = new SummerFactory(); Button* button = factory->createButton(); TextField* textField = factory->createTextField(); ComboBox* comboBox = factory->createComboBox(); button->draw(); //畫出Summer Style的Button textField->draw(); //畫出Summer Style的textField comboBox->draw(); //畫出Summer Style的comboBox return; } 優點 解決工廠模式中每個產品都使用一個工廠的生產的問題 新增產品很方便，擴展產品以及工廠即可(增加統一產品族) 擁有工廠模式的優點 缺點 如果要新增產品等級結構必須修過工廠抽象類，違反Open-Close 原則(增加產品等級結構) 唯一缺點就是開閉原則的傾斜性 何謂開閉原則的傾斜性呢? 就是在新增產品族(不同類型，相同產品)的時候可以符合開閉原則,但是在新增產品等級結構(同一類型，新增產品/不同的產品類型/等級)時候,必須修改抽象類。這個問題無法解決，只能透過設計避免。 例子 新增A的產品族，只需實現工程類以及實現產品類型，即可新增一個新的工廠用於生成新產品(符合Open-Close) 新增A的類型(如一個新的UI原件:IMG),這樣就必須要修改abstract class以及concrete class的內部(違反Open-Close) 抽象工廠模式跟工廠模式的區別 模式 區別 工廠模式(Factory Pattern) 每一組相關的Product都由同一個具體工廠生產 抽象工廠模式(Factory Pattern) 每個產品族(product)都由同一個具體工廠生產 例如:
電器(同牌子/同一產品族)/電器(同電器(如都是冰箱)/同一產品等級結構)
產品等級結構: 產品的繼承結構,例如:同一種類的產品(如:同一電器但不同牌子)產品族:同一工廠生產的，位於不用產品等級結構的一組產品,例如:同一族群的產品(如:同一牌子的不同電器) 抽象工廠模式(abstract factory pattern)使用場合 當一個工廠的可以創立出屬於不同產品的等級結構的一個產品族中的所有對象時,此時使用抽象工廠模式更有效率和簡單
系統不應該依賴具體的細節(如何創建,表達細節等&hellip;)，依賴於抽象(所有工廠模式都一樣) 系統中多於一個產品族時，而每次只會使用到某一個產品族。可通過配置文件動態修改產品族 約束:屬於同一產品族的產品將在一起使用(同一類)，而這些產品可以沒有任何關係，但有相同約束(同一工廠) 產品等級結構穩定，在設計完成後不會在系統更改/刪除產品等級結構(開閉原則的傾斜性) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Simple RateLimiter Example Based on IP</title><url>https://ryantokmanmokmtm.github.io/post/simple-rateLimiter-example-based-on-IP/</url><categories><category>golang</category><category>backend</category><category>note</category><category>system design</category></categories><tags><tag>gin</tag><tag>rate limiter</tag></tags><content type="html"> 基於Gin實作Rate Limiter 假設我們有2個APIs,而每個API都需要消耗1個Tokens
uri method desc /api/posts/{id} GET return a simple demo message /ping GET return pong 我們先設置一下rate limiter桶子的容量只能放下一個tokens,而tokens則會每秒生產5個。存取API時,若沒有Token可以用，就需要等待token下一次生產並放到桶子裡，才能繼續進行下去。
var ( Rate = rate.Every(time.Millisecond * 200) //1s x 10 token ReqLimiter = rate.NewLimiter(RateLimiterRate, 1) ) Post API Controller exapmle type PostCase struct { } func (p *PostUseCase) GetPost(ctx *gin.Context) { //get params id id := ctx.Param("id") //from the path //use a token if err := limiter.ReqLimiter.Wait(ctx); err != nil { ctx.JSON(http.StatusRequestTimeout, gin.H{}) return } //wait for a token is available or return ctx.JSON(http.StatusOK, gin.H{ "msg": "succeed:" + id, }) } Ping API Controller exapmle type HealthCheck struct { } func (hc *HealthCheck) Pong(ctx *gin.Context) { limiter.ReqLimiter.Wait(ctx) ctx.JSON(http.StatusOK, gin.H{ "msg": "Pong", }) } 基於ClientIP 的Rate limiter 由於上面的的例子都是所有人公用一個Rate Limiter，因此，我們這裡簡單實作一個基於IP的Rate Limiter,相同IP下會公用一個Rate Limiter。
實作思路如下:
定義Map用於保存不同IP下的Rate Limiter 定義Rate Limiter的結構 定義一個移除Rate Limiter的function 用於移除不在線的用戶(只會跑一次) 保存Limiter的結構 包含了2個成員(Member):
Limters: 主要是用於保存不同IP下的Limiter(storage) Lock : 因為有可能會有很多人同時存取這個Map,為了防止Race condition,因此需要使用Mutex進行保護 type Limiters struct { Limiters map[string]*Limiter Lock sync.Mutex } 定義Rate Limiter的結構 包含了3個成員(Member):
Limter : 一個rate limiter的實例 LastAccess : 上次存取這個limiter的時間 type Limiter struct { limiter *rate.Limiter lastAccess time.Time } 定義獲取Rate Limiter的Function 這個function主要做的事情是獲取Client IP的Rate limiter(如果存在)。如果不存在,會新建一個新的Rate Limiter，並保存到Map(storage)中。
func (ls *Limiters) GetLimiter(r rate.Limit, b int, key string) *Limiter { ls.Lock.Lock() defer ls.Lock.Unlock() if limiter, ok := ls.Limiters[key]; ok { return limiter } newLimiter := &amp;Limiter{ limiter: rate.NewLimiter(r, b), lastAccess: time.Now(), //key: key, } ls.Limiters[key] = newLimiter return newLimiter } 定義一個定期檢查Rate Limiter的function 這個function的主要作用的是在設定的時候到達時，會檢查是否有用戶的沒有存取/訪問的時間已超過設定的時間。如果已超過便會從Limiters的Map中移除，以免資源的浪費
func (ls *Limiters) ClearNotUseLimiter(sec time.Duration) { for { time.Sleep(sec) //for now just set 1-minutes for testing //for all limiter for key, l := range ls.Limiters { if time.Now().Sub(l.lastAccess) > sec { ls.Lock.Lock() delete(ls.Limiters, key) log.Printf("limiter for ip:%v is removed", key) ls.Lock.Unlock() } } } } 實作例子 因為每個Request被處理前，必須先確保此用戶(Client IP)沒有超過限制的Request的數目。所以,每個進來的Request都會先經過Middleware做預處理，獲得token後，才能進到處理的程序。
Limiter Middleware 這個Middleware中會透過Request Header(context)裡附帶的Client IP 獲得一個Limiter,並透過此Limiter檢查是否可以獲取Token，如果存取為False會直接response 一個錯誤訊息TooManyRequest
func RateLimiter() gin.HandlerFunc { return func(ctx *gin.Context) { clientIP := ctx.ClientIP() res := app.NewResponse(ctx) if clientIP == "" { res.ErrorResponse(errCode.ClientError.WithDetail("Client agent info not found or error")) ctx.Abort() } //log.Println(clientIP) //limiter : 10 request for each user and a token will generate after 1s l := newLimiters( //1s to generate a token rate.Every(global.AppSetting.LimiterTokenTime), global.AppSetting.LimiterBucketSize, //there are total 10 buckets clientIP) if !l.Allow() { res.ErrorResponse(errCode.TooManyRequest) ctx.Abort() } ctx.Next() } } 獲取Rate Limiter的function如下圖所示。細心的朋友可以發現這個包含了1個onceTask.Do的東西，其實他就是一個go語言內置允許function只跑一次的情況。透過onceTask.Do就可以實現一個Function只跑一次，無論呼叫了幾次同一個function,這個function也會只跑一次，直到程序結束。
這個onceTask.Do所做的事只有1件，也就是檢測是否有用戶不活躍，不活躍的用戶會被移除。它另外一條goroutine中進行，並不會堵塞主goroutin
func newLimiters(r rate.Limit, b int, key string) *limiter.Limiter { onceTask.Do(func() { log.Println("run once") go global.Limiters.ClearNotUseLimiter(global.AppSetting.LimterClearTime) }) return global.Limiters.GetLimiter(r, b, key) } 以上便是基於IP實作Rate Limiter的簡單方法
參考資料:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><url>https://ryantokmanmokmtm.github.io/post/token-bucket-intro/</url><categories><category>golang</category><category>backend</category><category>note</category><category>algorithm</category><category>system design</category></categories><tags><tag>golang package</tag><tag>rate limiter</tag></tags><content type="html"> Token Bucket(令牌桶算法) 什麼是Token Bucket 呢? 簡單來說就是運用Token Bucket的系統會以一個設定的速率往桶子(Bucket)裡面丟令牌(Token)。如果請求(Request)需要被處理時，就必需得Bucket裡的Token。當桶子裡面的沒有Token可以分配/獲取時，也就是說Bucket現在是空的(Token已經被其他令牌拿完了)，系統則會拒絕這個請求的服務。
根據算法(Algorithm)的定義:
A token is added to the bucket every 1/r seconds. 一個Token會以每1/r秒加入到Bucket裡面。 The bucket can hold at the most b tokens. If a token arrives when the bucket is full, it is discarded. Bucket可以保存最多b個tokens。如果在bucket以及滿了的情況下，有一個token被加入到bucket，這個token會被丟棄 例子: 假設一個n bytes的packet(封包)送達 假設目前最少有n個token在桶子裡面，這n個token就會被拿出來，然後packet就會被送到網絡上(剛好n bytes 封包有n個tokens) 假設目前桶子裡面可存取的tokens少於n個，就不會有tokens被拿出來(因為需要n個tokens 才能傳送n bytes的封包)，這個封包會被考慮為不符合的封包/不合規的封包 Go 實現/使用Token Bucket Go 的time/rate package 提供了Limiter的實作，而這個Limiter便是實作了Token Bucket的方式來達到限流的目的。
今天我們就來學習一下這麼使用go 提供Limiter來實作Rate Limiter
要如何新增一個Limiter呢? func NewLimiter(r Limit, b int) *Limiter
他有2個參數:
r: rate的type是Limit(一個float64的值)，表示著每秒會產生多少個Token,也就是每1/r秒生產1個token到bucket裡 b: Token Bucket 的桶子的Capacity(容量) //r 設置100表示每秒會產生100個tokens到桶子裡面 1/100 s(1個) //b 設置為1表示桶子最多有1個token limiter := rate.NewLimiter(100,1) Limiter的使用方式 Limiter提供了多個Function: Allow,Reserve,Wait,AllowN,ReserveN,WaitN
最主要使用為以下的3個種Function(都會消耗一個Tokens):
Allow func (lim *Limiter) Allow() bool 是 AllowN(time.Now(), 1)的縮寫 它會消耗掉一個Tokens 如果有token的話會return true 否者會token不足 return false Reserve func (lim *Limiter) Reserve() *Reservation 是 ReserveN(time.Now(), 1)的縮寫 每次會消耗掉一個token 他主要的作用是保存event的資訊預約下一次的服務 Wait(用最多的function) func (lim *Limiter) Wait(ctx context.Context) (err error) 是 WaitN(ctx, 1)的縮寫 每次會消耗掉一個token 主要的作用就是等待直到被取消或者有足夠的Tokens Wait 會堵塞(block)直到有足夠的tokens才會往下執行 Allow func (lim *Limiter) Allow() bool func (lim *Limiter) AllowN(now time.Time, n int) bool Allow() 等價於(equivalent to) AllowN(time.Now(),1)
AllowN主要的作用
AllowN 表示的是在目前的時間點，是否能消耗n個token,如bucket存在n個token則 return true 否則 return false
是想要Drop或者Skip超過rate limit的events時使用 否則使用 Reserve 或者Wait取代 Use this method if you intend to drop / skip events that exceed the rate limit. Otherwise use Reserve or Wait.
//AllowN的例子: func AllowDemo() { //each token generated every 100ms with 5 bucket limiter := rate.NewLimiter(rate.Every(time.Microsecond * 100), 5) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ //each time we need 2 tokens if isAllowed := limiter.AllowN(time.Now(), 2); isAllowed { //bucket have enough tokens fmt.Println("Welcome!!!") fmt.Printf("user:%v is allowed in %v\n", counter, time.Now().Format(time.RFC3339)) } else { fmt.Printf("user:%v is not allowed.Please wait for 100ms and try again later\n", counter) //wait for 100ms time.Sleep(100 * time.Microsecond) } } } Reserve func (lim *Limiter) Reserve() *Reservation func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation Reserve() 等價於(equivalent to) ReserveN(time.Now(),1)
ReserveN的主要作用
ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
回傳一個Reservation 表面在event執行前需要等待多久，這個Reservation被limiter納入考量內
如果Reservation 的所需的token n超過bucket 的size時,Reservation 的OK()會return false
//Reserve例子: func ReserveDemo() { //each token generated every 200ms and each second will put at most 5 tokens to bucket limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 3) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ tokensNeeds := 2 reserve := limiter.ReserveN(time.Now(), tokensNeeds) if !reserve.OK() { //this event won't be completed due to the tokens its needs fmt.Printf("needed tokens %v is greater than the bucket size %v\n", tokensNeeds, limiter.Burst()) return } //wait for the reversing time fmt.Printf("Wait for %v ms...\n", reserve.Delay()) //if dely is 0 that means no need to wait~ time.Sleep(reserve.Delay()) //at least to wait for 200ms fmt.Printf("waiting is done and now is allowed to deal with some tasks...\n") fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC3339)) } } Wait func (lim *Limiter) Wait(ctx context.Context) (err error) func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) Wait(ctx) 等價於(equivalent to) wait(time.Now(),1)
waitN的主要作用
WaitN 每次需要消耗N個Tokens，如果Bucket沒有足夠的Bucket會堵塞，直到有足夠的Tokens(n)才會繼續往下只需。除非以下條件成立才會回傳錯誤:
所需消耗tokens n大於bucket的size Context 被取消 Context 已經超過設定的Deal line(等待時間超過了Deal line) //例子 func WaitDemo() { //at most 5 tokens will generate in a sec 200/1000=5 ctx := context.Background() limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 2) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ if err := limiter.WaitN(ctx, 2); err != nil { fmt.Println("error", err) return } //wait for 2 tokens. At most wait for 400ms fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC1123)) } } 設定Bucket 和 Rate 可透過func (lim *Limiter) SetBurst(newBurst int)設定 Bucket size
可透過func (lim *Limiter) SetLimit(newLimit Limit)設定 Limit/Rate
參考資料:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Creational-Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Factory(工廠)呢? 定義:建立一個接口,讓子類自己決定實現哪一個Factory,其重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
可透過子類繼承Factory的抽象類自主決定生產什麼樣的Product。 生產的Product在透過里氏替換原則(Lisko Subsititution princeple)替換成繼承與Logger的子類，即可換成的需要的Logger。 class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc... Logger* logger = new DatabaseLogger(); //init this logger etc... return logger } } //Client to use int main(){ Factory *factory = new FileLoggerFactory(); Logger *logger = factory->createLogger(); //return the Product that it is initialized Logger->wirteLog(); return; //如果想讓系統有更多靈活性和課擴展性，可以透過xml來進行配置，不需透過修過client的代碼 //只需更新xml中的設置，在代碼中新增新的Product 以及新增的Factory 並重新編譯便可 //除了默認的設置方法外，還想透過傳入String的方法來自定義設計，例如連接要DB，文件的路徑等等 //可以透過Override Abstruct class 的func來進行設置 /* class Factory{ public: virtual Logger* createLogger() = 0; virtual Logger* createLogger(string config) = 0; virtual Logger* createLogger(Object obj) = 0;//通過Obj裡面的成員進行設置等 } */ } 優點 Client無需知道Object的設置的細節，也無需知道實質Object的名稱，只需通過工廠即可 工廠(Factory)以及產品(Product)都是透過Polymorphism(多態)來實現，也是工廠模式的關鍵，工廠可以自主的決定要生產什麼產品，在內部進行設置產品(封裝在內部) 加入新的Product時無需修改Abstract class 以及 具體的工廠和產品的類，只要擴展新增即可，符合Open-Close principle 透過繼承抽象類使系統更容易擴展 缺點 新增產品時，要加入新的產品類以及工廠類，增加了系統的複雜度，而且需要從新編譯，增加了開銷 為了擴展性,加入了抽象類，Client都使用Abstract class 進行編程，增加了系統的抽象性和理解難度 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Creational-Simple Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-simple-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Simple Factory(簡單工廠)呢? 簡單而言就是: 由一個工廠來生產全部產品 定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過Factory 類的Static 方法調用方法，傳入參數生成相關的Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == "A"){ return new ProductA(); } else if(type == "B"){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct("A"); //get ProductA instance Product* B = Factory::getProduct("B"); //get ProductB instance } 優點 Client可以自行決定生產哪個Product Client免除直接建立Product的責任，只僅僅消費產品 Client無需關心具體的類名與相關設置參數 缺點 Factory 的職責太重。所有的Product 都由一個Object 生產，一旦不能正常工作，便會影響整個系統的運作 如有不同的Product會增加系統中的class的數目，增加了系統複雜度以及理解難度 擴展十分困難，添加需要修改Factory的邏輯。如果生存的Product較多時，可能會使其邏輯過於複雜，不利於系統的擴展與維護 違背原則 違背了Open-Close Principe 如果有新的Product 需要生成，就必修要修改Factory類 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Design Pattern Princeple</title><url>https://ryantokmanmokmtm.github.io/post/design-pattern-princeple/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>learning</tag><tag>note</tag></tags><content type="html"> 什麼是Design Pattern(設計模式)呢? 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，如何解決問題的一種方案
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。 設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
Design Pattern 有什麼原則呢? 原則(Princeple) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) Design Pattern 分成哪幾種呢? 主要分成3大類，一共23個
創建型模式(6個) 結構型模式(7個) 行為型模式(11個) 創建型模式(6個) 簡單工廠模式(Simple Factory Pattern) 工廠模式(Factory Pattern) 抽象工廠模式(Abstract Factory Pattern) 單例模式(Singleton Pattern) 原形模式(Prototype Pattern) 建立者模式(Builder Pattern) 結構型模式(7個) 適配器模式(Adapter Pattern) 橋接模式(Bridge Pattern) 組合模式(Composite Pattern) 裝飾模式(Decorator Pattern) 外觀模式(Facade Pattern) 享元模式(FlayWeight Pattern) 代理模式(Proxy Pattern) 行為型模式(11個) 職責鏈模式(Chain of Responsibility Pattern) 命令模式(Command Pattern) 解釋器模式(Interpreter Pattern) 迭代器模式(Iterator Pattern) 中介者模式(Mediator Pattern) 備忘錄模式(Memento Pattern) 觀察者模式(Observer Pattern) 狀態模式(State Pattern) 策略模式(Strategy Pattern) 板塊模式(Template Method Pattern) 訪問者模式(Visitor Pattern) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]What Is JWT(Json Web Token)-EN</title><url>https://ryantokmanmokmtm.github.io/post/jwt-note/</url><categories><category>backend</category><category>development</category><category>web develpment</category><category>note</category><category>english</category></categories><tags><tag>web develpment</tag><tag>token</tag></tags><content type="html"> What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:
Header Payload Signature JWT Header Header typically consists of two parts
type : what&rsquo;s the type of the token algorithm : what algorithm does this token use to sign/encrypt. such as SHA256,RAS or HMAC { "typ" : "jwt", "alg" : "HS256" } This information will be encoded by base64Url algorithm in order to generate the JWT Header
JWT payload In payload is typically saving some users information and other useful information.
Be carefulthat payload must not include any secret information due to base64Url algorithm is easy to be decrypted.
JWT Payload standard claims
{ "sub" :"",//subject "aud" :"",//audience "jti" :"",//jwt id "iat" :"",//Issued at "iss" :"",//Issuer - who is the publisher of the jwt "nbf" :"",//Not Before - JWT is not available before the time jwt set. // other user information that developer set //for example: "user_name" : "jackson_tmm", "email" : "admin@admin.com" } This information will be encoded by base64Url algorithm in order to generate the JWT Payload
Signature The Signature is used to authenticate whether information has been modified during transmission and authenticate the sender that sent this JWT.
To Generate JWT Token Following this function
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), your-256-bit-secret) And these three partes will be combined by a . as following format: xxx.yyy.zzz
//exmaple eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ How it work between Client and server sequenceDiagram Client-Server:POST /authentication {username:xxx..} Note over Client,Server: User logs in alt is authenticated Server-Client:HTTP Status:200 {"token":eyxxx.xx.x} Note over Server,Client: Loged in Succeed else Unauthorized Server-Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Loged in Failed end Client-Server: POST /user/profile {"Authorization":"Bear token"} Note over Server,Client: Get User Profile with token alt succeed Server--Client: HTTP Status:200 {"profile":eyxxx.xx.x} Note over Server,Client: Succeed and response a profile else Unauthorized Server--Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Unauthorized(token error) end</content></entry><entry><title>[CGU]Graduation Project</title><url>https://ryantokmanmokmtm.github.io/project/final-project/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> OTT Movies recommender system-IOS Client
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database Demo Video
In Progress User chatting UI User profile Demo(參考小紅書)</content></entry><entry><title>About me</title><url>https://ryantokmanmokmtm.github.io/about.html</url><categories/><tags/><content type="html"> 個人簡歷 Introduction 你好~ 歡迎來到我的網站!
我是Jackson.tmm, 是一個從香港來到台灣讀大學的四年級學生。目前就讀於長庚大學-資訊工程學系(Computer Science And Information Engineering)。
More About me 我超喜歡TFBoy的，是TFBoys的忠實粉絲,特別是易烊千璽(Jackson yee)！！！我叫Jackson也是這個原因，想跟千璽一樣強！哈哈哈。從他們出道開始就開始喜歡他們了(應該快9年了)。
除了寫程式以外，我也喜歡設計跟音樂！你沒看錯，我一個後端喜歡設計，哈哈哈哈(不要問我為什麼不選前端，哈哈哈)
Why i choose Computer Science? 要從我小時候獲得了一台單核心CPU,512MB RAM,還沒有DisplayCard的電腦開始說起(雖然很爛)。哪個時候因為喜歡玩遊戲，所以,對於遊戲製作這件事是哪時候的夢想。直到了中學(大概是國一或國二)，因某某網絡遊戲關服，但卻對此心有不甘。所以，便與網絡上認識的小夥伴一起研究放出來的源代碼(雖然看不太懂)，這也是我接觸程式的開始。到了高中我便一心想要往Computer Science方向前進，也因此選擇了Information Computer Technology(ICT)科目。雖然我其他科目的成績沒有很好，但是在ICT的這門科中，連續拿了3年的第一名。但是因為高考失利，但又希望自己能學習到CS相關的科目，因此來到了台灣就讀CS科系。
A special and meaningful experience during my university 上大學以後，也是正式開始學習程式設計的開始。可能是以前有自學過一段時間C++，學起來比較輕鬆一點。大二下的時候，很不辛COVIN-19疫情爆發，不能會台灣只能留在香港上網絡課程，因此，便開始了我的自學之路。由於有了學習C++的經驗以及程式語言的基礎，便開始自我探索模式，嘗試接觸不同的領域。了解過網頁設計,後端開發,數據庫設計,Apple App開發,ML/TensorFlow基礎,甚至是其他領域的探索如遊戲開發，美術設計，3D建模等等&hellip;這段自學探索的旅程,貌似看上去毫無意義(也就是啥都學，沒有一個是精的)。但是，對我來說有巨大的意義，能夠讓我更認識自己，知道自己喜歡的東西，不喜歡的東西，甚至是知道哪些學習方法是適合自己。雖然很想什麼都想要會，但是也決定了只做自己感興趣的事情。以下是我在這段時間所做的東西(你們應該不會嫌棄吧>&lt;)
第一次學習IOS開發的Demo 基於IOS的Netfilx UI Clone 基於IOS的微博UI Clone 第一次學遊戲開發的作品 第一次學建模的作品 送給自己20歲的生日禮物的一顆排球模型 模擬水還是很好玩的(渲染了12小時 (◑‿◐) ) 燈籠魚(Lophiiformes)作品 第一次網絡課學習建模的作業 第一次網絡課學習建模的結課作品(還沒上貼圖>&lt;,有空就上) Interest 跑步，打球，說唱，唱歌，看電影，看動漫 遊戲設計，遊戲美術，3D建模 搞設計，寫程式 跟朋友分享、交流 特別喜歡宇宙/人類起源相關的奇怪知識 Current Plan 學更多有關後端開發，系統設計相關的技術 學好英文(看電影不要看字幕，能更外國人交流的程度) 考好雅思 做好自己,不比較,但一起學習一起進步 Contact Me: Email @Jacksontmm in Telegram</content></entry></search>