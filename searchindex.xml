<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Trim a Binary Search Tree</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode669/</url><categories><category>leetcode</category></categories><tags><tag>binary Search Tree</tag><tag>binary Tree</tag><tag>recursion</tag></tags><content type="html"> LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.
Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.
example
Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] How can we solve this problem? We are going to apply the recursive function. Because the Input is a binary search tree and all left child nodes of the low node are less than the low node. So, the simple solution is that change its parent&rsquo;s left child to its right child node. And the heigh bound is similar to low bound solution but changes its parent&rsquo;s right child to its left child node.
The solving steps: Find the low bound node and the heigh bound node Low bound 1. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { //space : O(tree node size for all nodes value are between low and height) //time : O(tree node size for all nodes) return TrimBST(root,low,high); } TreeNode* TrimBST(TreeNode* root,int low,int height){ if(!root) return nullptr; //if the root value is less than height ,go right sub-tree //if the root value is greater than low ,go left sub-tree if(root->val &lt; low){ // root->left = nullptr; return TrimBST(root->right,low,height); }else if(root->val > height){ // root->right = nullptr; return TrimBST(root->left,low,height); } //left root->left = TrimBST(root->left,low,height); //right root->right = TrimBST(root->right,low,height); // cout &lt;&lt; root->val &lt;&lt; "\n"; return root; } };</content></entry><entry><title>Search in a Binary Search Tree(easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode700/</url><categories><category>leetcode</category></categories><tags><tag>binary search tree</tag><tag>recursion</tag><tag>binary Tree</tag></tags><content type="html"> LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
example
Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5 Output: [] How can we solve this problem? Before solving this problem, we need to kown what is a Binary Search Tree. According to Binary Search Tree definition:
Binary Search Tree is base on a Binary Tree All elememts in left sub-tree are less than root value All elememts in right sub-tree are greater than root value Key/Value in Binary Search Tree are unique Now we know what is a Binary Search Tree, so we can start to solve this problem. This problem is asking about the sub-tree of the value. For solving this problem, we can use recursion to help us to search the value by applying some rules of Binary Search Tree:
All elememts in left sub-tree are less than root value All elememts in right sub-tree are greater than root value If the val is less than the root value, pass the left child pointer to the recursive function. Otherwise, pass the right child pointer to the recursive function. After it finds the value, return its root as the result.
The solving steps: Define a recursive function for binary search Define some conditions for searching If the value is found ,return the root. Otherwise return NULL /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(root == nullptr) return root; //check val if(root->val > val){ //go to left return searchBST(root->left,val); // }else if(root->val &lt; val){ return searchBST(root->right,val); }else{ return root; } } };</content></entry><entry><title>Shift 2D Grid(easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1260/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag></tags><content type="html"> LeetCode 1260 - Shift 2D Grid Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times.
example
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] How can we solve this problem? This question is easy, but we need to care about the last column of the grid if it right-shifts to the first column of the grid, the last element of this column becomes the first and the others will move down by 1 step. In order to solve this question, we can use math to help us:
n is the row size and m is the column size
left-shifting : currentColum + k % n, moving by k step shifting row : (j + k) / n), if it is in the last column, (j + k) / m will be 1. Otherwise will be 0 total row shifting step : (i + (j + k) / n)) % m. For example, suppose n = 3 , j = 2 , m = 3 and i = 2: (2 + ((2+1)/3)) % 3 = 0 so that it will move to [0][0] The solving steps: iterate the array and apply the formula to calumniate new row and column index. store the number to the new new row and column index class Solution { public: vector&lt;vector&lt;int>> shiftGrid(vector&lt;vector&lt;int>>&amp; grid, int k) { //just be careful the last element on [m-1][n-1] //n - k int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); for(int i = 0 ;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ //here we need to know how many time does the colums j pass the col 0,then we need to movie the i of that time // (j + k) % m => total time walk passed int moveJ = (j + k) % m; //if current moving j is the last one int walkPassedZeorTimes = (j + k)/m; int moveI = (i + walkPassedZeorTimes) % n; res[moveI][moveJ] = grid[i][j]; } } return res; } };</content></entry><entry><title>Spiral Matrix II(medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode59/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 59 - Spiral Matrix II Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
example
Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Input: n = 1 Output: [[1]] How can we solve this problem? First thing first, let&rsquo;s think about how we can insert a number into an array spirally? Can we just simply set a boundary of row and column to limit its inserted direction? YES! You Can! Let me explain how it works. According to the example, we can find out its moving pattern(top-left to top-right,top-right to bottom-right,bottom-right to bottom-left and bottom-left to top left), it always follows these 4 moving patterns, so that we can define a boundary of row and column to limit pointer moving to has inserted a number. Until reaching n2, it will break the loop and return the answer.
The solving steps: Define the upper boundary, lower boundary of row and column. Follow the moving pattern(top-left to top-right,top-right to bottom-right,bottom-right to bottom-left and bottom-left to top left) and update upper boundary, lower boundary depending on what moving pattern it has done. Until reaching n2, then return the answer class Solution { public: vector&lt;vector&lt;int>> generateMatrix(int n) { //total step n^2 vector&lt;vector&lt;int>> res(n,vector&lt;int>(n,0)); int c = 1; int upperRow = 0,lowerRow = n - 1; int upperCol = 0,lowerCol = n - 1; while(c &lt;= n*n){ //moving left if(upperCol &lt;= lowerCol){ //n step for(int i = upperCol;i&lt;=lowerCol;i++){ res[upperRow][i] = c++; } } upperRow ++; //moving down //moving down if(upperRow &lt;= lowerRow){ for(int i = upperRow;i&lt;=lowerRow;i++){ res[i][lowerCol] = c++; } } lowerCol--; //moving right if(lowerCol >= upperCol){ for(int i = lowerCol;i>=upperCol;i--){ res[lowerRow][i] = c++; } } lowerRow --; //moving up if(lowerRow >= upperRow){ for(int i = lowerRow;i>=upperRow;i--){ res[i][upperCol] = c++; } } upperCol ++; } return res; } };</content></entry><entry><title>Game of Life(medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode289/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 289 - Game of Life According to Wikipedia&rsquo;s article: &ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&rdquo;
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.
example
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] How can we solve this problem? For solving this problem, we need to know what the current cell state is(dead or alive). After that,we just need to check its neighbor cell' s state by the rules to determine the cell state. Because the maximum number of its neighbor cells is 9, from top to bottom and left to right. So, we can simply use some conditions to check.
The solving steps: iterate the array and check the cell state. Get the new state of the cell by applying the 4 rules class Solution { public: void gameOfLife(vector&lt;vector&lt;int>>&amp; board) { int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); //O(N^2 for checking each cells) : time //O(N^2 for storing new cells states) : space for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ int total = checkState(board,i,j,n,m); if(board[i][j] == 1) res[i][j] = (total &lt; 2 || total > 3 ) ? 0 : 1; else res[i][j] = total == 3 ? 1 : 0; } } board = res; } int checkState(vector&lt;vector&lt;int>>&amp; board,int i,int j,int n,int m){ // //neighbors bounds // int rowStart = (i - i) &lt; 0 ? 0 : i - 1; // int rowEnd = (i + 1) > n - 1 ? n - 1 : i + 1; // int colStart = (j - 1) &lt; 0 ? 0 : j - 1; // int colEnd = (j + 1) > m - 1 ? m - 1 : j + 1; int livesCells = 0; //top left if(i - 1 >= 0 &amp;&amp; j -1 >= 0){ livesCells += board[i-1][j-1]; } //top if(i - 1 >= 0){ livesCells += board[i-1][j]; } //top right if(i - 1 >= 0 &amp;&amp; j + 1 &lt; m){ livesCells += board[i-1][j + 1]; } //left if(j - 1 >= 0){ livesCells += board[i][j - 1]; } //right if(j + 1 &lt; m){ livesCells += board[i][j + 1]; } //bottom left if(i + 1 &lt; n &amp;&amp; j - 1 >= 0){ livesCells += board[i+1][j-1]; } //bottom if(i + 1 &lt; n ){ livesCells += board[i+1][j]; } //bottom right if(i + 1 &lt; n &amp;&amp; j + 1 &lt; m){ livesCells += board[i+1][j+1]; } return livesCells; } };</content></entry><entry><title>Baseball Game(easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode682/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 682 - Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&rsquo; scores.
At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:
An integer x - Record a new score of x. &ldquo;+&rdquo; - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. &ldquo;D&rdquo; - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. &ldquo;C&rdquo; - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. example
Input: ops = ["5","2","C","D","+"] Output: 30 Explanation: "5" - Add 5 to the record, record is now [5]. "2" - Add 2 to the record, record is now [5, 2]. "C" - Invalidate and remove the previous score, record is now [5]. "D" - Add 2 * 5 = 10 to the record, record is now [5, 10]. "+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Input: ops = ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation: "5" - Add 5 to the record, record is now [5]. "-2" - Add -2 to the record, record is now [5, -2]. "4" - Add 4 to the record, record is now [5, -2, 4]. "C" - Invalidate and remove the previous score, record is now [5, -2]. "D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. "9" - Add 9 to the record, record is now [5, -2, -4, 9]. "+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. "+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. How can we solve this problem? This question is simply simulating a baseball game. We just need to care about games rules and store the score separately into any container like array or stack.
The solving steps: iterate the array and determine the score by applying the game rules. store the score into a stack or array return sum up numbers storted in the container. class Solution { public: int calPoints(vector&lt;string>&amp; ops) { //ops : + D C x // vector&lt;int> s; //or using a stack stack&lt;int> sk; //O(n) //O(n) for(auto i : ops) { if(i == "+"){ int a = sk.top(); sk.pop(); int b = sk.top(); sk.push(a); sk.push(a+b); }else if(i == "D"){ sk.push(sk.top() * 2); }else if(i == "C"){ sk.pop(); }else{ sk.push(stoi(i)); } } int res = 0; //O(n) while(!sk.empty()){ res += sk.top();sk.pop(); } return res; } };</content></entry><entry><title>[Note]Creational Singleton Pattern</title><url>https://ryantokmanmokmtm.github.io/post/creational-singleton-pattern/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> ä»€éº¼æ˜¯Singleton Pattern(å–®ä¾‹æ¨¡å¼)å‘¢? å®šç¾©:ä¸€å€‹Classåœ¨ç³»çµ±ä¸­åªæœƒå­˜åœ¨ä¸€å€‹å¯¦ä¾‹(instance),æ•´å€‹ç³»çµ±ä¸­åªæä¾›1å€‹å¯ä½¿ç”¨çš„instance,ä»¥ç¢ºä¿å”¯ä¸€æ€§,ä¸¦ç¯€çœç³»çµ±è³‡æºã€‚
ç°¡å–®ä¾‹å­ æ³¨: ä»¥ä¸‹ç¨‹å¼å–®ç´”ç”¨æ–¼è§£é‡‹ï¼Œä¸¦ä¸èƒ½å¯¦éš›åŸ·è¡Œ
classçš„å»ºæ§‹å­(constructor)å°å¤–éš±è—,å¤–éƒ¨ç„¡æ³•é€šéconstructoré€²è¡Œå¯¦ä¾‹åŒ–ï¼Œä½†æœƒæä¾›ä¸€å€‹éœæ…‹(static)æ–¹æ³•ï¼Œä»¥ç²å–é€™å€‹classçš„å”¯ä¸€å¯¦ä¾‹ã€‚ TaskManager
//Constructor å°å¤–éš±è—ï¼Œä¸¦æä¾›ä¸€å€‹éœæ…‹Static è®“å¤–éƒ¨åªé€éé€™å€‹å­˜å– class TaskManager{ private: TaskManager(); void displayProcess(); void displayServices(); static TaskManager* taskManager = nullptr; //ä¿å­˜å”¯ä¸€Instance public: //å¤–éƒ¨åªèƒ½é€ééœæ…‹Static æ–¹æ³•å­˜å– ä¸¦newä¸€å€‹TaskMangerçš„Instance å¦‚æœæ˜¯nullçš„ //æ­¤æ–¹æ³•ç‚ºå·¥å»  static TaskManager* getInstance(){ if(taskManager == nullptr){ taskManager = new TaskManager(); } return TaskManager; } } LoadBalance
//LoadBalance ğŸŒ° //ç”¨æ–¼è¨ˆç®—æœå‹™å™¨è² è¼‰ï¼Œæ‰€ä»¥å¿…é ˆä½¿ç”¨å–®ä¾‹ class LoadBalance{ public: static LoadBalance* getInstance(){ if(loadBalance == nullptr){ loadBalance = new LoadBalance(); } return LoadBalance; } private: static LoadBalance* loadBalance; LinkedList* serverList = nullptr; LoadBalance(); void addServer(std::string server){ serverList->add(server);//add a server } std::string getServer(){ int i = random()% serverList->length(); //random get server return serverList->get(i); } } int main(){ LoadBalance *balancer1,*balancer2,*balancer3,*balancer4; balancer1 = LoadBalance::getInstance(); //ç²å–LoadBalanceï¼Œé€™è£¡æœƒå…ˆnew å†return balancer2 = LoadBalance::getInstance(); //ç²å–LoadBalance balancer3 = LoadBalance::getInstance(); //ç²å–LoadBalance balancer4 = LoadBalance::getInstance(); //ç²å–LoadBalance //ä»¥ä¸Š4å€‹balancer éƒ½æ‡‰è©²ç‚ºåŒä¸€è¨˜æ†¶é«” if(balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) printf("Balancer is nnique"); //add server balancer1->addServer("server1"); balancer1->addServer("server2"); balancer1->addServer("server3"); balancer1->addServer("server4"); for(int i = 0;i&lt;10;i++){ printf("server %d",balancer1->getServer()); } return; } Singletonçš„å•é¡Œ å› ç‚ºå¤–éƒ¨ä¸èƒ½å¯¦ä¾‹åŒ–ï¼Œå“ªæ‡‰è©²ä»€éº¼æ™‚å€™å¯¦ä¾‹åŒ–å®ƒå‘¢?
å¾ä¸Šé¢ä¾‹å­å¯ä»¥è§€å¯Ÿåˆ°ï¼Œç¬¬ä¸€æ¬¡ä½¿ç”¨åˆ°getInstance()çš„æ™‚å€™,æœƒå…ˆåˆ¤æ–·æ˜¯å¦ç‚ºç©º,æ˜¯çš„è©±æœƒå…ˆå¯¦ä¾‹åŒ–ä¸¦ä¿å­˜pointer,ç„¶å¾Œå†è¿”å›Instanceã€‚
å¦‚æœåœ¨å¤šç·šç¨‹(Multi-threading)ä¸‹ï¼ŒåŒæ™‚call getInstance() æœƒé€™æ¨£å‘¢?
æ²’éŒ¯!å°±æœƒå°è‡´é•åäº†Singtonçš„ç›®çš„ï¼Œå°è‡´ç³»çµ±éŒ¯èª¤çš„åš´é‡å¾Œæœã€‚
å‡å¦‚TAå’ŒTB 2å€‹Thead åŒæ™‚call getInstance(),æ­¤æ™‚é€™å€‹instanceæ˜¯ç‚ºnullï¼Œæ‰€ä»¥ä»–å€‘éƒ½æœƒåŒæ™‚æ»¿è¶³if(instance == null),ä¸¦é€²è¡Œnew instance,å°è‡´ç³»çµ±è¨˜æ†¶é«”ä¸­æœƒæœ‰2å€‹Instance.
å“ªè¦å¦‚ä½•è§£æ±ºå‘¢?
ä»¥ä¸‹æä¾›äº†2å€‹æ–¹æ³•ä¾†è§£æ±º
é¤“æ¼¢å¼ åœ¨å®šç¾©classçš„æ™‚å€™å°±å…ˆæŠŠstatic variableå…ˆçµ¦å¯¦ä¾‹åŒ–ï¼Œå› æ­¤ï¼Œåœ¨åŠ è¼‰æ™‚å€™å°±å·²ç¶“è¢«å¯¦ä¾‹åŒ–äº†ã€‚ å¯ä»¥æƒ³è±¡æˆä¸ç®¡è¦ä¸è¦ç”¨(åƒ)ï¼Œå…ˆå¯¦ä¾‹åŒ–äº†å†èªª(æŠŠé£Ÿç‰©è²·äº†å†èªª) (å°±æ€•è‡ªå·±æœƒé¤“æ­» xD å•é¡Œ: å¯èƒ½æœƒæµªè²»è³‡æºï¼Œå› ç‚ºæœ‰å¯èƒ½æœƒå‡ºç¾ä¸ä½¿ç”¨çš„æƒ…æ³å‡ºç¾ã€‚ æ‡¶æ¼¢å¼ è¦ä½¿ç”¨çš„æ™‚å€™ï¼Œå…ˆæª¢æ¸¬æ˜¯å¦å­˜åœ¨ï¼Œå†å¯¦ä¾‹åŒ–(å°±æ˜¯ä¸Šé¢ä¾‹å­ä¸€æ¨£) å•é¡Œ 1: åœ¨å¤šç·šç¨‹çš„æƒ…æ³ä¸‹ï¼Œæœƒè®Šå¾—ä¸å®‰å…¨ã€‚ç‚ºäº†ç¢ºä¿ç·šç¨‹å®‰å…¨ï¼Œå°±å¿…é ˆè¦ç”¨åˆ°Mutexé€²è¡Œä¿è­·(æœƒå¢åŠ é–‹éŠ·) å•é¡Œ 2: é›–ç„¶æœ‰åŠ ä¸Šé–ï¼Œä½†æ˜¯æœ‰å¯èƒ½ç·šç¨‹æœƒä¸€èµ·é€²å…¥if åˆ¤æ–·ï¼Œç­‰ä¸€å€‹threadè§£é–äº†ï¼Œå¦å¤–ä¸€å€‹é‚„æ˜¯æœƒé‡æ–°new æ–°çš„ä¸€å€‹ã€‚å› æ­¤ï¼Œè¦åœ¨è£¡é¢åŠ å¤šä¸€å€‹ifä¾†åˆ¤æ–·æ˜¯å¦ç‚ºnullã€‚é€™å€‹ç¨±ç‚ºdouble-Check Locking èƒ½å…‹æœé¤“æ¼¢å¼ ä»¥åŠ æ‡¶æ¼¢å¼çš„æ–¹æ³•:
åœ¨Classå…§éƒ¨å®šç¾©static classä¾†é€²è¡Œå¯¦ç¾
å› ç‚ºstatic Singleton* instance ä¸¦ä¸æ˜¯Class Singletonçš„æˆå“¡(Member)ï¼Œæ‰€ä»¥åœ¨åŠ è¼‰æ™‚å€™ï¼Œä¸æœƒè¢«å¯¦ä¾‹åŒ–ï¼Œåªæœ‰å‘¼å«äº†getInstance çš„æ™‚å€™æ‰æœƒè¢«å¯¦ä¾‹åŒ–ã€‚
class Singleton { private: Singleton() {} static class HolderClass { private: static Singleton* instance = new Singleton(); } public: static Singleton getInstance() { return HolderClass::instance } } } å„ªé» ç‚ºç³»çµ±æä¾›äº†å”¯ä¸€çš„Instance å› åªæœ‰ä¸€å€‹Instance,èƒ½ç¯€çœç³»çµ±è³‡æº åœ¨Singleton æ¨¡å¼ä¸­ï¼Œé™¤äº†å”¯ä¸€çš„ï¼Œä¹Ÿå¯ä»¥æä¾›æŒ‡å®šæ•¸é‡çš„Instanceï¼Œä»¥è§£æ±ºåˆ†äº«éå¤šé€ æˆçš„æ€§èƒ½å•é¡Œ ç¼ºé» é›£ä»¥æ“´å±•ï¼Œå› ç‚ºSingleton ä¸æ˜¯ç”± Abstract Classå¯¦ç¾ é•èƒŒåŸå‰‡ æœ‰é»é•åå–®ä¸€è·è²¬åŸå‰‡(Single-responsibility Principe) å› åˆæ˜¯å·¥å» çš„è§’è‰²(new instance),åˆæ˜¯Productçš„è§’è‰²(è¿”å›Static ç²å–å¯¦ä¾‹) åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>Top K Frequent Elements(Midium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode347/</url><categories><category>leetcode</category></categories><tags><tag>map</tag><tag>priority queue</tag><tag>array</tag></tags><content type="html"> LeetCode 347 - Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
example
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] How can we solve this problem? For solving this problem, we need to know the frequency of each number in the array, so we need to iterate the array and it will take O(n) times for counting, also the frequency of each number needs to be stored in a place(like map). Then we can get the answer by ascending order of the frequency(using priority queue).
The solving steps: iterate the array and store the frequency of each number to a map reverse all key and value that stored in the map and push to a priority queue. get the top k element from the priority queue class Solution { public: vector&lt;int> topKFrequent(vector&lt;int>&amp; nums, int k) { vector&lt;int> res; unordered_map&lt;int,int> map; priority_queue&lt;pair&lt;int,int>> q; for(auto i : nums) map[i]++; //counter numbers for(auto it : map) q.push({it.second,it.first}); //according to the second for priority while(k-- > 0) { res.push_back(q.top().second); q.pop(); } return res; } };</content></entry><entry><title>Kth Largest Element in a Stream(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode703/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 703 - Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. example:
Input ["KthLargest", "add", "add", "add", "add", "add"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 How can we solve this problem? First thing first, we need to know what this problem is asking about. This question is asking about what is the kth largest element in the array, so we just need to know what the largest kth elements are. For example [1,2,3,4,5 ] k=3, the largest 3 elements are [3,4,5] right?. Therefore, we just need to consider the top k elements in the array and the other elements will be discarded.
The solving steps: using priority queue with greater/maxinum cmp or using min heap. keep the largest k elements. return the last element/top element(the size of the queue is k) class KthLargest { private: priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; int k; public: KthLargest(int k, vector&lt;int>&amp; nums) { for(auto e : nums) { q.push(e); if(q.size() > k) q.pop(); } this->k = k; } int add(int val) { q.push(val); if(q.size() > k) q.pop(); return q.top(); } };</content></entry><entry><title>é•·åºšå¤§å­¸-ç•¢æ¥­å°ˆé¡Œçé …</title><url>https://ryantokmanmokmtm.github.io/achievement/my-first-reward/</url><categories><category>CGU</category><category>Reward</category></categories><tags/><content type="html"> Reward é€™æ˜¯æˆ‘è·Ÿçµ„å“¡å€‘ä¸€èµ·è¨è«–ã€è¾›è‹¦äº†å¤šå€‹æ—¥å¤œï¼Œèƒ½ä¸€èµ·åšå¯«ç¨‹å¼ï¼Œåˆ†äº«çŸ¥è­˜çš„æ„Ÿè¦ºçœŸçš„å¾ˆæ£’>&lt;ã€‚é›–ç„¶ä¸çŸ¥é“ä»¥å¾Œé‚„æ²’æœ‰æ©Ÿæœƒä¸€èµ·åˆä½œï¼Œä½†é‚„æ˜¯éå¸¸æ„Ÿè¬ä»–å€‘é¡˜æ„é™ªæˆ‘èº²åœ¨å¯¦é©—å®¤è£¡é¢ä¸€æ•´å¤©(â•¥â•¯^â•°â•¥)ã€‚å¸Œæœ›ä»–å€‘èƒ½å¥½å¥½ç”Ÿæ´»ï¼Œå¥½å¥½å­¸ç¿’ï¼
My Teammates</content></entry><entry><title>[Note]Creational Abstract Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-abstract-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> ä»€éº¼æ˜¯Abstract Factory(æŠ½è±¡å·¥å» )å‘¢? å®šç¾©: åˆç¨±ç‚ºKitæ¨¡å¼ã€‚æä¾›ä¸€å€‹å‰µå»ºç³»åˆ—ç›¸é—œæˆ–è€…äº’ç›¸ä¾è³´çš„Interfaceï¼Œè€Œç„¡éœ€æŒ‡å®šå…¶å…·é«”çš„class
ç°¡å–®ä¾‹å­ æ³¨: ä»¥ä¸‹ç¨‹å¼å–®ç´”ç”¨æ–¼è§£é‡‹ï¼Œä¸¦ä¸èƒ½å¯¦éš›åŸ·è¡Œ
é€éå®šç¾©ä¸åŒçµ„ä»¶çš„Abstractioné¡,ä¸¦æŠŠAbstractioné¡çµ„åˆåœ¨ä¸€èµ·ã€‚é€šéç¹¼æ‰¿æŠ½è±¡å·¥å» çš„æ–¹å¼ï¼Œå®šç¾©ä¸åŒçš„å·¥å» é¡ï¼Œç”Ÿæˆä¸åŒçš„Productã€‚ ç”±ä»¥ä¸‹ä¾‹å­å¯è¦‹ï¼Œæœ‰2çµ„ä¸åŒçš„UIåˆ†åˆ¥æ˜¯Summaryä»¥åŠSpringï¼Œä»–å€‘éƒ½åˆ†åŒ…å¯¦ç¾äº†Abstraction é¡ï¼Œç„¶å¾Œåœ¨é€éå¯¦ç¾å„è‡ªçš„å·¥å» é¡ï¼Œç”ŸæˆSummaryä»¥åŠSpringçš„Product //ğŸŒ°UI //Button TextField ComboBox //Abstract Class UI class Button{ public: virtual void display() = 0; } class TextField{ public: virtual void display() = 0; } class ComboBox{ public: virtual void display() = 0; } //Abstract Class Factory //ç”¨æ–¼æŠŠä¸åŒé¡å‹çš„UI/ä¸»é¡ŒGroup åœ¨ä¸€èµ· class UIFactory { public: virtual Button* createButton() = 0; virtual TextField* createTextField() = 0; virtual ComboBox* createComboBox() = 0; } //Spring class SpringButton : public Button{ public: void Draw(){ //Draw Spring style Button } } class SpringTextField : public TextField{ public: void Draw(){ //Draw Spring stype TextField } } class SpringComboBox : public ComboBox{ public: void Draw(){ //Draw Spring stype ComboBox } } //Summer class SummerButton : public Button{ public: void Draw(){ //Draw Summer style Button } } class SummerTextField : public TextField{ public: void Draw(){ //Draw Summer style TextField } } class SummerComboBox : public ComboBox{ public: void Draw(){ //Draw Summer style ComboBox } } //Factory class SpringFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SpringButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SpringTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SpringComboBox(); return ComboBox; }; } //SummerFactory class SummerFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SummerButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SummerTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SummerComboBox(); return ComboBox; }; } int main(){ //å°±æ˜¯é€éå·¥å» ç”Ÿæˆæ¥å£ç”Ÿæˆä¸åŒçš„å·¥å»  //å†é€éä¸åŒçš„å·¥å» èª¿ç”¨å…¶ç”Ÿç”¢çš„product //Summer å·¥å»  UIFactory* factory = new SummerFactory(); Button* button = factory->createButton(); TextField* textField = factory->createTextField(); ComboBox* comboBox = factory->createComboBox(); button->draw(); //ç•«å‡ºSummer Styleçš„Button textField->draw(); //ç•«å‡ºSummer Styleçš„textField comboBox->draw(); //ç•«å‡ºSummer Styleçš„comboBox return; } å„ªé» è§£æ±ºå·¥å» æ¨¡å¼ä¸­æ¯å€‹ç”¢å“éƒ½ä½¿ç”¨ä¸€å€‹å·¥å» çš„ç”Ÿç”¢çš„å•é¡Œ æ–°å¢ç”¢å“å¾ˆæ–¹ä¾¿ï¼Œæ“´å±•ç”¢å“ä»¥åŠå·¥å» å³å¯(å¢åŠ çµ±ä¸€ç”¢å“æ—) æ“æœ‰å·¥å» æ¨¡å¼çš„å„ªé» ç¼ºé» å¦‚æœè¦æ–°å¢ç”¢å“ç­‰ç´šçµæ§‹å¿…é ˆä¿®éå·¥å» æŠ½è±¡é¡ï¼Œé•åOpen-Close åŸå‰‡(å¢åŠ ç”¢å“ç­‰ç´šçµæ§‹) å”¯ä¸€ç¼ºé»å°±æ˜¯é–‹é–‰åŸå‰‡çš„å‚¾æ–œæ€§ ä½•è¬‚é–‹é–‰åŸå‰‡çš„å‚¾æ–œæ€§å‘¢? å°±æ˜¯åœ¨æ–°å¢ç”¢å“æ—(ä¸åŒé¡å‹ï¼Œç›¸åŒç”¢å“)çš„æ™‚å€™å¯ä»¥ç¬¦åˆé–‹é–‰åŸå‰‡,ä½†æ˜¯åœ¨æ–°å¢ç”¢å“ç­‰ç´šçµæ§‹(åŒä¸€é¡å‹ï¼Œæ–°å¢ç”¢å“/ä¸åŒçš„ç”¢å“é¡å‹/ç­‰ç´š)æ™‚å€™,å¿…é ˆä¿®æ”¹æŠ½è±¡é¡ã€‚é€™å€‹å•é¡Œç„¡æ³•è§£æ±ºï¼Œåªèƒ½é€éè¨­è¨ˆé¿å…ã€‚ ä¾‹å­ æ–°å¢Açš„ç”¢å“æ—ï¼Œåªéœ€å¯¦ç¾å·¥ç¨‹é¡ä»¥åŠå¯¦ç¾ç”¢å“é¡å‹ï¼Œå³å¯æ–°å¢ä¸€å€‹æ–°çš„å·¥å» ç”¨æ–¼ç”Ÿæˆæ–°ç”¢å“(ç¬¦åˆOpen-Close) æ–°å¢Açš„é¡å‹(å¦‚ä¸€å€‹æ–°çš„UIåŸä»¶:IMG),é€™æ¨£å°±å¿…é ˆè¦ä¿®æ”¹abstract classä»¥åŠconcrete classçš„å…§éƒ¨(é•åOpen-Close) æŠ½è±¡å·¥å» æ¨¡å¼è·Ÿå·¥å» æ¨¡å¼çš„å€åˆ¥ æ¨¡å¼ å€åˆ¥ å·¥å» æ¨¡å¼(Factory Pattern) æ¯ä¸€çµ„ç›¸é—œçš„Productéƒ½ç”±åŒä¸€å€‹å…·é«”å·¥å» ç”Ÿç”¢ æŠ½è±¡å·¥å» æ¨¡å¼(Factory Pattern) æ¯å€‹ç”¢å“æ—(product)éƒ½ç”±åŒä¸€å€‹å…·é«”å·¥å» ç”Ÿç”¢ ä¾‹å¦‚:
é›»å™¨(åŒç‰Œå­/åŒä¸€ç”¢å“æ—)/é›»å™¨(åŒé›»å™¨(å¦‚éƒ½æ˜¯å†°ç®±)/åŒä¸€ç”¢å“ç­‰ç´šçµæ§‹)
ç”¢å“ç­‰ç´šçµæ§‹: ç”¢å“çš„ç¹¼æ‰¿çµæ§‹,ä¾‹å¦‚:åŒä¸€ç¨®é¡çš„ç”¢å“(å¦‚:åŒä¸€é›»å™¨ä½†ä¸åŒç‰Œå­)ç”¢å“æ—:åŒä¸€å·¥å» ç”Ÿç”¢çš„ï¼Œä½æ–¼ä¸ç”¨ç”¢å“ç­‰ç´šçµæ§‹çš„ä¸€çµ„ç”¢å“,ä¾‹å¦‚:åŒä¸€æ—ç¾¤çš„ç”¢å“(å¦‚:åŒä¸€ç‰Œå­çš„ä¸åŒé›»å™¨) æŠ½è±¡å·¥å» æ¨¡å¼(abstract factory pattern)ä½¿ç”¨å ´åˆ ç•¶ä¸€å€‹å·¥å» çš„å¯ä»¥å‰µç«‹å‡ºå±¬æ–¼ä¸åŒç”¢å“çš„ç­‰ç´šçµæ§‹çš„ä¸€å€‹ç”¢å“æ—ä¸­çš„æ‰€æœ‰å°è±¡æ™‚,æ­¤æ™‚ä½¿ç”¨æŠ½è±¡å·¥å» æ¨¡å¼æ›´æœ‰æ•ˆç‡å’Œç°¡å–®
ç³»çµ±ä¸æ‡‰è©²ä¾è³´å…·é«”çš„ç´°ç¯€(å¦‚ä½•å‰µå»º,è¡¨é”ç´°ç¯€ç­‰&hellip;)ï¼Œä¾è³´æ–¼æŠ½è±¡(æ‰€æœ‰å·¥å» æ¨¡å¼éƒ½ä¸€æ¨£) ç³»çµ±ä¸­å¤šæ–¼ä¸€å€‹ç”¢å“æ—æ™‚ï¼Œè€Œæ¯æ¬¡åªæœƒä½¿ç”¨åˆ°æŸä¸€å€‹ç”¢å“æ—ã€‚å¯é€šéé…ç½®æ–‡ä»¶å‹•æ…‹ä¿®æ”¹ç”¢å“æ— ç´„æŸ:å±¬æ–¼åŒä¸€ç”¢å“æ—çš„ç”¢å“å°‡åœ¨ä¸€èµ·ä½¿ç”¨(åŒä¸€é¡)ï¼Œè€Œé€™äº›ç”¢å“å¯ä»¥æ²’æœ‰ä»»ä½•é—œä¿‚ï¼Œä½†æœ‰ç›¸åŒç´„æŸ(åŒä¸€å·¥å» ) ç”¢å“ç­‰ç´šçµæ§‹ç©©å®šï¼Œåœ¨è¨­è¨ˆå®Œæˆå¾Œä¸æœƒåœ¨ç³»çµ±æ›´æ”¹/åˆªé™¤ç”¢å“ç­‰ç´šçµæ§‹(é–‹é–‰åŸå‰‡çš„å‚¾æ–œæ€§) åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Note]Simple RateLimiter Example Based on IP</title><url>https://ryantokmanmokmtm.github.io/post/simple-rateLimiter-example-based-on-IP/</url><categories><category>golang</category><category>backend</category><category>note</category><category>system design</category></categories><tags><tag>gin</tag><tag>rate limiter</tag></tags><content type="html"> åŸºæ–¼Ginå¯¦ä½œRate Limiter å‡è¨­æˆ‘å€‘æœ‰2å€‹APIs,è€Œæ¯å€‹APIéƒ½éœ€è¦æ¶ˆè€—1å€‹Tokens
uri method desc /api/posts/{id} GET return a simple demo message /ping GET return pong æˆ‘å€‘å…ˆè¨­ç½®ä¸€ä¸‹rate limiteræ¡¶å­çš„å®¹é‡åªèƒ½æ”¾ä¸‹ä¸€å€‹tokens,è€Œtokenså‰‡æœƒæ¯ç§’ç”Ÿç”¢5å€‹ã€‚å­˜å–APIæ™‚,è‹¥æ²’æœ‰Tokenå¯ä»¥ç”¨ï¼Œå°±éœ€è¦ç­‰å¾…tokenä¸‹ä¸€æ¬¡ç”Ÿç”¢ä¸¦æ”¾åˆ°æ¡¶å­è£¡ï¼Œæ‰èƒ½ç¹¼çºŒé€²è¡Œä¸‹å»ã€‚
var ( Rate = rate.Every(time.Millisecond * 200) //1s x 10 token ReqLimiter = rate.NewLimiter(RateLimiterRate, 1) ) Post API Controller exapmle type PostCase struct { } func (p *PostUseCase) GetPost(ctx *gin.Context) { //get params id id := ctx.Param("id") //from the path //use a token if err := limiter.ReqLimiter.Wait(ctx); err != nil { ctx.JSON(http.StatusRequestTimeout, gin.H{}) return } //wait for a token is available or return ctx.JSON(http.StatusOK, gin.H{ "msg": "succeed:" + id, }) } Ping API Controller exapmle type HealthCheck struct { } func (hc *HealthCheck) Pong(ctx *gin.Context) { limiter.ReqLimiter.Wait(ctx) ctx.JSON(http.StatusOK, gin.H{ "msg": "Pong", }) } åŸºæ–¼ClientIP çš„Rate limiter ç”±æ–¼ä¸Šé¢çš„çš„ä¾‹å­éƒ½æ˜¯æ‰€æœ‰äººå…¬ç”¨ä¸€å€‹Rate Limiterï¼Œå› æ­¤ï¼Œæˆ‘å€‘é€™è£¡ç°¡å–®å¯¦ä½œä¸€å€‹åŸºæ–¼IPçš„Rate Limiter,ç›¸åŒIPä¸‹æœƒå…¬ç”¨ä¸€å€‹Rate Limiterã€‚
å¯¦ä½œæ€è·¯å¦‚ä¸‹:
å®šç¾©Mapç”¨æ–¼ä¿å­˜ä¸åŒIPä¸‹çš„Rate Limiter å®šç¾©Rate Limiterçš„çµæ§‹ å®šç¾©ä¸€å€‹ç§»é™¤Rate Limiterçš„function ç”¨æ–¼ç§»é™¤ä¸åœ¨ç·šçš„ç”¨æˆ¶(åªæœƒè·‘ä¸€æ¬¡) ä¿å­˜Limiterçš„çµæ§‹ åŒ…å«äº†2å€‹æˆå“¡(Member):
Limters: ä¸»è¦æ˜¯ç”¨æ–¼ä¿å­˜ä¸åŒIPä¸‹çš„Limiter(storage) Lock : å› ç‚ºæœ‰å¯èƒ½æœƒæœ‰å¾ˆå¤šäººåŒæ™‚å­˜å–é€™å€‹Map,ç‚ºäº†é˜²æ­¢Race condition,å› æ­¤éœ€è¦ä½¿ç”¨Mutexé€²è¡Œä¿è­· type Limiters struct { Limiters map[string]*Limiter Lock sync.Mutex } å®šç¾©Rate Limiterçš„çµæ§‹ åŒ…å«äº†3å€‹æˆå“¡(Member):
Limter : ä¸€å€‹rate limiterçš„å¯¦ä¾‹ LastAccess : ä¸Šæ¬¡å­˜å–é€™å€‹limiterçš„æ™‚é–“ type Limiter struct { limiter *rate.Limiter lastAccess time.Time } å®šç¾©ç²å–Rate Limiterçš„Function é€™å€‹functionä¸»è¦åšçš„äº‹æƒ…æ˜¯ç²å–Client IPçš„Rate limiter(å¦‚æœå­˜åœ¨)ã€‚å¦‚æœä¸å­˜åœ¨,æœƒæ–°å»ºä¸€å€‹æ–°çš„Rate Limiterï¼Œä¸¦ä¿å­˜åˆ°Map(storage)ä¸­ã€‚
func (ls *Limiters) GetLimiter(r rate.Limit, b int, key string) *Limiter { ls.Lock.Lock() defer ls.Lock.Unlock() if limiter, ok := ls.Limiters[key]; ok { return limiter } newLimiter := &amp;Limiter{ limiter: rate.NewLimiter(r, b), lastAccess: time.Now(), //key: key, } ls.Limiters[key] = newLimiter return newLimiter } å®šç¾©ä¸€å€‹å®šæœŸæª¢æŸ¥Rate Limiterçš„function é€™å€‹functionçš„ä¸»è¦ä½œç”¨çš„æ˜¯åœ¨è¨­å®šçš„æ™‚å€™åˆ°é”æ™‚ï¼Œæœƒæª¢æŸ¥æ˜¯å¦æœ‰ç”¨æˆ¶çš„æ²’æœ‰å­˜å–/è¨ªå•çš„æ™‚é–“å·²è¶…éè¨­å®šçš„æ™‚é–“ã€‚å¦‚æœå·²è¶…éä¾¿æœƒå¾Limitersçš„Mapä¸­ç§»é™¤ï¼Œä»¥å…è³‡æºçš„æµªè²»
func (ls *Limiters) ClearNotUseLimiter(sec time.Duration) { for { time.Sleep(sec) //for now just set 1-minutes for testing //for all limiter for key, l := range ls.Limiters { if time.Now().Sub(l.lastAccess) > sec { ls.Lock.Lock() delete(ls.Limiters, key) log.Printf("limiter for ip:%v is removed", key) ls.Lock.Unlock() } } } } å¯¦ä½œä¾‹å­ å› ç‚ºæ¯å€‹Requestè¢«è™•ç†å‰ï¼Œå¿…é ˆå…ˆç¢ºä¿æ­¤ç”¨æˆ¶(Client IP)æ²’æœ‰è¶…éé™åˆ¶çš„Requestçš„æ•¸ç›®ã€‚æ‰€ä»¥,æ¯å€‹é€²ä¾†çš„Requestéƒ½æœƒå…ˆç¶“éMiddlewareåšé è™•ç†ï¼Œç²å¾—tokenå¾Œï¼Œæ‰èƒ½é€²åˆ°è™•ç†çš„ç¨‹åºã€‚
Limiter Middleware é€™å€‹Middlewareä¸­æœƒé€éRequest Header(context)è£¡é™„å¸¶çš„Client IP ç²å¾—ä¸€å€‹Limiter,ä¸¦é€éæ­¤Limiteræª¢æŸ¥æ˜¯å¦å¯ä»¥ç²å–Tokenï¼Œå¦‚æœå­˜å–ç‚ºFalseæœƒç›´æ¥response ä¸€å€‹éŒ¯èª¤è¨Šæ¯TooManyRequest
func RateLimiter() gin.HandlerFunc { return func(ctx *gin.Context) { clientIP := ctx.ClientIP() res := app.NewResponse(ctx) if clientIP == "" { res.ErrorResponse(errCode.ClientError.WithDetail("Client agent info not found or error")) ctx.Abort() } //log.Println(clientIP) //limiter : 10 request for each user and a token will generate after 1s l := newLimiters( //1s to generate a token rate.Every(global.AppSetting.LimiterTokenTime), global.AppSetting.LimiterBucketSize, //there are total 10 buckets clientIP) if !l.Allow() { res.ErrorResponse(errCode.TooManyRequest) ctx.Abort() } ctx.Next() } } ç²å–Rate Limiterçš„functionå¦‚ä¸‹åœ–æ‰€ç¤ºã€‚ç´°å¿ƒçš„æœ‹å‹å¯ä»¥ç™¼ç¾é€™å€‹åŒ…å«äº†1å€‹onceTask.Doçš„æ±è¥¿ï¼Œå…¶å¯¦ä»–å°±æ˜¯ä¸€å€‹goèªè¨€å…§ç½®å…è¨±functionåªè·‘ä¸€æ¬¡çš„æƒ…æ³ã€‚é€éonceTask.Doå°±å¯ä»¥å¯¦ç¾ä¸€å€‹Functionåªè·‘ä¸€æ¬¡ï¼Œç„¡è«–å‘¼å«äº†å¹¾æ¬¡åŒä¸€å€‹function,é€™å€‹functionä¹Ÿæœƒåªè·‘ä¸€æ¬¡ï¼Œç›´åˆ°ç¨‹åºçµæŸã€‚
é€™å€‹onceTask.Doæ‰€åšçš„äº‹åªæœ‰1ä»¶ï¼Œä¹Ÿå°±æ˜¯æª¢æ¸¬æ˜¯å¦æœ‰ç”¨æˆ¶ä¸æ´»èºï¼Œä¸æ´»èºçš„ç”¨æˆ¶æœƒè¢«ç§»é™¤ã€‚å®ƒå¦å¤–ä¸€æ¢goroutineä¸­é€²è¡Œï¼Œä¸¦ä¸æœƒå µå¡ä¸»goroutin
func newLimiters(r rate.Limit, b int, key string) *limiter.Limiter { onceTask.Do(func() { log.Println("run once") go global.Limiters.ClearNotUseLimiter(global.AppSetting.LimterClearTime) }) return global.Limiters.GetLimiter(r, b, key) } ä»¥ä¸Šä¾¿æ˜¯åŸºæ–¼IPå¯¦ä½œRate Limiterçš„ç°¡å–®æ–¹æ³•
åƒè€ƒè³‡æ–™:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><url>https://ryantokmanmokmtm.github.io/post/token-bucket-intro/</url><categories><category>golang</category><category>backend</category><category>note</category><category>algorithm</category><category>system design</category></categories><tags><tag>golang package</tag><tag>rate limiter</tag></tags><content type="html"> Token Bucket(ä»¤ç‰Œæ¡¶ç®—æ³•) ä»€éº¼æ˜¯Token Bucket å‘¢? ç°¡å–®ä¾†èªªå°±æ˜¯é‹ç”¨Token Bucketçš„ç³»çµ±æœƒä»¥ä¸€å€‹è¨­å®šçš„é€Ÿç‡å¾€æ¡¶å­(Bucket)è£¡é¢ä¸Ÿä»¤ç‰Œ(Token)ã€‚å¦‚æœè«‹æ±‚(Request)éœ€è¦è¢«è™•ç†æ™‚ï¼Œå°±å¿…éœ€å¾—Bucketè£¡çš„Tokenã€‚ç•¶æ¡¶å­è£¡é¢çš„æ²’æœ‰Tokenå¯ä»¥åˆ†é…/ç²å–æ™‚ï¼Œä¹Ÿå°±æ˜¯èªªBucketç¾åœ¨æ˜¯ç©ºçš„(Tokenå·²ç¶“è¢«å…¶ä»–ä»¤ç‰Œæ‹¿å®Œäº†)ï¼Œç³»çµ±å‰‡æœƒæ‹’çµ•é€™å€‹è«‹æ±‚çš„æœå‹™ã€‚
æ ¹æ“šç®—æ³•(Algorithm)çš„å®šç¾©:
A token is added to the bucket every 1/r seconds. ä¸€å€‹Tokenæœƒä»¥æ¯1/rç§’åŠ å…¥åˆ°Bucketè£¡é¢ã€‚ The bucket can hold at the most b tokens. If a token arrives when the bucket is full, it is discarded. Bucketå¯ä»¥ä¿å­˜æœ€å¤šbå€‹tokensã€‚å¦‚æœåœ¨bucketä»¥åŠæ»¿äº†çš„æƒ…æ³ä¸‹ï¼Œæœ‰ä¸€å€‹tokenè¢«åŠ å…¥åˆ°bucketï¼Œé€™å€‹tokenæœƒè¢«ä¸Ÿæ£„ ä¾‹å­: å‡è¨­ä¸€å€‹n bytesçš„packet(å°åŒ…)é€é” å‡è¨­ç›®å‰æœ€å°‘æœ‰nå€‹tokenåœ¨æ¡¶å­è£¡é¢ï¼Œé€™nå€‹tokenå°±æœƒè¢«æ‹¿å‡ºä¾†ï¼Œç„¶å¾Œpacketå°±æœƒè¢«é€åˆ°ç¶²çµ¡ä¸Š(å‰›å¥½n bytes å°åŒ…æœ‰nå€‹tokens) å‡è¨­ç›®å‰æ¡¶å­è£¡é¢å¯å­˜å–çš„tokenså°‘æ–¼nå€‹ï¼Œå°±ä¸æœƒæœ‰tokensè¢«æ‹¿å‡ºä¾†(å› ç‚ºéœ€è¦nå€‹tokens æ‰èƒ½å‚³é€n bytesçš„å°åŒ…)ï¼Œé€™å€‹å°åŒ…æœƒè¢«è€ƒæ…®ç‚ºä¸ç¬¦åˆçš„å°åŒ…/ä¸åˆè¦çš„å°åŒ… Go å¯¦ç¾/ä½¿ç”¨Token Bucket Go çš„time/rate package æä¾›äº†Limiterçš„å¯¦ä½œï¼Œè€Œé€™å€‹Limiterä¾¿æ˜¯å¯¦ä½œäº†Token Bucketçš„æ–¹å¼ä¾†é”åˆ°é™æµçš„ç›®çš„ã€‚
ä»Šå¤©æˆ‘å€‘å°±ä¾†å­¸ç¿’ä¸€ä¸‹é€™éº¼ä½¿ç”¨go æä¾›Limiterä¾†å¯¦ä½œRate Limiter
è¦å¦‚ä½•æ–°å¢ä¸€å€‹Limiterå‘¢? func NewLimiter(r Limit, b int) *Limiter
ä»–æœ‰2å€‹åƒæ•¸:
r: rateçš„typeæ˜¯Limit(ä¸€å€‹float64çš„å€¼)ï¼Œè¡¨ç¤ºè‘—æ¯ç§’æœƒç”¢ç”Ÿå¤šå°‘å€‹Token,ä¹Ÿå°±æ˜¯æ¯1/rç§’ç”Ÿç”¢1å€‹tokenåˆ°bucketè£¡ b: Token Bucket çš„æ¡¶å­çš„Capacity(å®¹é‡) //r è¨­ç½®100è¡¨ç¤ºæ¯ç§’æœƒç”¢ç”Ÿ100å€‹tokensåˆ°æ¡¶å­è£¡é¢ 1/100 s(1å€‹) //b è¨­ç½®ç‚º1è¡¨ç¤ºæ¡¶å­æœ€å¤šæœ‰1å€‹token limiter := rate.NewLimiter(100,1) Limiterçš„ä½¿ç”¨æ–¹å¼ Limiteræä¾›äº†å¤šå€‹Function: Allow,Reserve,Wait,AllowN,ReserveN,WaitN
æœ€ä¸»è¦ä½¿ç”¨ç‚ºä»¥ä¸‹çš„3å€‹ç¨®Function(éƒ½æœƒæ¶ˆè€—ä¸€å€‹Tokens):
Allow func (lim *Limiter) Allow() bool æ˜¯ AllowN(time.Now(), 1)çš„ç¸®å¯« å®ƒæœƒæ¶ˆè€—æ‰ä¸€å€‹Tokens å¦‚æœæœ‰tokençš„è©±æœƒreturn true å¦è€…æœƒtokenä¸è¶³ return false Reserve func (lim *Limiter) Reserve() *Reservation æ˜¯ ReserveN(time.Now(), 1)çš„ç¸®å¯« æ¯æ¬¡æœƒæ¶ˆè€—æ‰ä¸€å€‹token ä»–ä¸»è¦çš„ä½œç”¨æ˜¯ä¿å­˜eventçš„è³‡è¨Šé ç´„ä¸‹ä¸€æ¬¡çš„æœå‹™ Wait(ç”¨æœ€å¤šçš„function) func (lim *Limiter) Wait(ctx context.Context) (err error) æ˜¯ WaitN(ctx, 1)çš„ç¸®å¯« æ¯æ¬¡æœƒæ¶ˆè€—æ‰ä¸€å€‹token ä¸»è¦çš„ä½œç”¨å°±æ˜¯ç­‰å¾…ç›´åˆ°è¢«å–æ¶ˆæˆ–è€…æœ‰è¶³å¤ çš„Tokens Wait æœƒå µå¡(block)ç›´åˆ°æœ‰è¶³å¤ çš„tokensæ‰æœƒå¾€ä¸‹åŸ·è¡Œ Allow func (lim *Limiter) Allow() bool func (lim *Limiter) AllowN(now time.Time, n int) bool Allow() ç­‰åƒ¹æ–¼(equivalent to) AllowN(time.Now(),1)
AllowNä¸»è¦çš„ä½œç”¨
AllowN è¡¨ç¤ºçš„æ˜¯åœ¨ç›®å‰çš„æ™‚é–“é»ï¼Œæ˜¯å¦èƒ½æ¶ˆè€—nå€‹token,å¦‚bucketå­˜åœ¨nå€‹tokenå‰‡ return true å¦å‰‡ return false
æ˜¯æƒ³è¦Dropæˆ–è€…Skipè¶…érate limitçš„eventsæ™‚ä½¿ç”¨ å¦å‰‡ä½¿ç”¨ Reserve æˆ–è€…Waitå–ä»£ Use this method if you intend to drop / skip events that exceed the rate limit. Otherwise use Reserve or Wait.
//AllowNçš„ä¾‹å­: func AllowDemo() { //each token generated every 100ms with 5 bucket limiter := rate.NewLimiter(rate.Every(time.Microsecond * 100), 5) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ //each time we need 2 tokens if isAllowed := limiter.AllowN(time.Now(), 2); isAllowed { //bucket have enough tokens fmt.Println("Welcome!!!") fmt.Printf("user:%v is allowed in %v\n", counter, time.Now().Format(time.RFC3339)) } else { fmt.Printf("user:%v is not allowed.Please wait for 100ms and try again later\n", counter) //wait for 100ms time.Sleep(100 * time.Microsecond) } } } Reserve func (lim *Limiter) Reserve() *Reservation func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation Reserve() ç­‰åƒ¹æ–¼(equivalent to) ReserveN(time.Now(),1)
ReserveNçš„ä¸»è¦ä½œç”¨
ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
å›å‚³ä¸€å€‹Reservation è¡¨é¢åœ¨eventåŸ·è¡Œå‰éœ€è¦ç­‰å¾…å¤šä¹…ï¼Œé€™å€‹Reservationè¢«limiterç´å…¥è€ƒé‡å…§
å¦‚æœReservation çš„æ‰€éœ€çš„token nè¶…ébucket çš„sizeæ™‚,Reservation çš„OK()æœƒreturn false
//Reserveä¾‹å­: func ReserveDemo() { //each token generated every 200ms and each second will put at most 5 tokens to bucket limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 3) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ tokensNeeds := 2 reserve := limiter.ReserveN(time.Now(), tokensNeeds) if !reserve.OK() { //this event won't be completed due to the tokens its needs fmt.Printf("needed tokens %v is greater than the bucket size %v\n", tokensNeeds, limiter.Burst()) return } //wait for the reversing time fmt.Printf("Wait for %v ms...\n", reserve.Delay()) //if dely is 0 that means no need to wait~ time.Sleep(reserve.Delay()) //at least to wait for 200ms fmt.Printf("waiting is done and now is allowed to deal with some tasks...\n") fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC3339)) } } Wait func (lim *Limiter) Wait(ctx context.Context) (err error) func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) Wait(ctx) ç­‰åƒ¹æ–¼(equivalent to) wait(time.Now(),1)
waitNçš„ä¸»è¦ä½œç”¨
WaitN æ¯æ¬¡éœ€è¦æ¶ˆè€—Nå€‹Tokensï¼Œå¦‚æœBucketæ²’æœ‰è¶³å¤ çš„Bucketæœƒå µå¡ï¼Œç›´åˆ°æœ‰è¶³å¤ çš„Tokens(n)æ‰æœƒç¹¼çºŒå¾€ä¸‹åªéœ€ã€‚é™¤éä»¥ä¸‹æ¢ä»¶æˆç«‹æ‰æœƒå›å‚³éŒ¯èª¤:
æ‰€éœ€æ¶ˆè€—tokens nå¤§æ–¼bucketçš„size Context è¢«å–æ¶ˆ Context å·²ç¶“è¶…éè¨­å®šçš„Deal line(ç­‰å¾…æ™‚é–“è¶…éäº†Deal line) //ä¾‹å­ func WaitDemo() { //at most 5 tokens will generate in a sec 200/1000=5 ctx := context.Background() limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 2) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ if err := limiter.WaitN(ctx, 2); err != nil { fmt.Println("error", err) return } //wait for 2 tokens. At most wait for 400ms fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC1123)) } } è¨­å®šBucket å’Œ Rate å¯é€éfunc (lim *Limiter) SetBurst(newBurst int)è¨­å®š Bucket size
å¯é€éfunc (lim *Limiter) SetLimit(newLimit Limit)è¨­å®š Limit/Rate
åƒè€ƒè³‡æ–™:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Creational-Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> ä»€éº¼æ˜¯Factory(å·¥å» )å‘¢? å®šç¾©:å»ºç«‹ä¸€å€‹æ¥å£,è®“å­é¡è‡ªå·±æ±ºå®šå¯¦ç¾å“ªä¸€å€‹Factory,å…¶é‡é»æ˜¯ç¹¼æ‰¿äº†Simple Factory Patternsçš„å„ªé»,åŒæ™‚è§£æ±ºäº†å®ƒçš„å•é¡Œ
ç°¡å–®ä¾‹å­ æ³¨: ä»¥ä¸‹ç¨‹å¼å–®ç´”ç”¨æ–¼è§£é‡‹ï¼Œä¸¦ä¸èƒ½å¯¦éš›åŸ·è¡Œ
å¯é€éå­é¡ç¹¼æ‰¿Factoryçš„æŠ½è±¡é¡è‡ªä¸»æ±ºå®šç”Ÿç”¢ä»€éº¼æ¨£çš„Productã€‚ ç”Ÿç”¢çš„Productåœ¨é€éé‡Œæ°æ›¿æ›åŸå‰‡(Lisko Subsititution princeple)æ›¿æ›æˆç¹¼æ‰¿èˆ‡Loggerçš„å­é¡ï¼Œå³å¯æ›æˆçš„éœ€è¦çš„Loggerã€‚ class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //ä¸å¯ä»¥æ˜¯Staticéœæ…‹ï¼Œå› ç‚ºå­é¡æ˜¯å‹•æ…‹å¯¦ç¾çˆ¶é¡çš„å‡½æ•¸(static æ²’æœ‰thisæŒ‡æ¨™) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc... Logger* logger = new DatabaseLogger(); //init this logger etc... return logger } } //Client to use int main(){ Factory *factory = new FileLoggerFactory(); Logger *logger = factory->createLogger(); //return the Product that it is initialized Logger->wirteLog(); return; //å¦‚æœæƒ³è®“ç³»çµ±æœ‰æ›´å¤šéˆæ´»æ€§å’Œèª²æ“´å±•æ€§ï¼Œå¯ä»¥é€éxmlä¾†é€²è¡Œé…ç½®ï¼Œä¸éœ€é€éä¿®éclientçš„ä»£ç¢¼ //åªéœ€æ›´æ–°xmlä¸­çš„è¨­ç½®ï¼Œåœ¨ä»£ç¢¼ä¸­æ–°å¢æ–°çš„Product ä»¥åŠæ–°å¢çš„Factory ä¸¦é‡æ–°ç·¨è­¯ä¾¿å¯ //é™¤äº†é»˜èªçš„è¨­ç½®æ–¹æ³•å¤–ï¼Œé‚„æƒ³é€éå‚³å…¥Stringçš„æ–¹æ³•ä¾†è‡ªå®šç¾©è¨­è¨ˆï¼Œä¾‹å¦‚é€£æ¥è¦DBï¼Œæ–‡ä»¶çš„è·¯å¾‘ç­‰ç­‰ //å¯ä»¥é€éOverride Abstruct class çš„funcä¾†é€²è¡Œè¨­ç½® /* class Factory{ public: virtual Logger* createLogger() = 0; virtual Logger* createLogger(string config) = 0; virtual Logger* createLogger(Object obj) = 0;//é€šéObjè£¡é¢çš„æˆå“¡é€²è¡Œè¨­ç½®ç­‰ } */ } å„ªé» Clientç„¡éœ€çŸ¥é“Objectçš„è¨­ç½®çš„ç´°ç¯€ï¼Œä¹Ÿç„¡éœ€çŸ¥é“å¯¦è³ªObjectçš„åç¨±ï¼Œåªéœ€é€šéå·¥å» å³å¯ å·¥å» (Factory)ä»¥åŠç”¢å“(Product)éƒ½æ˜¯é€éPolymorphism(å¤šæ…‹)ä¾†å¯¦ç¾ï¼Œä¹Ÿæ˜¯å·¥å» æ¨¡å¼çš„é—œéµï¼Œå·¥å» å¯ä»¥è‡ªä¸»çš„æ±ºå®šè¦ç”Ÿç”¢ä»€éº¼ç”¢å“ï¼Œåœ¨å…§éƒ¨é€²è¡Œè¨­ç½®ç”¢å“(å°è£åœ¨å…§éƒ¨) åŠ å…¥æ–°çš„Productæ™‚ç„¡éœ€ä¿®æ”¹Abstract class ä»¥åŠ å…·é«”çš„å·¥å» å’Œç”¢å“çš„é¡ï¼Œåªè¦æ“´å±•æ–°å¢å³å¯ï¼Œç¬¦åˆOpen-Close principle é€éç¹¼æ‰¿æŠ½è±¡é¡ä½¿ç³»çµ±æ›´å®¹æ˜“æ“´å±• ç¼ºé» æ–°å¢ç”¢å“æ™‚ï¼Œè¦åŠ å…¥æ–°çš„ç”¢å“é¡ä»¥åŠå·¥å» é¡ï¼Œå¢åŠ äº†ç³»çµ±çš„è¤‡é›œåº¦ï¼Œè€Œä¸”éœ€è¦å¾æ–°ç·¨è­¯ï¼Œå¢åŠ äº†é–‹éŠ· ç‚ºäº†æ“´å±•æ€§,åŠ å…¥äº†æŠ½è±¡é¡ï¼ŒClientéƒ½ä½¿ç”¨Abstract class é€²è¡Œç·¨ç¨‹ï¼Œå¢åŠ äº†ç³»çµ±çš„æŠ½è±¡æ€§å’Œç†è§£é›£åº¦ åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Note]Creational-Simple Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-simple-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> ä»€éº¼æ˜¯Simple Factory(ç°¡å–®å·¥å» )å‘¢? ç°¡å–®è€Œè¨€å°±æ˜¯: ç”±ä¸€å€‹å·¥å» ä¾†ç”Ÿç”¢å…¨éƒ¨ç”¢å“ å®šç¾©:å»ºç«‹ä¸€å€‹æ¥å£,è®“å­é¡è‡ªå·±æ±ºå®šå¯¦ç¾å“ªä¸€å€‹Factory,é‡é»åœ¨æ–¼å·¥å» ï¼Œé€éå·¥å» çš„Static method é€²è¡Œç”Ÿæˆçš„Object
ç°¡å–®ä¾‹å­ æ³¨: ä»¥ä¸‹ç¨‹å¼å–®ç´”ç”¨æ–¼è§£é‡‹ï¼Œä¸¦ä¸èƒ½å¯¦éš›åŸ·è¡Œ
é€éFactory é¡çš„Static æ–¹æ³•èª¿ç”¨æ–¹æ³•ï¼Œå‚³å…¥åƒæ•¸ç”Ÿæˆç›¸é—œçš„Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == "A"){ return new ProductA(); } else if(type == "B"){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct("A"); //get ProductA instance Product* B = Factory::getProduct("B"); //get ProductB instance } å„ªé» Clientå¯ä»¥è‡ªè¡Œæ±ºå®šç”Ÿç”¢å“ªå€‹Product Clientå…é™¤ç›´æ¥å»ºç«‹Productçš„è²¬ä»»ï¼Œåªåƒ…åƒ…æ¶ˆè²»ç”¢å“ Clientç„¡éœ€é—œå¿ƒå…·é«”çš„é¡åèˆ‡ç›¸é—œè¨­ç½®åƒæ•¸ ç¼ºé» Factory çš„è·è²¬å¤ªé‡ã€‚æ‰€æœ‰çš„Product éƒ½ç”±ä¸€å€‹Object ç”Ÿç”¢ï¼Œä¸€æ—¦ä¸èƒ½æ­£å¸¸å·¥ä½œï¼Œä¾¿æœƒå½±éŸ¿æ•´å€‹ç³»çµ±çš„é‹ä½œ å¦‚æœ‰ä¸åŒçš„Productæœƒå¢åŠ ç³»çµ±ä¸­çš„classçš„æ•¸ç›®ï¼Œå¢åŠ äº†ç³»çµ±è¤‡é›œåº¦ä»¥åŠç†è§£é›£åº¦ æ“´å±•ååˆ†å›°é›£ï¼Œæ·»åŠ éœ€è¦ä¿®æ”¹Factoryçš„é‚è¼¯ã€‚å¦‚æœç”Ÿå­˜çš„Productè¼ƒå¤šæ™‚ï¼Œå¯èƒ½æœƒä½¿å…¶é‚è¼¯éæ–¼è¤‡é›œï¼Œä¸åˆ©æ–¼ç³»çµ±çš„æ“´å±•èˆ‡ç¶­è­· é•èƒŒåŸå‰‡ é•èƒŒäº†Open-Close Principe å¦‚æœæœ‰æ–°çš„Product éœ€è¦ç”Ÿæˆï¼Œå°±å¿…ä¿®è¦ä¿®æ”¹Factoryé¡ åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Note]Design Pattern Princeple</title><url>https://ryantokmanmokmtm.github.io/post/design-pattern-princeple/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>learning</tag><tag>note</tag></tags><content type="html"> ä»€éº¼æ˜¯Design Pattern(è¨­è¨ˆæ¨¡å¼)å‘¢? è¨­è¨ˆæ¨¡å¼(Design Pattern) æ˜¯å°è»Ÿé«”è¨­è¨ˆä¸­æ™®éå­˜åœ¨ï¼ˆåè¦†å‡ºç¾ï¼‰çš„å„ç¨®å•é¡Œï¼Œæ‰€æå‡ºçš„è§£æ±ºæ–¹æ¡ˆã€‚ç”¨æ–¼æè¿°åœ¨å„ç¨®ä¸åŒçš„æƒ…æ³ä¸‹ï¼Œå¦‚ä½•è§£æ±ºå•é¡Œçš„ä¸€ç¨®æ–¹æ¡ˆ
OOPè¨­è¨ˆæ¨¡å¼é€šå¸¸ä»¥é¡åˆ¥æˆ–è€…ç‰©ä»¶ä¾†æè¿°é—œä¿‚å’Œç›¸äº’çš„ä½œç”¨(ä¸æ¶‰åŠå®Œæˆæ‡‰ç”¨çš„ç‰¹å®šobject)ã€‚ è¨­è¨ˆæ¨¡å¼èƒ½ä½¿ä¸ç©©å®šä¾è³´æ–¼ç›¸å°ç©©å®šã€å…·é«”ä¾è³´æ–¼ç›¸å°æŠ½è±¡ï¼Œé¿å…æœƒå¼•èµ·éº»ç…©çš„ç·Šè€¦åˆã€‚
Design Pattern æœ‰ä»€éº¼åŸå‰‡å‘¢? åŸå‰‡(Princeple) å®šç¾©(Def) å–®ä¸€è·è²¬åŸå‰‡(Single Responsibility Principle) ä¸€å€‹é¡åªè² è²¬ä¸€å€‹åŠŸèƒ½é ˜åŸŸä¸­çš„ç›¸æ‡‰çš„åŸå‰‡ é–‹é–‰åŸå‰‡(Open-Closed Principle) å°æ“´å±•é–‹ç™¼(å¯ä»¥ç¹¼æ‰¿æ“´å±•)ï¼Œå°ä¿®æ”¹é—œé–‰(ä¸èƒ½ä¿®æ”¹BaseClass) é‡Œæ°æ›¿æ›åŸå‰‡(Liskov Substitution Principe) æ‰€æœ‰å¼•ç”¨æ–¼Base Class çš„åœ°æ–¹ éƒ½èƒ½å¤ é€æ˜çš„ä½¿ç”¨å…¶å­é¡çš„å°è±¡(ä»¥å­é¡ä¾†æ›¿æ›çˆ¶é¡) ä¾è³´å€’è½‰åŸå‰‡(Dependencie Inversion Principe ç´°ç¯€æ‡‰ä¾è³´æ–¼æŠ½è±¡(Abstract),æŠ½è±¡(Abstract)ä¸æ‡‰è©²ä¾è³´èˆ‡ç´°ç¯€ã€‚(ä¹Ÿå°±æ˜¯ç´°ç¯€ç”±å­é¡ä¾†å¯¦ç¾ï¼Œçˆ¶é¡è² è²¬å®šç¾©) æ¥å£éš”é›¢åŸå‰‡(Interface Segregation Principle) ä½¿ç”¨å¤šå€‹å°ˆç”¨çš„æ¥å£(Interface),è€Œä¸æ˜¯ä½¿ç”¨å–®ä¸€çš„ç¸½æ¥å£.(èƒ½é¿å…Clientå¯¦ç¾ä¸€äº›æ²’å¿…è¦çš„åŠŸèƒ½) åˆæˆè¤‡ç”¨åŸå‰‡(Composition Reuse Principle) ç›¡é‡ä½¿ç”¨Object Composition(åœ¨è¦ä½¿ç”¨çš„Objectçš„åœ°æ–¹æŠŠç”¨åˆ°çš„Objectæ³¨å…¥),è€Œä¸æ˜¯ç¹¼æ‰¿èƒ½é”åˆ°ç›®çš„.(æ¸›å°‘ä¾è³´) è¿ªç±³ç‰¹æ³•å‰‡(Law of Demeter) ä¸€å€‹è»Ÿä»¶å¯¦é«”æ‡‰ç›¡å¯èƒ½åœ°èˆ‡å…¶ä»–å¯¦é«”ç™¼ç”Ÿäº’ç›¸ä½œç”¨.(å°±æ˜¯ä¸ç”¨è·Ÿä¸æ˜¯æœ‹å‹(æ³¨å…¥)çš„Object ç›´æ¥é€šè¨Š) Design Pattern åˆ†æˆå“ªå¹¾ç¨®å‘¢? ä¸»è¦åˆ†æˆ3å¤§é¡ï¼Œä¸€å…±23å€‹
å‰µå»ºå‹æ¨¡å¼(6å€‹) çµæ§‹å‹æ¨¡å¼(7å€‹) è¡Œç‚ºå‹æ¨¡å¼(11å€‹) å‰µå»ºå‹æ¨¡å¼(6å€‹) ç°¡å–®å·¥å» æ¨¡å¼(Simple Factory Pattern) å·¥å» æ¨¡å¼(Factory Pattern) æŠ½è±¡å·¥å» æ¨¡å¼(Abstract Factory Pattern) å–®ä¾‹æ¨¡å¼(Singleton Pattern) åŸå½¢æ¨¡å¼(Prototype Pattern) å»ºç«‹è€…æ¨¡å¼(Builder Pattern) çµæ§‹å‹æ¨¡å¼(7å€‹) é©é…å™¨æ¨¡å¼(Adapter Pattern) æ©‹æ¥æ¨¡å¼(Bridge Pattern) çµ„åˆæ¨¡å¼(Composite Pattern) è£é£¾æ¨¡å¼(Decorator Pattern) å¤–è§€æ¨¡å¼(Facade Pattern) äº«å…ƒæ¨¡å¼(FlayWeight Pattern) ä»£ç†æ¨¡å¼(Proxy Pattern) è¡Œç‚ºå‹æ¨¡å¼(11å€‹) è·è²¬éˆæ¨¡å¼(Chain of Responsibility Pattern) å‘½ä»¤æ¨¡å¼(Command Pattern) è§£é‡‹å™¨æ¨¡å¼(Interpreter Pattern) è¿­ä»£å™¨æ¨¡å¼(Iterator Pattern) ä¸­ä»‹è€…æ¨¡å¼(Mediator Pattern) å‚™å¿˜éŒ„æ¨¡å¼(Memento Pattern) è§€å¯Ÿè€…æ¨¡å¼(Observer Pattern) ç‹€æ…‹æ¨¡å¼(State Pattern) ç­–ç•¥æ¨¡å¼(Strategy Pattern) æ¿å¡Šæ¨¡å¼(Template Method Pattern) è¨ªå•è€…æ¨¡å¼(Visitor Pattern) åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Note]What Is JWT(Json Web Token)-EN</title><url>https://ryantokmanmokmtm.github.io/post/jwt-note/</url><categories><category>backend</category><category>development</category><category>web develpment</category><category>note</category><category>english</category></categories><tags><tag>web develpment</tag><tag>token</tag></tags><content type="html"> What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:
Header Payload Signature JWT Header Header typically consists of two parts
type : what&rsquo;s the type of the token algorithm : what algorithm does this token use to sign/encrypt. such as SHA256,RAS or HMAC { "typ" : "jwt", "alg" : "HS256" } This information will be encoded by base64Url algorithm in order to generate the JWT Header
JWT payload In payload is typically saving some users information and other useful information.
Be carefulthat payload must not include any secret information due to base64Url algorithm is easy to be decrypted.
JWT Payload standard claims
{ "sub" :"",//subject "aud" :"",//audience "jti" :"",//jwt id "iat" :"",//Issued at "iss" :"",//Issuer - who is the publisher of the jwt "nbf" :"",//Not Before - JWT is not available before the time jwt set. // other user information that developer set //for example: "user_name" : "jackson_tmm", "email" : "admin@admin.com" } This information will be encoded by base64Url algorithm in order to generate the JWT Payload
Signature The Signature is used to authenticate whether information has been modified during transmission and authenticate the sender that sent this JWT.
To Generate JWT Token Following this function
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), your-256-bit-secret) And these three partes will be combined by a . as following format: xxx.yyy.zzz
//exmaple eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ How it work between Client and server sequenceDiagram Client-Server:POST /authentication {username:xxx..} Note over Client,Server: User logs in alt is authenticated Server-Client:HTTP Status:200 {"token":eyxxx.xx.x} Note over Server,Client: Loged in Succeed else Unauthorized Server-Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Loged in Failed end Client-Server: POST /user/profile {"Authorization":"Bear token"} Note over Server,Client: Get User Profile with token alt succeed Server--Client: HTTP Status:200 {"profile":eyxxx.xx.x} Note over Server,Client: Succeed and response a profile else Unauthorized Server--Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Unauthorized(token error) end</content></entry><entry><title>[CGU]Graduation Project</title><url>https://ryantokmanmokmtm.github.io/project/final-project/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> OTT Movies recommender system-IOS Client
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database Demo Video
In Progress User chatting UI User profile Demo(åƒè€ƒå°ç´…æ›¸)</content></entry><entry><title>About me</title><url>https://ryantokmanmokmtm.github.io/about.html</url><categories/><tags/><content type="html"> Here is my personal CV:MY-CV Introduction ä½ å¥½~ æ­¡è¿ä¾†åˆ°æˆ‘çš„ç¶²ç«™!
æˆ‘æ˜¯Jackson.tmm, æ˜¯ä¸€å€‹å¾é¦™æ¸¯ä¾†åˆ°å°ç£è®€å¤§å­¸çš„å››å¹´ç´šå­¸ç”Ÿã€‚ç›®å‰å°±è®€æ–¼é•·åºšå¤§å­¸-è³‡è¨Šå·¥ç¨‹å­¸ç³»(Computer Science And Information Engineering)ã€‚
More About me æˆ‘è¶…å–œæ­¡TFBoyçš„ï¼Œæ˜¯TFBoysçš„å¿ å¯¦ç²‰çµ²,ç‰¹åˆ¥æ˜¯æ˜“çƒŠåƒç’½(Jackson yee)ï¼ï¼ï¼æˆ‘å«Jacksonä¹Ÿæ˜¯é€™å€‹åŸå› ï¼Œæƒ³è·Ÿåƒç’½ä¸€æ¨£å¼·ï¼å“ˆå“ˆå“ˆã€‚å¾ä»–å€‘å‡ºé“é–‹å§‹å°±é–‹å§‹å–œæ­¡ä»–å€‘äº†(æ‡‰è©²å¿«9å¹´äº†)ã€‚
é™¤äº†å¯«ç¨‹å¼ä»¥å¤–ï¼Œæˆ‘ä¹Ÿå–œæ­¡è¨­è¨ˆè·ŸéŸ³æ¨‚ï¼ä½ æ²’çœ‹éŒ¯ï¼Œæˆ‘ä¸€å€‹å¾Œç«¯å–œæ­¡è¨­è¨ˆï¼Œå“ˆå“ˆå“ˆå“ˆ(ä¸è¦å•æˆ‘ç‚ºä»€éº¼ä¸é¸å‰ç«¯ï¼Œå“ˆå“ˆå“ˆ)
Why i choose Computer Science? è¦å¾æˆ‘å°æ™‚å€™ç²å¾—äº†ä¸€å°å–®æ ¸å¿ƒCPU,512MB RAM,é‚„æ²’æœ‰DisplayCardçš„é›»è…¦é–‹å§‹èªªèµ·(é›–ç„¶å¾ˆçˆ›)ã€‚å“ªå€‹æ™‚å€™å› ç‚ºå–œæ­¡ç©éŠæˆ²ï¼Œæ‰€ä»¥,å°æ–¼éŠæˆ²è£½ä½œé€™ä»¶äº‹æ˜¯å“ªæ™‚å€™çš„å¤¢æƒ³ã€‚ç›´åˆ°äº†ä¸­å­¸(å¤§æ¦‚æ˜¯åœ‹ä¸€æˆ–åœ‹äºŒ)ï¼Œå› æŸæŸç¶²çµ¡éŠæˆ²é—œæœï¼Œä½†å»å°æ­¤å¿ƒæœ‰ä¸ç”˜ã€‚æ‰€ä»¥ï¼Œä¾¿èˆ‡ç¶²çµ¡ä¸Šèªè­˜çš„å°å¤¥ä¼´ä¸€èµ·ç ”ç©¶æ”¾å‡ºä¾†çš„æºä»£ç¢¼(é›–ç„¶çœ‹ä¸å¤ªæ‡‚)ï¼Œé€™ä¹Ÿæ˜¯æˆ‘æ¥è§¸ç¨‹å¼çš„é–‹å§‹ã€‚åˆ°äº†é«˜ä¸­æˆ‘ä¾¿ä¸€å¿ƒæƒ³è¦å¾€Computer Scienceæ–¹å‘å‰é€²ï¼Œä¹Ÿå› æ­¤é¸æ“‡äº†Information Computer Technology(ICT)ç§‘ç›®ã€‚é›–ç„¶æˆ‘å…¶ä»–ç§‘ç›®çš„æˆç¸¾æ²’æœ‰å¾ˆå¥½ï¼Œä½†æ˜¯åœ¨ICTçš„é€™é–€ç§‘ä¸­ï¼Œé€£çºŒæ‹¿äº†3å¹´çš„ç¬¬ä¸€åã€‚ä½†æ˜¯å› ç‚ºé«˜è€ƒå¤±åˆ©ï¼Œä½†åˆå¸Œæœ›è‡ªå·±èƒ½å­¸ç¿’åˆ°CSç›¸é—œçš„ç§‘ç›®ï¼Œå› æ­¤ä¾†åˆ°äº†å°ç£å°±è®€CSç§‘ç³»ã€‚
A special and meaningful experience during my university ä¸Šå¤§å­¸ä»¥å¾Œï¼Œä¹Ÿæ˜¯æ­£å¼é–‹å§‹å­¸ç¿’ç¨‹å¼è¨­è¨ˆçš„é–‹å§‹ã€‚å¯èƒ½æ˜¯ä»¥å‰æœ‰è‡ªå­¸éä¸€æ®µæ™‚é–“C++ï¼Œå­¸èµ·ä¾†æ¯”è¼ƒè¼•é¬†ä¸€é»ã€‚å¤§äºŒä¸‹çš„æ™‚å€™ï¼Œå¾ˆä¸è¾›COVIN-19ç–«æƒ…çˆ†ç™¼ï¼Œä¸èƒ½æœƒå°ç£åªèƒ½ç•™åœ¨é¦™æ¸¯ä¸Šç¶²çµ¡èª²ç¨‹ï¼Œå› æ­¤ï¼Œä¾¿é–‹å§‹äº†æˆ‘çš„è‡ªå­¸ä¹‹è·¯ã€‚ç”±æ–¼æœ‰äº†å­¸ç¿’C++çš„ç¶“é©—ä»¥åŠç¨‹å¼èªè¨€çš„åŸºç¤ï¼Œä¾¿é–‹å§‹è‡ªæˆ‘æ¢ç´¢æ¨¡å¼ï¼Œå˜—è©¦æ¥è§¸ä¸åŒçš„é ˜åŸŸã€‚äº†è§£éç¶²é è¨­è¨ˆ,å¾Œç«¯é–‹ç™¼,æ•¸æ“šåº«è¨­è¨ˆ,Apple Appé–‹ç™¼,ML/TensorFlowåŸºç¤,ç”šè‡³æ˜¯å…¶ä»–é ˜åŸŸçš„æ¢ç´¢å¦‚éŠæˆ²é–‹ç™¼ï¼Œç¾è¡“è¨­è¨ˆï¼Œ3Då»ºæ¨¡ç­‰ç­‰&hellip;é€™æ®µè‡ªå­¸æ¢ç´¢çš„æ—…ç¨‹,è²Œä¼¼çœ‹ä¸Šå»æ¯«ç„¡æ„ç¾©(ä¹Ÿå°±æ˜¯å•¥éƒ½å­¸ï¼Œæ²’æœ‰ä¸€å€‹æ˜¯ç²¾çš„)ã€‚ä½†æ˜¯ï¼Œå°æˆ‘ä¾†èªªæœ‰å·¨å¤§çš„æ„ç¾©ï¼Œèƒ½å¤ è®“æˆ‘æ›´èªè­˜è‡ªå·±ï¼ŒçŸ¥é“è‡ªå·±å–œæ­¡çš„æ±è¥¿ï¼Œä¸å–œæ­¡çš„æ±è¥¿ï¼Œç”šè‡³æ˜¯çŸ¥é“å“ªäº›å­¸ç¿’æ–¹æ³•æ˜¯é©åˆè‡ªå·±ã€‚é›–ç„¶å¾ˆæƒ³ä»€éº¼éƒ½æƒ³è¦æœƒï¼Œä½†æ˜¯ä¹Ÿæ±ºå®šäº†åªåšè‡ªå·±æ„Ÿèˆˆè¶£çš„äº‹æƒ…ã€‚ä»¥ä¸‹æ˜¯æˆ‘åœ¨é€™æ®µæ™‚é–“æ‰€åšçš„æ±è¥¿(ä½ å€‘æ‡‰è©²ä¸æœƒå«Œæ£„å§>&lt;)
ç¬¬ä¸€æ¬¡å­¸ç¿’IOSé–‹ç™¼çš„Demo åŸºæ–¼IOSçš„Netfilx UI Clone åŸºæ–¼IOSçš„å¾®åšUI Clone ç¬¬ä¸€æ¬¡å­¸éŠæˆ²é–‹ç™¼çš„ä½œå“ ç¬¬ä¸€æ¬¡å­¸å»ºæ¨¡çš„ä½œå“ é€çµ¦è‡ªå·±20æ­²çš„ç”Ÿæ—¥ç¦®ç‰©çš„ä¸€é¡†æ’çƒæ¨¡å‹ æ¨¡æ“¬æ°´é‚„æ˜¯å¾ˆå¥½ç©çš„(æ¸²æŸ“äº†12å°æ™‚ (â—‘â€¿â—) ) ç‡ˆç± é­š(Lophiiformes)ä½œå“ ç¬¬ä¸€æ¬¡ç¶²çµ¡èª²å­¸ç¿’å»ºæ¨¡çš„ä½œæ¥­ ç¬¬ä¸€æ¬¡ç¶²çµ¡èª²å­¸ç¿’å»ºæ¨¡çš„çµèª²ä½œå“(é‚„æ²’ä¸Šè²¼åœ–>&lt;,æœ‰ç©ºå°±ä¸Š) Interest è·‘æ­¥ï¼Œæ‰“çƒï¼Œèªªå”±ï¼Œå”±æ­Œï¼Œçœ‹é›»å½±ï¼Œçœ‹å‹•æ¼« éŠæˆ²è¨­è¨ˆï¼ŒéŠæˆ²ç¾è¡“ï¼Œ3Då»ºæ¨¡ æè¨­è¨ˆï¼Œå¯«ç¨‹å¼ è·Ÿæœ‹å‹åˆ†äº«ã€äº¤æµ ç‰¹åˆ¥å–œæ­¡å®‡å®™/äººé¡èµ·æºç›¸é—œçš„å¥‡æ€ªçŸ¥è­˜ Current Plan å­¸æ›´å¤šæœ‰é—œå¾Œç«¯é–‹ç™¼ï¼Œç³»çµ±è¨­è¨ˆç›¸é—œçš„æŠ€è¡“ å­¸å¥½è‹±æ–‡(çœ‹é›»å½±ä¸è¦çœ‹å­—å¹•ï¼Œèƒ½æ›´å¤–åœ‹äººäº¤æµçš„ç¨‹åº¦) è€ƒå¥½é›…æ€ åšå¥½è‡ªå·±,ä¸æ¯”è¼ƒ,ä½†ä¸€èµ·å­¸ç¿’ä¸€èµ·é€²æ­¥ Contact Me: Email @Jacksontmm in Telegram</content></entry></search>