<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>71天的日本之旅</title><url>/memories/jp-trip/</url><categories/><tags><tag>jp</tag><tag>japen</tag></tags><content type="html"> 71天 - 日本體驗生活📝 2024年5月1日 ～ 2024年7月10日 行程 東京✓ 新宿 ✓ 原宿 ✓ 澀谷 ✓ 下北澤 ✓ 吉祥寺 ✓ 中野 ✓ 上野 ✓ 熱海 - 海上花火大會✓ 鐮倉 ✓ 江之島 ✓ 台場 ✓ 舞濱/迪士尼 ✓ 橫濱 ✓ 銀座 ✓ 池袋 ✓ 秋葉原 ✓ 春日部 ✓ 淺草 ✓ 豐島園 - 東京哈利波特影城 ✓ 東京車站 ✓ 阿佐谷 ✓ 高圓寺 ✓ 日本橋 ✓ 大阪✓ 難波 ✓ 櫻川 ✓ 心齋橋 ✓ 櫻島 - 日本環球影城 ✓ 大阪城 ✓ 梅田 ✓ 恵美須町 - 通天閣 ✓ 奈良 - 奈良公園 ✓ 京都✓ 京都車站 ✓ 清水寺 ✓ 金閣寺 ✓ 八板神社 ✓ 春日大社 ✓ 平安神宮 ✓ 伏見稻荷大社 ✓ 御法神社 ✓ 京都國立博物館 ✓ 錦市場 ✓ 嵐山 名古屋✓ 名古屋城 ✓ 名古屋站 ✓ 名古屋港水族館 ✓ 感想 日本街道很乾淨 食物有點鹹和沒什麼蔬菜卻還不錯吃 東京JR很方便但線路很多有點麻煩 食物種類不算很多 夏天很熱切很乾燥 女生都會化妝、包包會掛娃娃和鞋子都很高 日本人都很有禮貌 電車裡面很安靜 新幹線有bug，出了新幹線的站但還在JR站，如果去了其他地方原本的車票就出不去，要去工作人員那邊補錢 如果同一站出入必須去工作人員哪裡 垃圾分類還挺麻煩的 國內飛機航班比新幹線還便宜 巴士都是先讓乘客下車，才到其他乘客上車 巴士是後面上車，前門下車且下車在付款 巴士的車費不論哪裡上車/下車都是同一車費 東京都是坐電車、京都卻是巴士比較方便 日本用英文不太能溝通 整體感受 整體來說這趟路程雖然花了1,200,000+日幣，但是我覺得值得花這麼多錢去換來這麼一個體驗！如果下次還有機會，還是會繼續體驗的😁！</content></entry><entry><title>7月份的日本 - 結束</title><url>/memories/jp-july/</url><categories/><tags><tag>jp</tag><tag>japen</tag></tags><content type="html"> 7月份在日本體驗生活的日記 2024年7月1日～2024年7月10日 行程 這是這趟旅程的最後的10天了，但是實際遊玩時間就只有9天而已。剩下的這9天也沒有浪費，也有去不同的地方看看。
7/1再一次前往「東京哈利波特影城」，這次恰好碰到「一週年活動」，也買到了1週年的限定物品，有夠幸運的！
7/3就到了名古屋快閃一天，體驗了一回晚上搭夜光巴士前往另外一個城市，雖然坐得很累，但是有體驗到當地人凌晨搭車前往別的城市！因為只有一天，行程沒有去到很多地方～
7/5是從名古屋回到東京，當天下午就去了參觀「吉卜力公園」，看到了很多宮崎駿的作品，《龍貓》、《千與千尋》等等，還不錯！
7/8就去看了赤板看「哈利波特與被詛咒的孩子」舞台劇。這場舞台劇要看3小時40分鐘，有夠長！這比「復仇者聯盟4」還長了，哈哈哈。雖然我們坐的是最便宜（雖然還是要7000日幣），但是還是有享受到那種氛圍。但問題是講的是日語根本沒聽懂劇情是什麼。雖然這樣，但是特效是很神奇的！很值得看！
7/9最後一天就過得比較輕鬆一些了，直接到街機店玩，哈哈哈，超爽！也把剩下的日幣花得差不多了～
7/10離開日本
感想 雖然是只有9天的時間，但也沒有因為之前已經體驗的差不多而停下腳步，時間用好用蠻，能體驗多少就體驗多少，哈哈哈！很滿足！</content></entry><entry><title>6月份的日本</title><url>/memories/jp-june/</url><categories/><tags><tag>jp</tag><tag>japen</tag></tags><content type="html"> 6月份在日本體驗生活的日記 2024年6月1日 ～ 2024年6月30日 行程 不知不覺得再日本度過了一個月，這個月除了在東京以外，還去了大阪和京都這2個原理東京的地方旅遊！
6月初的時候去了「藤子・f・不二雄博物館」參觀，這裡放了很多有關藤子・f・不二雄的創作經歷和作品，講述了創作「多啦A夢」之前的歷程。
隨後6月10號跟6月11號都去了「東京迪士尼海洋」遊玩，因為之前迪士尼海洋6/6新開園區「fantasy springs 夢幻泉鄉」開幕，然而新園區的遊樂設施必須要拿到DPA/預約等候卡才能進去。但是提早入園卷只有住飯店的人才能得到，所以我們為了確保能進入到新園區遊玩。但是迪士尼海洋一共有6個飯店，只有住在其中2個飯店「東京迪士尼海洋夢幻泉鄉大飯店」以及「東京迪士尼樂園大飯店」才能獲得。我們5月份刷了很幾天，終於是刷到了「東京迪士尼樂園大飯店」，雖然不是對著表演區，哈哈哈。6/10號的時候，我們就提著行李出發前往迪士尼海洋，當時還下著小雨呢。一到樂園就馬上去飯店checkIn和放下行李馬上就去遊玩，但幸運的是在等待其他遊樂設施的途中，讓我們意外的刷到了「冰雪奇緣」的預約等候卡，超級幸運的，明天就可以少搶一個了，嘿嘿！晚上，我們買了海洋表演的DPA，雖然天氣的關係沒有看到煙花，但是這個表演還是很值得看的！！
6/11早上，我們拿著提早入園卷在外面等候，其實已經有很多人早早在外面等待了。一入園我們就馬上拿起手機開始搶！但是我的信用卡有問題搶DPA失敗，可惡，我們最後也成功拿到「魔髮奇緣」的預約等號卡以及「小飛俠」的DPA，雖然最後沒有成功拿到「小仙子」的預約等號卡，但是「小飛俠」卻拿到了2次預約等號卡，哈哈哈，也算是有進到新園區多次了😌。在離開園區之前也再看了一次海洋的表演，真的很值得看，下次再去的話還是一樣會看完再離開。
到了6/13，我們就出發前往大阪和京都的9天之旅。去大阪是搭乘日本國內航班前往，比起新幹線便宜很多呢。在大阪主要還是去「環球影城日本 - USJ」，我們在6/14前往USJ，我在裡面主要是去了「哈利波特區」以及「超級馬里奧區」，讓我印象最深刻的是當時在「哈利波特區的貓頭鷹郵局」買了明信片，店員就帶我們去郵箱那邊，他就說了一句「為什麼你穿著『葛萊芬多學院』的校服，但是是背著『勞文克勞學院』的包包？」，我就默默從口袋拿出魔杖，店員就做出嘴巴閉閉的手 …</content></entry><entry><title>5月份的日本</title><url>/memories/jp-may/</url><categories/><tags><tag>jp</tag><tag>japen</tag></tags><content type="html"> 5月份在日本體驗生活的日記 為什麼會在日本這麼久呢 本來的計劃是去日本旅遊7天左右的，而且在2月底的時候機票和酒店都定好了，但是因為工作上的一些的原因，就從7天換成了2個月了，哈哈哈。因為酒店定了不能退，所以就在淺草那邊住了7天的酒店，然後就到朋友家住了，嘿嘿，快樂！
心驚動魄的事情 出發當天進入日本已經晚上10:45分，skyliner末班車晚上11:00，拿完票10:58分，差點要睡大街 之前去了富士山玩一天，想說去富士山站看看，然後4:30左右上了巴士到了富士山站後，才發現巴士要很久才一班，然而我的高速巴士是6點左右的車，還好可以搭JR回去，不然真的回不去了 之前在打街機打到了11:30分，本以為會來得及搭車的，結果沒想到到了上野站的時候，銀座線末班車早我1分鐘到達小丑 之前去了涉谷Sky玩，在Sky那邊很大風，從口袋拿出相機的時候，口袋裡面的2萬塊掉了出來，差點飄走 一樣是在涉谷Sky玩，那邊有個可以躺的東西，我就躺了下去結果零錢就從口袋裡面掉了出來，還好沒有很多，不然虧大了 感受 在這個月裡面，剛踏入日本的哪一刻就覺得這裡的天氣真舒服，雖然有陽光看上去好像很熱，但卻會有涼涼的風吹出來，又熱又亮的感覺。雖然很舒服，但是這個感覺只持續了不到2週就結束了，看來是春天已經結束了，來到了夏天。因為日本的天氣真的很乾，然後我的皮膚也很乾，乾乾的天氣配合上的乾乾的皮膚，超級癢，特別是很熱的時候，嗚嗚。
在這個月裡面。吃過了很多日本的食物，但是這些食物基本上都不包含蔬菜類的，所以基本上都在便秘😅，還有些食物不知道為何我吃完就會肚子疼🤣。然而景點也去了很多個，但好像也沒有網路上說的那麼震撼呢～原本是有所期待的，但是卻跟想像中的有點落差，不過還是很漂亮的呢～ 希望下個月的行程會更豐富更美好！（真的不要下雨了，都哭了)</content></entry><entry><title>[開發者日記] 聊天通訊APP(完結) - 總結</title><url>/post/chat-app-final-summary/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 Hi, 已經有一段時間沒有更新了，因為最近在研究多人串流的問題。這篇文章主要是分享我做了些什麼以及對這個project做個總結，這裡的意思就是這個project終於完成了！！花了我近1年的時間呢。
雖然這個project已完成，但是依然還有些問題，如果我們之後還有這個能力在修復～ 這些問題使得串流沒有這麼的穩定，但還是可以玩的呢！
在進入今天主題之前，如果你不記得或不知道這個project關於什麼的話，可以回去閱讀這幾篇文章：
ChatApp(I) ChatApp(II) ChatApp(III) ChatApp(IV) ChatApp(V) ChatApp(VI) ChatApp(Ⅶ) ChatApp(Ⅷ) ChatApp(IX) 這裡是App的最新截圖： 問題描述 我之前開發了一對一的音視頻通話，所以也想把多對多的音視頻通話也用出來。在這個時候，我遇到到了問題就是一對一的通話是通過P2P進行傳輸的，但是如果使用相同的方式來實作多對多音視頻傳流的話，在多人的時候會導致upstreaming有過高的網絡成本，使得效能下降。客戶端需要上傳他的音視頻數據給n-1個客戶端。這裡不單單只有upstreaming，還是downstraming，所以需要找到一個方法解決這個問題。
這裡是我上面所講訴的問題的網絡拓墣 - Mesh.
每個在網絡中的user需要與其餘n-1個user建立連線用於上傳和下載多媒體數據
解決方案 經過數月的研究，我找到了一個合適的解決方案。這個解決方案的名稱為SFU(Selective Forwording Unit)以及另外一個解決方案為MCU(Multipoint Control Unit)。這裡我選擇使用了SFU解決方案來解決上訴的問題。如果你對SFU和MCU有興趣，可以閱讀 這篇文章 以獲得更多的資訊
SFU(Selective Forwording Unit) MCU(Multipoint Control Unit) Mesh vs SFU vs MCH Mesh
每個客戶端會與其他在網絡中的user建立p2p連結，並透過此連結進行通訊。也就是每單一個客戶端需要管理n-1個連結以及需要上傳自己的音視頻訊號給n-1個用戶，在少人的情況下還可以接受，但是在多人的情況下對於上傳者的上傳band-width而言是一項挑戰
SFU
理解SFU的簡 …</content></entry><entry><title>2023年度總結(2023 annual summary)</title><url>/memories/summary-of-2023/</url><categories/><tags><tag>2023</tag></tags><content type="html"><![CDATA[  2023目標進度條目標： 找到合適的工作 -&amp;gt; 算了找了工作 競賽積分達到1700+ : 鴿了 嘗試拿下Knight 段位 : 鴿了 英文聽說讀寫好好練 -&amp;gt; 持續學習 多參與活動 -&amp;gt; 參與的活動還是很多的 考好雅思 -&amp;gt; 持續學習 年初 1月份的時候， 大概2年半快3年沒回家是時候應該要回家一趟了。於是就訂了1月10號的機票回家。或許是太久沒有踏入這個成長的地方感覺真的變的不一樣了，真的有種離鄉別井多年回到家的感覺，很懷念且很感動！然而這個時候還在疫情影響恢復的初期，所以大家都帶著口罩以免感染。在疫情這2年，我在台灣都沒有感染過，回來第一週就被感染，真的有夠不幸，嗚嗚嗚。不過我的症狀並沒有像網路上說的一樣呼吸困難，發燒等痛苦的症狀，只有喉嚨像被刀割。雖然很痛苦，但是一週後就康復了。很幸運，不用去住醫院，不幸的是我爸被我傳染了，但他也很快也就康復了！
這次回來其實我覺得自己是一個遊客多過像一個本地人。康復後的第一個時間就是到處跑，去以前經常去的地方，以前沒去過的地方等等。對於以前經常去過的地方對比以前我有了不一樣的感覺，還會特地放下腳步觀察以前曾不會去留意的事和物十分的有趣；而對於沒去過的地方就當作是旅遊來看，哈哈哈。除此之外，也跟了很多以前的朋友，同學吃飯，聊了很多這些年發生和學生時代發生過的事情，真的是回憶滿滿！最後也去了「香港迪士尼樂園」，上一次去已經是10幾年前，也就是小學4年級的時候學校帶過去，我對那次的記憶基本上已經很模糊了，只記得一小部分～這次來真的讓我很感動，使我回憶起來迪士尼角色陪伴我成長的片段，特別是晚上的「迪士尼星夢光影之旅」的點綴，更加讓人差點眼淚止不住的流，嗚嗚嗚。期待下一才再來看的時候，有別的不一樣的感覺！
新年過後，2月10號我便回到了台灣繼續我的尋找工作之旅，但是在2月這段時間我也有在陸續投遞CV同時在思考自己是否應該必須留在台灣工作，台灣知否真的適合自己等問題，也跟朋友們和家人討論，經過一段時間的掙扎後，我便下定了決心，離開🇹🇼。在現階段🇹🇼感覺不是很適合我，可以現暫時離開回🇭🇰工作，如果日後真的很想要再回🇹🇼，還可以另尋他法。痛定思痛就跟房東說出了自己要離開🇹🇼的決心，於4月1號退租。其實說出口的這段時間還是有點猶豫的，但說出來了就不能在回頭了。再剩下的最後這1個多月裡，除了處理如何把東西寄回家，不能寄回 …  ]]></content></entry><entry><title>香港迪士尼跨年(迪士尼第一次跨年活動)</title><url>/memories/last-day-of-2023/</url><categories/><tags><tag>memories</tag><tag>2023</tag><tag>disney</tag></tags><content type="html"> 因為2023年年初的時候有去香港迪士尼遊玩一天，就想著就在迪士尼來在完美的ending。於是便有了年尾去迪士尼度過最後一天的念頭，剛好今年迪士尼也是第一次舉辦跨年活動，開心！！！！
所以就想透過此文章記錄一次這個完美的時刻！嘿嘿😁
享受快樂的時光❤️❤️❤️❤️</content></entry><entry><title>[開發者日記] 聊天通訊APP - 貼圖更新(III)</title><url>/post/chat-app-sticker-shop-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 如果您想了解該項目的內容，請閱讀以下文章
ChatApp(I) ChatApp(II) ChatApp(III) ChatApp(IV) ChatApp(V) ChatApp(VI) ChatApp(Ⅶ) ChatApp(Ⅷ) Demo 簡介 正如我在 這篇文章 中提到的，我添加了一個關於貼紙的新功能，它可以在聊天中使用提供的貼圖資源。但這還不夠，對用戶來說也不靈活。因此，我開發了更多關於貼紙功能的內容。
首先，由於使用者只能使用ADMIN提供的貼紙，因此不允許使用者在沒有ADMIN的情況下新增任何其他貼圖資源。而且，應用程式中的所有用戶都有相同的貼圖，因此不同的用戶沒有不同的貼圖。因此，我在應用程式中添加了一個貼圖商店，允許用戶選擇他們想要使用的貼圖。
其次，在先前的版本中，使用者透過API存取貼圖資源來取得數據，這對於頻繁取得相同的資源效果不佳。因此，我添加了一項功能，要求用戶將貼圖下載到他們的裝置上才能使用。用戶下載完貼圖資源後，如果帳號擁有相同的貼圖，則可以在同一裝置上的不同帳號之間共用下載的資源。
總結 在這個版本中，我更新了一些關於貼圖功能的內容。
Sticker Shop供用戶將自己喜歡的貼圖添加到他們的帳戶中：Sticker Shop的貼紙現在只能透過API添加） 將貼圖下載到本機，並在同一裝置上的不同帳戶之間共用相同的資源。 我的分享到此結束，感謝您的閱讀^^，再見！</content></entry><entry><title>[開發者日記] 聊天通訊APP - 限時動態更新(III)</title><url>/post/chat-app-story-view-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 如果您想了解該項目的內容，請閱讀以下文章。 ChatApp(I) ChatApp(II) ChatApp(III) ChatApp(IV) ChatApp(V) ChatApp(VI) ChatApp(Ⅶ) ChatApp(Ⅷ) Demo 描述 在先前的版本中，用戶只能查看好友的故事並回覆該限時動態。它除了回覆故事之外不能和朋友有任何互動，所以在這個版本中，我打算為它添加更多的互動功能。
我更新了三個主要功能。第一是限時動態能被喜歡；第二個是限時動態所有者可以查看誰看到了該故事，並且能夠向觀眾發送訊息；最後一件事是與任何朋友分享一個限時動態。所有這些功能實現起來並不困難，因此我沒有任何可以與您分享的技術問題。
本文只是簡單記錄我在這個版本中更新的內容。
希望您有美好的一天。享受！</content></entry><entry><title>[開發者日記] 聊天通訊APP - 限時動態更新(II)</title><url>/post/chat-app-story-multiple-img-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 如果您想了解該項目的內容，請閱讀以下文章。 ChatApp(I) ChatApp(II) ChatApp(III) ChatApp(IV) ChatApp(V) ChatApp(VI) 這是關於限時動態功能的demo，類似於instagram（我的UI參考來自instagram xD）。
我為這個功能做了什麼？
允許使用者在他的故事中添加文字或圖像。 為了使故事編輯器更加靈活，添加了對齊系統和縮放、旋轉和移動。 Baisc 屬性，例如：文字 - （文字顏色、粗體、背景等）、圖像（邊框） 允許朋友透過按讚按鈕來喜歡這個限時動態。 這篇文章只是簡單分享一下我最近做了些什麼xD
我的分享到此結束，感謝您的閱讀^^，再見！</content></entry><entry><title>[開發者日記] 聊天通訊APP - 限時動態更新(I)</title><url>/post/chat-app-story-alignment-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 如果您想了解該項目的內容，請閱讀以下文章。
ChatApp(I) ChatApp(II) ChatApp(III) ChatApp(IV) ChatApp(V) ChatApp(VI) Demo TODO 在先前的版本中，它確實允許用戶將多個文本添加到他們的限時動態中。但如果不使用眼睛就很難對齊所有文字項目。因此，在這個版本中，我決定添加一個對齊工具來幫助他們，這類似於「Instagram」對齊工具。
如何實作 為了實現這個功能，我們首先需要知道使用者想要對齊的項目的「寬度」和「高度」。由於項目可以縮放和旋轉，因此寬度和高度會與原始尺寸不同，因此我們需要先獲得正確的尺寸，然後才能開始對齊。
你可能想知道在縮放和旋轉之後我們如何才能得到正確的尺寸。對於縮放來說，它比旋轉要容易一些，我們只需要把尺寸乘以比例的factor，就可以得到正確的縮放尺寸。但是要計算旋轉後的大小，我們需要一些數學來幫助我們，這是我們在高中學過的，那就是「三角函數」。應用這個數學，我們可以輕鬆計算寬度和高度。
獲得正確的尺寸後，我們可以開始對齊項目。對齊函數只是一個簡單的計算，所以我不會在這裡分享細節，但我會在這裡提供所有這些函數供您參考！
To calculate the size
GeometryReader{ proxy -&amp;amp;gt; Color in DispatchQueue.main.async { self.currentItemSize = proxy.size let newWidthAfterRotate1 = self.currentItemSize.height * sin(box.angle.radians) let newWidthAfterRotate2 = self.currentItemSize.width * cos(box.angle.radians) let newHeightAfterRotate1 = self.currentItemSize.height * cos(box.angle.radians) let newHeightAfterRotate2 = self.currentItemSize.width * sin(box.angle.radians) self.currentItemSize.width = …</content></entry><entry><title>[開發者日記] 聊天通訊APP - 貼圖更新(I)</title><url>/post/chat-app-sticker-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 關於這個專案我就不多說了，如果你對這個專案有興趣的話，請看我之前的貼文。在之前的文章中，我已經詳細介紹了這個專案。 ChatApp(I) ChatApp(II) ChatApp(III) ChatApp(IV) ChatApp(V) 在demo影片中，您可以看到貼圖功能與網路上任何其他即時通訊應用程式類似。用戶能夠存取我們提供的所有可用貼圖並將其發送給其他用戶或群組。但問題是我們如何提供使用者貼圖資源，貼圖從哪裡來呢？
為了解決第一個問題，我們可以透過在客戶端或使用者能夠存取它之前將所有必要的圖像上傳到伺服器來建立貼圖資源。每個建立的貼圖資源都會被分配一個唯一的ID作為其貼圖ID。與相同貼圖ID相關的所有資源都將以標準化格式重新命名，以便於存取。 stickerID_index.format。
我設計了 2 個用於創建和獲取貼圖的api。
POST /api/v1/sticker -&amp;gt; 建立一組貼圖並將所有相關貼圖上傳到伺服器 GET /api/v1/sticker/:id -&amp;gt; 取得給定id的相關貼圖資源
為了解決第二個問題，現在我只是簡單地透過網路爬蟲下載了Line的貼圖如果應用程式發布則存在非法問題xD。所以貼圖只是為了測試！
總結 貼圖是png格式的圖像。要實現貼圖功能，我們只需要獲取貼紙的路徑並將其發送給接收者，類似於發送普通圖像。不過，不需要將圖片上傳到伺服器，因為貼圖資源已經保存在伺服器上。
這就是我今天要分享的全部內容！</content></entry><entry><title>[Leetcode] Maximum Twin Sum of a Linked List(M)</title><url>/leetcodes/leetcode2130/</url><categories><category>leetcode</category></categories><tags><tag>list</tag><tag>two pointer</tag></tags><content type="html"><![CDATA[  LeetCode 2130 - Maximum Twin Sum of a Linked List In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &lt;= i &lt;= (n / 2) - 1.
For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4. The twin sum is defined as the sum of a node and its twin. Given the head of a linked list with even length, return the maximum twin sum of the linked list.
example
Input: head = [5,4,2,1] Output: 6 Explanation: Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6. There are no other nodes with twins in the linked list. Thus, the maximum twin sum of the linked list is 6. Input: head = [4,2,2,3] Output: 7 Explanation: The nodes with twins present in this linked list are: - Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7. - Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4. Thus, the maximum twin sum of the linked list is max(7, 4) = 7. Input: head = [1,100000] Output: 100001 Explanation: There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001. How can we solve this problem? The question told us the length of the given list will be even. So, We can try to use two-pointer approach to find out which node is the n/2th. After we found it out, there&rsquo;s a problem we are facing on, is that the twins node of the n/2th is n/2 - 1th node. Thus, we need to reverse all nodes before n/2th node. Then we can keep moving the pointer and find the maxinum twin&rsquo;s til the end of the list.
A simple graph of this approch
Orignal List: a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f the n/2th node : d reverse all nodes before b: a&lt;-b&lt;-c d-&gt;e-&gt;f both list has the same length ,the ending condtion will be either list a or list b. Solution(Recursion): 我們可以在initial透過Recursive Function來遍歷Input,並把所有Integer先Push到Array/List裡面。然後在定義一個pointer用於存取Next的值即可。
/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * }; */ //calling hasNext -&gt; next class NestedIterator { vector&lt;int&gt; ans; // vector&lt;NestedInteger&gt; list; int cur = 0; void getValue(vector&lt;NestedInteger&gt;&amp; data){ for(int i = 0;i&lt;data.size();i++){ if(data[i].isInteger()) ans.push_back(data[i].getInteger()); else getValue(data[i].getList()); } } public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) { getValue(nestedList); } int next() { return ans[cur++]; } bool hasNext() { return cur &lt; ans.size() ? true:false; } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Solution: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: int pairSum(ListNode* head) { ListNode* slow = head, *fast = head; ListNode* pre = nullptr ,*cur = nullptr, *nxt = nullptr; int ans = 0; while(fast != nullptr){ fast = fast-&gt;next; if(fast != nullptr){ fast = fast-&gt;next; } //reverse the head list cur = slow; nxt = slow-&gt;next; cur-&gt;next = pre; pre = cur; slow = nxt; } ListNode* left = pre,*right = slow; while(left != nullptr &amp;&amp; right != nullptr){ ans = max(ans , left-&gt;val + right-&gt;val); left = left-&gt;next; right = right-&gt;next; } return ans; } };   ]]></content></entry><entry><title>[DONE] Chat App - 2024/04/20</title><url>/project/chat-app/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> Chat App - Frontend Chat App - Backend 簡介 因為之前的OTT電影社群APP中有包含通訊的功能，但是那個App所實現的功能就只是簡單的存文字聊天而已，而那個app主要的focus點並不在通訊上，所以只有簡簡單單的實作了通訊，沒有到完整的通訊，例如：發送文字，發送圖片，發送文件等等的通訊功能。所以這次的side project所實作的app則主要focus在通訊這個點上。
主要功能 Chat-App主要會包含一下之功能
用戶登入/註冊 修改用戶資料 新增用戶為好友(聊天) 刪除用戶 新增聊天群 加入聊天群 退出聊天群 修改聊天群資訊(群主特權) 查看群資訊 查看用戶資訊 單聊 - 與已加好友通訊 群聊 - 與加入之群組通訊 語音通訊(單人) 視頻通訊(單人) 特別之功能 - 限時動態(24小時動態)
限時動態的新增與刪除 好友動態查看 好友動態回覆 限時動態內容多元 允許文字與多張圖片且可縮放、旋轉、邊界對齊 好友動態新增 點讚 分享動態 查看已看列表，且可留言 新增貼圖商店 &amp;amp; 貼圖下載保存於用戶端 聊天內容新增 - 貼圖 語音通訊(多人) 視頻通訊(多人) 技術棧/工具 SwiftUI UIKit Go-Zero MySQL Gorm Docker Websocket WebRTC K8S AWS App 測試影片 開發階段Demo #1 開發階段Demo #2 開發階段Demo #3 開發階段Demo #4 開發階段Demo #5 開發階段Demo #6 開發階段Demo #7 開發階段Demo #8 開發階段Demo #9 開發階段Demo #10 開發階段Demo #11</content></entry><entry><title>[開發者日記] 聊天通訊APP - RTC小更新</title><url>/post/chat-app-voice-chat/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 我在 [開發者日記] 聊天通訊APP(一) 中有提及過這app會有
語音通訊 視頻通訊 這次他們真的來了！！廢話少說先看視頻
說明 雖然現在只有展示了語音通訊(Voice-chat),但是他們的工作原理其實是差不多的，就差在有沒有傳送視頻數據而已。老實說，這個功能其實言研究了2個月都不知道要從何入手，而github上的simple-demo又是UIKit的版本，所以就一直拖，一直研究。知道最近就想試試也無妨，最多也就不成功，萬一它成功了呢！於是我便開始寫，寫了1-2天，發現失敗了，哈哈哈。然後debug了一下，發現好像是沒有連接上的問題，於是又花了一整天來測試是否有成功連接，當成功連接上且文字數據傳送成功的那一刻，那個激動的心啊❤️！！！然後打開視訊，還真的成功了！！！！好開心！
而我這裡用到是WebRTC這個框架。根據網絡上的文章以及我的理解說：要使用P2P連結，就要先繞過NAT，知道自己的Public IP，並通過STUN/TRUN Server來操作！哪這裡我是怎麼做的呢？
首先，要先跟另外一方交換SDP(Session Description Protocal),這裡的資訊包括很多，例如攝像機的sepc，解碼的資訊等等，有興趣可以自行google！而這裡我是透過Websocket 進行交換的。發起人發送offer的SDP，而接收人返回answer的SDP。這樣設備的資訊就交換完成了 接下來就是交換IP和進行連結,這邊我是有過google的public 的ICEServer，並把Ice Server 返回回來的candidate資訊也交換一樣，然後就可以建立P2P連結了！ 以上便是解決這個問題的心得，如果之後還有什麼心得，會繼續更新！
更新 視頻通訊 - Video Chat 這邊就不拍Demo視頻了🤣
支援Mic/Speaker/Video開啟與關閉，鏡頭與切換 其實視訊的部分也只是Voice Chat開啟了視訊數據傳輸而已啦，哈哈哈！其他部分都一樣的呢。這邊就不多說了。
這裡基本上所有功能都實現了，剩下就只是測試和部署。讚
參考資料 WebRTC Swift-RTC SwiftUI-RTC 何謂 WebRTC</content></entry><entry><title>[開發者日記] 聊天通訊APP(四) - 最終章</title><url>/post/chat-app-final/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"><![CDATA[  簡介 在之前 序章 中，雖然已經大概介紹過這個app在幹嘛。但是因為這次是最終章的成品展示(或許有些部分沒實現😂)，所以就允許我囉嗦得再說一次吧！
這個app主要是focus在Websocket，也就是實時通訊上。雖然但是HTTP的部分還是不能少的🤣，哈哈哈。所以這個App的Server-side包含了HTTP和Websocket 2個部分。HTTP的部分主要是用作CURD,而Websocket的部分則是用於個人通訊和群組通訊。
Tech Stack SwiftUI Golang Go-Zero Gorm Mysql Redis Docker/Docker-compose App的功能如下：
基礎功能： 用戶登入與註冊 用戶資料修改，包括用戶頭像，名字和狀態訊息(Status Message) 獲取用戶資訊 尋找好友(透過名字查找) 新增/刪除好友 獲取已加好友列表 建立群組，其中建立群組可以選擇要邀請加入的好友，在建立時會一同加入到群組中。 尋找群組(透過群名) 加入未加入的群組/離開已加入的群組 群組資訊修改(群組權限)，可修改群組頭像和群組名稱 獲取群友類表 獲取已加入群組列表 額外功能: 新增用戶的限時動態(24小時) 獲取用戶好友動態 獲取特定限時動態 刪掉特定限時動態 回覆特定好友之限時動態 - 透過Websocket 發送訊息給動態用戶 核心功能 個人聊天 - 透過Websocket 發送訊息 群組聊天 - 透過Websocket 發送訊息 各聊天室都支援以下訊息: 文字 圖片(如:jpg,png) 文件(如:pdf,docx,txt,ppt,etc.) 音頻(如:wav,mp3) 視頻(暫只支援mp4) 功能細節(後端) HTTP API的部分就不一一詳細解說了，也僅僅是CRUD而已，😂哈哈哈。
用戶API - POST /api/v1/user/signup -&amp;gt; 用戶註冊 - POST /api/v1/user/signin -&amp;gt; 用戶登入 - GET /api/v1/user/info -&amp;gt; 獲取特地用戶資訊 - GET /api/v1/user/profile -&amp;gt; 獲取朋友資訊 - PATCH /api/v1/user/info -&amp;gt; 更新資訊 - PATCH /api/v1/UpdateUserStatus …  ]]></content></entry><entry><title>[開發者日記] 聊天通訊APP(三) - 聊天小更新</title><url>/post/chat-app-update/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 廢話少說直接上影片
對上一次的 demo 中，雖然也包含了個人聊天和群組聊天的部分，但是只支援普通文本和圖片的傳送，而這次修復了文件發送，音頻發送已經視頻發送的部分。而音頻可以直接聆聽接收到的音頻，而視頻則可以直接觀看。
除此之外還添加了系統資訊，例如：群組的建立，群組加入，群組退出並通知群組人員。
更新 - 聊天 支援文本，圖片，音頻，文件，視頻 群組系統通知 實作方法: 文本 ： 這個就比較簡單，就直接講發送文本設置到content field，透過Websocket發送即可。 圖片 ： 這個就不能直接發送了(也是可以直接發送，但是這樣content就會超大，你們猜猜用什麼方法，哈哈哈)。這邊我是透過先將圖片上傳到server，並將上傳API回傳的path，透過websocket發送。 文件，音頻，視頻：這個也是跟圖片發送相似，透過先上傳，再websocket發送。</content></entry><entry><title>[開發者日記] 聊天通訊APP(二) - Demo</title><url>/post/chat-app-demo/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 這篇文章主要是展示一下整個App的Demo，廢話不多說，先上視頻:
Demo說明 這個App的詳細介紹在 [開發者日記] 聊天通訊APP(一) 中已經有基本的介紹，這裡就不作過多的介紹了。
這裡主要是說明一下以上Demo中所展示的內容：
用戶登入和註冊 用戶資訊修改，包括上傳Avatar, Cover, 修改Status Message等 新增好友 給好友發訊息，另外一方如果上線則會即時收到訊息,否則會視為離線消息保存，待用戶上線後再發送。 建立用戶群組 加入用戶群組 查找群組 群組通訊,只有加入了群組的使用者才能收到訊息 單人聊天，其中一方為好友即可發送訊息，無須都戶為好友 發布個人動態到限時動態，只有加了好友者才能觀看 下拉刷新更新好友動態 給動態留言，並透過socket發送給特定之用戶 Backend Github IOS Client Github</content></entry><entry><title>[開發日記] 聊天通訊APP(一) - 序章</title><url>/post/chat-app-init/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 因為之前的OTT電影社群APP中有包含通訊的功能，但是那個App所實現的功能就只是簡單的存文字聊天而已，而那個app主要的focus點並不在通訊上，所以只有簡簡單單的實作了通訊，沒有到完整的通訊，例如：發送文字，發送圖片，發送文件等等的通訊功能。所以這次的side project所實作的app則主要focus在通訊這個點上。
這次的聊天通訊App主要會包含一下之功能
用戶登入/註冊 修改用戶資料 新增用戶為好友(聊天) 刪除用戶 新增聊天群 加入聊天群 退出聊天群 修改聊天群資訊(群主特權) 查看群資訊 查看用戶資訊 單聊 - 與已加好友通訊 群聊 - 與加入之群組通訊 語音通訊(暫定) 視頻通訊(暫定) 特別之功能 - 限時動態(24小時動態)
限時動態的新增與刪除 好友動態查看 好友動態回覆 app 截圖 階段性Demo 進度 完成
用戶登入/註冊 好友添加/移除 好友查詢 建立群組 單聊/群聊 發布/移除個人限時動態 查看好友限時動態 限時動態留言 離線消息推送(上線時推送 通訊功能
發送文字 發送圖片 發送文件(doc,pdf,ppt,etc) 發送限動回覆 待修復(發現問題)
限動留言聊天室資訊錯誤(發送方) - 已修復 refresh 功能缺失 - 已修復 限動錯誤/提醒(限動不存在,已發送留言等)</content></entry><entry><title>🇹🇼倒數</title><url>/memories/last-moment-in-taiwan/</url><categories><category>taiwan</category></categories><tags><tag>taiwan</tag></tags><content type="html"> 在2023年1月的時候，因為已經快3年沒有回家了，所以勢必要回去一趟。所以在1月10號的時候買了回去的票。其實這次回去只要還是想看看香港的環境如何。在這個月裡面跟高中同學吃飯也了解到了許多資訊,開始考慮是否可以回來找工作，畢竟台灣找工作還是有一點難度，工作環境好像也沒有很優。除此之外，去年也有在考慮到澳洲讀研究生，如果在台灣工作可能很難達到這個目標，所以決定回來找工作，回來就只是為了存錢，沒有別的。
哪為什麼是4月份才要離開呢？因為租房子那邊，如果要不繼續租的話，需要提前一個月告知。其實離開這個決定是在回來台灣的時候思考的，也就是2月10號。考慮了大概半個月，並下定決心。因此需要在多租一個月的時間，大概就是4月初的時候離開。在離開前，我想在最後的這段時間好好享受。嗚嗚嗚
2月份 寒假過後，2月10日回來，在這之前已經決定要去台南找莉淇姐姐，雖然只去1天一夜。那就回來當天就收拾好東西，另外一天早上8點鐘就出發！根據網絡上的數據，我本來以為搭客運到台南只要4個多小時，沒想到啊，最後花了快6個小時，嗚嗚嗚。到了台南後，莉淇姐姐就開機車來載我（第一次被女生載&amp;amp;gt;&amp;amp;lt;, 沒想到載我的會是莉淇姐姐!）。而這天的行程就是去KTV唱歌，晚上就去喝牛肉湯，順便到附近走走。吃完飯過後，就先去青年旅社check in。但是過後不知道能幹嘛，哈哈哈。最後決定到附近的桌遊店玩！玩到了關店！開勳。
另外一天，中午就去吃了壽司，這也是我第一次在台灣吃壽司欸！不錯不錯！雖然等了一段時間吃吃得到，嗚嗚嗚。過後，因為的票是下午5點鐘的車，離5點還有一點時間，所以就跟莉淇姐姐找了個咖啡廳聊天～讚！到了差不多的時間，就載我去車站離開了！回程的時間也差不多快6個小時，幹！台南很棒，下次不去了，嗚嗚嗚。
3月份 而這個月開始也是我決定好要離開的最後一個月了，而這個月主要的行程就是約人見面和吃飯！這個月我約了很多人，我也去了好幾個地方。
跟朋友們吃飯,室友，同學，學長們 都是某人約我去的，我就順便去了，我壓根不知道會有這麽多人😏！ 跟Ellie吃飯聊天的一天 其實我們已經好久沒有講過話，上次認真講話已經是大一的時候的事了，當時我也只是問問他要不要一起出來吃飯(應該會被拒絕的吧？)，沒有想到她居然答應了，嗚嗚嗚🥹，好開心，居然還能約出來。我們就去了那個大稻埕吃晚餐，還被要求拍照了。在吃飯的時候，聊天聊了很 …</content></entry><entry><title>[筆記] Binary Search 演算法</title><url>/post/note-binarysearch/</url><categories><category>note</category><category>algorithm</category></categories><tags><tag>note</tag><tag>algorithm</tag></tags><content type="html"><![CDATA[  Binary Search 演算法是用於在一個有序array中搜尋一個值的演算法 - TC:O(log n)。相較於Linear Search(線性搜尋) - TC:O(n),其效率大大提高。
這篇文章就主要紀錄Binary Search 的不同的搜尋方式。
在有序數組中尋找特定的值 這種問題比較簡單，就只要直接比較值是否一樣，如果一樣直接返回index。但如果是比特地值小/大，因為給定的數組是有序的，我們就可以直接將搜尋區間縮小即可(取決於比搜尋的值較大還是較小，較小往較大值的範圍趨近，否則往較小值的範圍趨近) 。
尋找特定值之代碼
func binarySearch(vector&amp;lt;int&amp;gt; arr,int value){ int i = 0; int j = arr.size() - 1; while(i &amp;lt;= j){ int mid = i + (j - i) / 2; //middle index between i and j point if(arr[mid] == value) return mid; //the value is found. else if(arr[mid] &amp;lt; value) i = mid + 1; //the arr[mid] is less than value,search in [mid + 1,j] else if(arr[mid] &amp;gt; value) j = mid - 1; // the arr[mid] is greater than value,search in [i,mid - 1]; } return -1; //NOT FOUND } 在有序數組中搜尋最接近特地值的最小/最大index 在某些情況下，在特定數值中可能會出現多個一樣的特定值，找到了特別的值後直接返回可能不一樣的最小index或者最大index。哪我們就要透過以下的2種區間搜尋方式來尋找。尋找最小(收縮右邊界)，搜尋最大(收縮左邊界)。
搜尋左邊界
int binarySearch(vector&amp;lt;int&amp;gt; arr,int value){ int left = 0; int right = arr.size(); // while(left &amp;lt; right){ //not equals ,coz …  ]]></content></entry><entry><title>[筆記] KMP - Knuth-Morris-Pratt 演算法</title><url>/post/note-kmp/</url><categories><category>note</category><category>algorithm</category></categories><tags><tag>note</tag><tag>algorithm</tag></tags><content type="html"><![CDATA[  KMP(Knuth-Morris-Pratt) 算法是一個用於字符串匹配的一個算法，但確實有點抽象和複雜，因此打算寫一篇筆記來紀錄一下這個算法！
給定一個text以及pattern字符串，透過KMP 算法可以在text中是否存在pattern這個字符串。
返回在text中匹配pattern的index的位置。如果沒有找到則返回-1. case 1: text : aaaaaabcccd pattern : aaabc aaaaaabcccd aaabc 我們可以看到text的index = 3的位置匹配到了pattern，因此返回3 --------------------------------------------------------------- case 2: text : aaaaaabcccd pattern : aabd 可以看到text中並不存在這個pattern，因此返回-1 如果我們透過暴力解也可以找到text中是否存在pattern，但TC為O(n * m),其中n為text的長度以及m為pattern的長度。代碼如下：
int strStr(string text,string pattern) { int n = text.size(); int m = pattern.size(); for(int i = 0;i &amp;lt; n;i++){ int j; for(j = 0;j &amp;lt;,;j++) { if(text[i+j] != pattern[j]) break; } if(j == m) return i; } return -1; //pattern isn&amp;#39;t exist in text } 以上這個算法，pattern對會與text進行匹配，即便是不存在的字符也會進行比較，多做了無必要的操作。例如：
text : aaabaaac pattern aaac 使用暴力解的話，pattern中並不存在b這個字符串，但還會把text的i pointer給回退回去，從下一個index 開始比較。 Step: aaabaaac aaac (不匹配) aaabaaac aaac (不匹配) aaabaaac aaac (不匹配) aaabaaac aaac (不匹配) aaabaaac aaac (匹配) -&amp;gt; …  ]]></content></entry><entry><title>2022年度總結(2023 annual summary)</title><url>/memories/summary-of-2022/</url><categories/><tags><tag>2022</tag></tags><content type="html"> 年初 今年是我踏入大學的第四年，也就是大學生活的最後一年的最後一個學期，這個學期也沒有什麼課程可以修，主要修的是《雲端系統》, 《編譯器原理》以及《網絡安全與管理》。因為當時看到課程安排的寬鬆，因此打算抽出部分時間去實習，因此開始了尋找實現之旅。可能經歷有點少，在找實習的過程中處處碰壁，申請了眾多公司都沒有回應，只有提交了作業跟申請的Dcard Backend Intern給我發了感謝信，而且也拿到了一間Block chain的公司的面試機會，但是因為是橋生的關係再加上申請的期限已截止，只能夠面試一次，因此實習之旅宣告失敗。因此只能收拾心情迎接畢業的到來。
在這段時間裡除了找實習以外，也準備了英文的考試。本來是準備要考IELTS的，但是讀了幾周後覺得考試費用有點貴，而且我也沒有把握，因此打算轉去考TOEIC,IELTS的話需要更多的練習。在我學習了TOEIC的一個多月後，便去了國立台灣大學的考場考試。最後出來的結果也出乎我的意料拿到了660/990。這應該是我在2022年上半年唯一順利的事情了吧！嗚嗚嗚
年中 到了大四下學期末，也就是我迎接畢業的時候到了。但是因為我要延期居留證的話就必須要先找到房子，因此我開始尋找房子之旅。這段時間大概維持了1個多月，在7月尾到8月頭的時候找到一間心儀的房子，我便一大早打電話去約房東看房子，也因為當天我是第一個看房子，也成功的找到了房子了！(^▽^)
不過在這段尋覓房子的日子裡，我也沒有閒著沒有做。在6月底，也就是暑假開始的時候，打算把我的Final Year Project(畢業專題) 砍掉重構。說幹就乾。首先從後端開始重構。因為我只年初的時候學習了一個蠻好用的Framework Go-Zero, 而且我以後打算往Golang方向發展，因此選擇了使用Go-Zero重構Vapor Swift的API。除此之外，前端的部分UI大改，並添加了一些新的功能例如：文章發佈，文章留言，文章點讚，文章留言回復，個人聊天，添加好友，刪除好友以及·個人資訊等。在這段時間大概重構了約30%-40%左右。
期間也跟同學約了出去玩。這次的活動是同學安排去一個龍洞的地方，我完全對這個地方沒有什麼概念，以為只是一個海灘或者樂園的地方。意想不到的是哪裡居然是在懸崖邊上，而且玩的地方是在居然是在海里！對我一個完全不會游泳的人來說有夠可怕，因此同學就把他的浮標借我 …</content></entry><entry><title>2022年LeetCode年度總結(Summary)</title><url>/post/lc-sumarry-of-2022/</url><categories/><tags><tag>2022</tag><tag>leetcode</tag></tags><content type="html"> Leetcode 總結 雖然在2021年暑假的這段時間有刷過一整子大概有50道題左右，但是2021年9月到12月在忙畢業專題因此就停止了。直到我12月份去找投實習MataApp 的全棧實習生時，公司給我發來了一份OA或叫面試題並要求在2小時內完成。當時就很激動的便開始寫了(實習問的都有多難),結果都的是算法題(當時一臉懵逼)。最後我花了將近5個小時的時間才完成(超時),收到了深深的打擊(收到了感謝信)，也下定了決心2022年好好認真刷題。
從2022年1月27日開始達到100道題開始至2022年12月31日達到622道。
成功獲得了2022年Leetcode年度勛章 在2021年9月的時候第一次參與雙週賽，可能是第一次玩有點緊張加上是晚上因此只解出了一道。不過在第二天的週賽很難得的AK(All Kill)了4道題(很神奇吧~可能是因為這次比較簡單)！在這之後基本上是穩定2題，偶爾3題。有時候第二題沒想到怎麼解，就只有1題(又或者是我太菜QQ)。
2022年9月18日-Leetcode 第311場周賽 2022年獲得勛章 每日一題月勛章 * 8 (5月 - 12月) 學習計劃 * 5 2023年目標 掌握Dynamic Programming 掌握Graph 嘗試Hard 題 競賽1700+</content></entry><entry><title>簡歷模板 Resume Template</title><url>/resources/resume-template/</url><categories><category>resume</category><category>resources</category></categories><tags/><content type="html"> 中英文簡歷模板 English CV Template(docx) 中文模板(docx) 資料來源 DBC</content></entry><entry><title>透過Kops工具在AWS中部署K8S集群</title><url>/post/kuberneters-on-aws/</url><categories><category>cloud native</category></categories><tags><tag>tutorial</tag></tags><content type="html"><![CDATA[  這篇文章主要是講述如何在AWS雲服務中部署Kubernetes集群 首先，我們需要準備使用一下工具進行設置
KOps - 一個能讓我們輕鬆無痛部署Kubernetes到任何雲服務的工具，可以想象為集群的kubectl AWS IAM - 申請一個能讓Kops存取權限的賬號 AWS S3 Bucket - 用來作為存取Kubernets資料的資料庫 AWS Route53 - 用於使用自定義Domain Name 並連接到Master Node中 GoDady - 作為DNS 服務供應商 前置工作 在電腦中安裝KOps工具用於幫助我們部署集群 想要了解更多關於KOps的讀者，可以參閱 kOps-Kubernetes Operations 安裝: Linux
curl -Lo kops https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d &amp;#39;&amp;#34;&amp;#39; -f 4)/kops-linux-amd64 chmod +x kops sudo mv kops /usr/local/bin/kops Macos
curl -Lo kops https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d &amp;#39;&amp;#34;&amp;#39; -f 4)/kops-darwin-amd64 chmod +x kops sudo mv kops /usr/local/bin/kops 或者使用 Homebrew 安裝
brew update &amp;amp;&amp;amp; brew install kops Window
到 KOps的github 中的Release中下載kops-windows-amd64 重新命名為kOps，並設置為環境變數 安裝AWS Cli 到AWS 的官方網站中直接下載安裝即可 AWS …  ]]></content></entry><entry><title>[Side-Project] Movie App</title><url>/project/movie-app/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> Movie App - Frontend Movie App - Backend 簡介 開發這個App的目的主要是為了解決在搜尋電影OTT資源以及電影內容討論分散在多個不同平台等問題，如:搜尋到的資源是無效/不合法的，花費大量時間在搜尋上等等&amp;hellip;。因此這個App主要分成2個組成部分，分別是電影資訊搜尋獲取OTT資源，並整合不同OTT平台的電影資源，供用戶選擇合法資源，並過濾無效資源以及電影分享社群，供用戶在觀看完電影後，直接在App中發佈相關文章以分享給其他用戶，而無需在不同平台發佈。
主要功能 用戶基本功能(登入/登出/修改資料等) 提供海量電影資源供用戶查閱(約100w+) 提供用戶點讚電影以及收藏電影 提供有效電影的OTT資源(如:Netfilx,Disney+,YoutubeTV等) 提供社群平台讓用戶發佈電影文章，對其他用戶的文章點讚,留言,回復留言等社群功能 提供用戶瀏覽其他用戶個人資訊(如:發佈之文章,點讚的電影,以及個人收藏的專輯) 用戶可與相互為朋友的用戶進行簡單文字交流,分享更多資訊 分享App文章到社交媒體(如: Instagram) 技術棧/工具 SwiftUI UIKit Comebine Go-Zero MySQL Gorm Docker Websocket CI/CD Pipeline (Github Action + AWS CodeDeploy) TMDB - 電影數據來源處 K8S AWS App 測試影片 階段性測試 最新版本</content></entry><entry><title>[總結]Leetcode 週賽第319場復盤總結</title><url>/post/leetcode-contest319/</url><categories><category>summary</category></categories><tags/><content type="html"> 今日為2022年11月13日(週日) - Leetcode 週賽第319場 目前參加週賽主要的目的是學習跟訓練，所有當前主要focus在解Easy 跟 Medium的題目，Hard的題目暫且先跳過了
週賽題目如下: Convert the Temperature - Easy Number of Subarrays With LCM Equal to K - Medium Minimum Number of Operations to Sort a Binary Tree by Level - Medium Convert the Temperature - Easy You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.
You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].
Return the array ans. Answers within 105 of the actual answer will be accepted.
Example
Input: celsius = 36.50 Output: [309.65000,97.70000] Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70. Input: celsius = 122.11 Output: [395.26000,251.79800] Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798. 解題思路 這題沒有什麼難度呢，就直接代題目給的公式就可以AC了
class Solution { public: …</content></entry><entry><title>[Leetcode] Maximum Length of Repeated Subarray(Medium)</title><url>/leetcodes/leetcode718/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag></tags><content type="html"><![CDATA[  LeetCode 718 - Maximum Length of Repeated Subarray Given two integer arrays ``nums1andnums2`, return the maximum length of a subarray that appears in both arrays.
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3,2,1]. Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0] Output: 5 How can we solve this problem? 這題要我們找出2個array中最長的相同subarray。這題有點類似於 最長公共子序列 ,但是不同的是子序列不一樣的連續的,而subarray是必須要連續的。哪我們只需要改寫一下最長公共子序列,我們只需要更新相等的元素即可。其餘的都不需要關心。
Solution: class Solution { vector&lt;vector&lt;int&gt;&gt; dp; public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { /* [0,1,1,1,1] [1,0,1,0,1] we need to know where the max length between num 1 and num 2 suppose i = 0,j = 0 dp[0][0] = the longest length of subarray in num2[i:n-1]num2[j:m-1] */ int n = nums1.size(); int m = nums2.size(); int res = 0; dp = vector&lt;vector&lt;int&gt;&gt;(n+1,vector&lt;int&gt;(m+1,0)); for(int i = 1;i&lt;n+1;i++){ for(int j = 1; j &lt;m+1;j++){ if(nums1[i-1] == nums2[j-1]){ dp[i][j] = 1 + dp[i-1][j-1]; } res = max(dp[i][j],res); } } return res; } };   ]]></content></entry><entry><title>[Leetcode] Find Duplicate File in System(Medium)</title><url>/leetcodes/leetcode609/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>map</tag></tags><content type="html"><![CDATA[  LeetCode 42 - Trapping Rain Water Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.
A group of duplicate files consists of at least two files that have the same content.
A single directory info string in the input list has the following format:
&quot;root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot; It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory &quot;root/d1/d2/.../dm&quot;. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory.
The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:
&ldquo;directory_path/file_name.txt&rdquo; Input: paths = [&#34;root/a 1.txt(abcd) 2.txt(efgh)&#34;,&#34;root/c 3.txt(abcd)&#34;,&#34;root/c/d 4.txt(efgh)&#34;,&#34;root 4.txt(efgh)&#34;] Output: [[&#34;root/a/2.txt&#34;,&#34;root/c/d/4.txt&#34;,&#34;root/4.txt&#34;],[&#34;root/a/1.txt&#34;,&#34;root/c/3.txt&#34;]] Input: paths = [&#34;root/a 1.txt(abcd) 2.txt(efgh)&#34;,&#34;root/c 3.txt(abcd)&#34;,&#34;root/c/d 4.txt(efgh)&#34;] Output: [[&#34;root/a/2.txt&#34;,&#34;root/c/d/4.txt&#34;],[&#34;root/a/1.txt&#34;,&#34;root/c/3.txt&#34;]] How can we solve this problem? 這題是也什麼難度，只要透過字串分隔和透過Map保存相同內容(Content)的路徑即可。
Solution: class Solution { public: vector&lt;vector&lt;string&gt;&gt; findDuplicate(vector&lt;string&gt;&amp; paths) { //format : directory fileName(content) fileName2(contnet) //abcd : &#34;root/a/1.txt&#34;,&#34;root/c 3.txt(abcd)&#34; unordered_map&lt;string,vector&lt;string&gt;&gt; m; vector&lt;vector&lt;string&gt;&gt; res; for(auto &amp;str : paths){ //find root path int i = 0; int n = str.length(); while(i &lt; n){ if(str[i] == &#39; &#39;)break; i++; } string root = str.substr(0,i); i++; //after sapce vector&lt;string&gt; files; while(i &lt; n){ //find file name //find file content string fileName,fileContent; while(str[i] != &#39;(&#39;){ fileName += str[i++]; } // cout &lt;&lt; fileName &lt;&lt; &#34; &#34;; i++; //skip ( while(str[i] != &#39;)&#39;) fileContent += str[i++]; // cout &lt;&lt; fileContent &lt;&lt; endl; i+=2; //skip and move to next file m[fileContent].push_back(root + &#34;/&#34; + fileName); } } for(auto &amp;ele : m){ if(ele.second.size() &gt; 1) res.push_back(ele.second); } return res; } };   ]]></content></entry><entry><title>Leetcode Weekly Contest 331(第一次參加競賽)</title><url>/post/leetcodeweeklycontest331/</url><categories><category>leetcode contest</category></categories><tags/><content type="html"><![CDATA[   今天是我第一次參加Leetcode 雙週賽，所以想記錄一下今天的競賽題目。希望能透過博客來記錄自己的競賽狀況。
本週AC題數為:4/4
題目 2413. Smallest Even Multiple(EASY) - AC Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.
Example Input: n = 5 Output: 10 Explanation: The smallest multiple of both 5 and 2 is 10. Input: n = 6 Output: 6 Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself. Solution 這題主要是讓我們返回一個最小的整數是可以同時被n和2整除。哪解這題的思路也很簡單，就是如果n可以被2整除，就直接放回n否者就返回2 * n即可。
class Solution { public: int smallestEvenMultiple(int n) { return n % 2 == 0 ? n : 2 * n; } }; 2414. Length of the Longest Alphabetical Continuous Substring(Medium) - AC An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string &amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;.
For example, &amp;quot;abc&amp;quot; is an alphabetical continuous string, while &amp;quot;acb&amp;quot; and &amp;quot;za&amp;quot; are not. Given a string s …  ]]></content></entry><entry><title>[Leetcode] Trapping Rain Water(Hard)</title><url>/leetcodes/leetcode42/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag></tags><content type="html"><![CDATA[  LeetCode 42 - Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. example
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Input: height = [4,2,0,3,2,5] Output: 9 How can we solve this problem? 這題是給定一個array代表著高度，問我們一共可以裝多少水。這題的解題思路，假設當前是i,那我當前這個i是否可以裝水呢？我們是是不是要知道i的左手邊的最高的柱子(x)和最右手邊的最高的柱子(y)，那跟柱子比較矮而且是不是大於現在這個i。假設IFF x &lt; y &amp;&amp; x &gt; i,哪i可以裝的水就會是x - i那麼多。所以說，我們必須要知道當前i的左邊最高和i的右邊最高是多少。哪要怎麼做呢？我們可以透過預處理的方式，預先計算左手邊(i之前)最大值以及右手邊(i之後)的最大值，然後在根據以上的方法即可解出答案。
Solution: class Solution { public: int trap(vector&lt;int&gt;&amp; height) { int n = height.size(); /* how can we solve this problem? [i] can trap water ?? it determin the min(maxinum number [0..i] ,maxinum number [i...n-1]) but the problem is how can we know what is the maxinum height before i?[0...i] //maybe itself is the local maxinum height and how can we know what is the maxinum height after i ?// /maybe itself is the local maxinum height pre-calculating the left and the right?? */ vector&lt;int&gt; leftHeight(n,0); vector&lt;int&gt; rightHeight(n,0); //init case -&gt;the first height is the maxinum heigh of left height //init case -&gt;the last height is the maxinum heigh of right height leftHeight[0] = height[0]; rightHeight[n-1] = height[n-1]; //precalculating step for(int i = 1;i&lt;n;i++) leftHeight[i] = max(leftHeight[i-1],height[i]); //current i is the heigher one ? for(int i = n-2;i &gt;= 0;i--) rightHeight[i] = max(rightHeight[i+1],height[i]); int res = 0; //calculating trapping water for(int i = 1;i&lt;n-1;i++){ //the first height and the last height can&#39;t trap any water res += min(leftHeight[i],rightHeight[i]) - height[i]; } return res; } };   ]]></content></entry><entry><title>[Leetcode] Palindrome Pairs(Hard)</title><url>/leetcodes/leetcode336/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>tire Tree</tag><tag>string</tag></tags><content type="html"><![CDATA[  LeetCode 336 - Palindrome Pairs Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.
example
Input: words = [&amp;#34;abcd&amp;#34;,&amp;#34;dcba&amp;#34;,&amp;#34;lls&amp;#34;,&amp;#34;s&amp;#34;,&amp;#34;sssll&amp;#34;] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [&amp;#34;dcbaabcd&amp;#34;,&amp;#34;abcddcba&amp;#34;,&amp;#34;slls&amp;#34;,&amp;#34;llssssll&amp;#34;] Input: words = [&amp;#34;bat&amp;#34;,&amp;#34;tab&amp;#34;,&amp;#34;cat&amp;#34;] Output: [[0,1],[1,0]] Explanation: The palindromes are [&amp;#34;battab&amp;#34;,&amp;#34;tabbat&amp;#34;] How can we solve this problem? 在解這題之前我們先要知道有哪些情況是成立Palindrome。
Case 1 ：2個字符串為反向字符串 - &amp;quot;abcd&amp;quot;&amp;quot;dcba&amp;quot; =&amp;gt; &amp;quot;abcd|dcba&amp;quot; Case 2 ：2個字符前中一個與另一個字符串的前面部分為Palindrome,剩餘未能匹配的部分也是一個 Palindrome - &amp;quot;abb&amp;quot;&amp;quot;hcch|bba&amp;quot; =&amp;gt; abbhc|chbba Case 3 : 2個字符的其中一個為空字符，而另外一個自己就是一個Palindrome - &amp;quot;&amp;quot;&amp;quot;aba&amp;quot; =&amp;gt; &amp;quot;aba&amp;quot; 哪我們怎麼才能知道哪些字符串是某字符串的Palindrome呢？
我們 …  ]]></content></entry><entry><title>[Leetcode] Maximum Score from Performing Multiplication Operations(Medium)</title><url>/leetcodes/leetcode1770/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag><tag>dynamic programming</tag><tag>recursion</tag></tags><content type="html"><![CDATA[  LeetCode 1770 - Maximum Score from Performing Multiplication Operations You are given two integer arrays nums and multipliers of size n and m respectively, where n &gt;= m. The arrays are 1-indexed.
You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will:
Choose one integer x from either the start or the end of the array nums. Add multipliers[i] * x` to your score. Remove x from the array nums. Return the maximum score after performing m operations. example Input: nums = [1,2,3], multipliers = [3,2,1] Output: 14 Explanation: An optimal solution is as follows: - Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score. - Choose from the end, [1,2], adding 2 * 2 = 4 to the score. - Choose from the end, [1], adding 1 * 1 = 1 to the score. The total score is 9 + 4 + 1 = 14. Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] Output: 102 Explanation: An optimal solution is as follows: - Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score. - Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score. - Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score. - Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score. - Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. The total score is 50 + 15 - 9 + 4 + 42 = 102. How can we solve this problem? 這題最主要的重點是對於每個multipliers[i],它只能挑選最左邊或者最右邊的值。所有，我們需要知道multipliers[i]拿最左邊的值最後的結果比較大，還是拿最右邊後的結果比較大。為了避免重複計算而超時，所以我們需要使用dp來幫助我們記錄當前最優解。注:因multipliers最多為m個，所有最多只能從nums拿m個數字
dp 定義： dp[i][j], 從前面取了i個,以及後面取了j個，但是因為j很大(n-1),所以我們透過計算當前計算的multipliers的第k個來表示(n - j - i + 1)。當前的multipliers是k。 dp 初始條件 : init 為 INT_MIN Solution: class Solution { vector&lt;vector&lt;int&gt;&gt; dp; public: int maximumScore(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; multipliers) { //n &gt;= m //socre : 0 //m operations //[3,2,1] int m = multipliers.size(); int n = nums.size(); dp = vector&lt;vector&lt;int&gt;&gt;(m+1,vector&lt;int&gt;(m+1,INT_MIN)); return solution(nums,multipliers,0,n-1,n,m); } int solution(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; multipliers,int i,int j,int n,int m){ int currentMul = n - (j - i + 1); //the rest of size of the sub-array is the index of current multipliers if(currentMul == m) return 0; //current maxvalue = choose first or choose end? if(dp[i][currentMul] != INT_MIN) return dp[i][currentMul]; //choose the front val return dp[i][currentMul] = max( (nums[i] * multipliers[currentMul]) + solution(nums,multipliers,i+1,j,n,m),// take left (nums[j] * multipliers[currentMul]) + solution(nums,multipliers,i,j-1,n,m) //take right ); } };   ]]></content></entry><entry><title>[Leetcode] Pancake Sorting(Medium)</title><url>/leetcodes/leetcode969/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>reverse</tag><tag>recursive</tag></tags><content type="html"><![CDATA[  LeetCode 969 - Pancake Sorting Given an array of integers arr, sort the array by performing a series of pancake flips.
In one pancake flip we do the following steps:
Choose an integer k where 1 &lt;= k &lt;= arr.length. Reverse the sub-array arr[0...k-1] (0-indexed). For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3. Return an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct. example
Input: arr = [3,2,4,1] Output: [4,2,4,3] Explanation: We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: arr = [3, 2, 4, 1] After 1st flip (k = 4): arr = [1, 4, 2, 3] After 2nd flip (k = 2): arr = [4, 1, 2, 3] After 3rd flip (k = 4): arr = [3, 2, 1, 4] After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted. Input: arr = [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted. How can we solve this problem? 這題我我們要關注的點是如何將當前數字範圍([0,n))中最大的元素移動到array的最後。從上述例子中，我們可以觀察到:
翻轉[0,最大值的Index] -&gt; 最大值就會被移動到最前面 翻轉[0,n) -&gt; 最大值就會被移動的最後面 我們只需要重複以上步驟，每次做完就代表著[n-i,n-1]的這段範圍是已經被排序了。所以，每次做完只關注n-i-i即可(就是當前位置的前面的所有未排序元素[x,x,x,|y(n-i),y,y(n-1)])。 Solution: class Solution { public: vector&lt;int&gt; pancakeSort(vector&lt;int&gt;&amp; arr) { vector&lt;int&gt; res; /* [3,2,4,1] -&gt; we need to move the large value to the end //move the large element to the front then flip n-1 [4,2,3,1] 4(3) [1,3,2,4] n 4 [3,1,2,4] 3(2) [2,1,3,4] n-1 3 [1,2,3,4] 1 ,3 2 ,4 */ // we need to push the large number to the back // so we need to find out the maxinum number in [0,n] // then reverse [0,maxinum index] and then reverse whole list to make the large number at the end of the list(n) for(auto it = arr.end(); it != arr.begin(); it--){ auto maxVal = max_element(arr.begin(),it); //where is this element in the list if(distance(maxVal,it) &gt; 1){ //if current val is not the maxinum if(maxVal != arr.begin()){ //if current value is not the first one -&gt; no need to put it at the front of the array reverse(arr.begin(),maxVal + 1); res.push_back(distance(arr.begin(),maxVal) + 1); } //move the maxinum value to the back reverse(arr.begin(),it); res.push_back(distance(arr.begin(),it)); //don&#39;t filp sorted element at the end of the array } } // filp(arr,arr.size()); return res; } // void filp(vector&lt;int&gt;&amp; arr,int n){ // if(n == 0) return; // //find the maximun // int max = 0; // int idx = 0; // for(int i = 0;i&lt;n;i++){ // if(arr[i] &gt; max){ // max = arr[i]; // idx = i; // } // } // // move the max value to the front -&gt; flip idx + 1 // res.push_back(idx + 1); // //swap the value // swapVal(arr,0,idx); // //move the large element to the end // swapVal(arr,0,n-1); // res.push_back(n); // //need doing this approach til sorted // filp(arr,n-1); // } // void swapVal(vector&lt;int&gt;&amp; arr,int i,int j){ // while(i &lt; j){ // int temp = arr[i]; // arr[i] = arr[j]; // arr[j] = temp; // i++; // j--; // } // } };   ]]></content></entry><entry><title>[Leetcode] Find Original Array From Doubled Array(Medium)</title><url>/leetcodes/leetcode2007/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>hash map</tag></tags><content type="html"><![CDATA[  LeetCode 2007 - Find Original Array From Doubled Array An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.
Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order. example
Input: changed = [1,3,4,2,6,8] Output: [1,3,4] Explanation: One possible original array could be [1,3,4]: - Twice the value of 1 is 1 * 2 = 2. - Twice the value of 3 is 3 * 2 = 6. - Twice the value of 4 is 4 * 2 = 8. Other original arrays could be [4,3,1] or [3,1,4]. Input: changed = [6,3,0,1] Output: [] Explanation: changed is not a doubled array. Input: changed = [1] Output: [] Explanation: changed is not a doubled array. How can we solve this problem? 這是其實需要我們計算每個數出現的頻率，如果要找出某個數x的雙倍數是否存在於array中，如果存在，我們只需要將x與雙倍數移除(因為每個x只會匹配到一個順便數)。如果不存在，也就代表了這個array並不是一個有效的Double list，直接return false即可。
Solution: class Solution { public: vector&lt;int&gt; findOriginalArray(vector&lt;int&gt;&amp; changed) { if(changed.size() % 2 != 0) return {}; //must be an even size vector&lt;int&gt; res; int n = changed.size(); sort(changed.begin(),changed.end()); unordered_map&lt;int,int&gt; m; for(auto num : changed) m[num]++; //number frequency for(auto num : changed){ if(m.count(num) &amp;&amp; m[num] &gt; 0){ //num is exist? m[num]--; if(!m.count(num * 2) || m[num*2] == 0){ //num * 2 is not exist or num*2 is empty return {}; }else { m[num * 2]--; res.push_back(num); } } } return res; } };   ]]></content></entry><entry><title>[Leetcode] Pseudo-Palindromic Paths in a Binary Tree(Medium)</title><url>/leetcodes/leetcode1457/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>recursive</tag><tag>XOR</tag></tags><content type="html"><![CDATA[  LeetCode 1457 - Pseudo-Palindromic Paths in a Binary Tree Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.
Return the number of pseudo-palindromic paths going from the root node to leaf nodes. example
Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). Input: root = [2,1,1,1,3,null,null,null,null,null,1] Output: 1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). Input: root = [9] Output: 1 How can we solve this problem? 這一題簡單的來說就是讓我們從Binary Tree中找到有幾條path是一個Palindromic(Pseudo-Palindromic)偽迴文串。 也就是說從root到leaft的path是一個Palindromic。 (我們只需要知道path是否能組成Palindromic即可)
哪我們要怎麼知道path是不是Palindromic的呢?
解決這個問題之前,我們先來看一下Palindromic分成了以下2個case。
Odd(Path長度為基數): aabbdbbaa =&gt; a:2,b:2, d:1 從這裡我們可以看得出來,只會有1個值/字符是基數,其餘的都會是偶數。
Even(Path長度為偶數): aabb =&gt; a:2,b:2 從這裡我們可以看得出來,所有值/字符都是偶數。
所以,我們可以直接通過一個array幫助我們計數有多少個值為基數。如果基數數目小於或者等於1的話,就符合了以上這2個條件，否則不能組成一個Palindromic。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int res = 0; int counter = 0; public: int pseudoPalindromicPaths (TreeNode* root) { vector&lt;int&gt; counter(10,0); // from 1 - 9 solution(root,counter); return res; } void solution(TreeNode* root,vector&lt;int&gt; &amp;counter){ //m uses to count how many number in the path //for odd case there will only remind 1 number such that xyzUyxz l //for even case there will not remind any number such that any number in the path occurs twice //example : xxyyzz -&gt; rerange as xyzzyx if(root == nullptr) return; counter[root-&gt;val]++; if(!root-&gt;left &amp;&amp; !root-&gt;right){ //vector sum num be 0 or 1 int oddOccur = 0; for(auto n : counter){ if(n % 2 == 1) oddOccur ++; } //odd element at most appears once if(oddOccur &lt;= 1) res++; counter[root-&gt;val]--; return; } solution(root-&gt;left,counter); solution(root-&gt;right,counter); //check counter[root-&gt;val]--; } };   ]]></content></entry><entry><title>[Leetcode] UTF-8 Validation(Medium)</title><url>/leetcodes/leetcode393/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>binary</tag><tag>bit operation</tag></tags><content type="html"><![CDATA[  LeetCode 393 - UTF-8 Validation Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
For a 1-byte character, the first bit is a 0, followed by its Unicode code. For an n-bytes character, the first n bits are all one&rsquo;s, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10. This is how the UTF-8 encoding would work:
Number of Bytes | UTF-8 Octet Sequence | (binary) --------------------+----------------------------------------- 1 | 0xxxxxxx 2 | 110xxxxx 10xxxxxx 3 | 1110xxxx 10xxxxxx 10xxxxxx 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx example
Input: data = [197,130,1] Output: true Explanation: data represents the octet sequence: 11000101 10000010 00000001. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. Input: data = [235,140,4] Output: false Explanation: data represented the octet sequence: 11101011 10001100 00000100. The first 3 bits are all one&#39;s and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that&#39;s correct. But the second continuation byte does not start with 10, so it is invalid. How can we solve this problem? 這一題其實也不太算是算法題, 只是單純的驗證是不是一個合法的UTF-8。只要根據題目給你條件，就可以判斷出是不是合法的了。
要解這題我們需要判斷UTF-8的長度是多少，然後根據這個長度檢測是否包含了這裡多個BYTE(n-1)即可。
UTF-8 長度為1 =&gt; 沒有其他組成部分，所有ByteCount會是0 UTF-8 長度為2 =&gt; 組成部分包含了2個(包含自己),所以ByteCount會是1 UTF-8 長度為3 =&gt; 組成部分包含了3個(包含自己),所以ByteCount會是2 UTF-8 長度為4 =&gt; 組成部分包含了4個(包含自己),所以ByteCount會是3 因此讀取到(110xx xxx)/(1110 xxxx)/(1111 0xxx) 為UTF-8開頭,接下來就會包含n-1個為10xx xxxx的BYTE(1-byte的除外(0xxx xxxx))。如果不符號這個條件直接返回false即可。
小提示：
0(b00000000) - 127(b01111111) : 0xxx xxxx的最小值與最大值的範圍
128(b10000000) - 191(b10111111) : 10xx xxxx的最小值與最大值的範圍
192(b11000000) - 223(b11011111) : 110x xxxx的最小值與最大值的範圍
224(b11100000) - 239(b11101111) : 1110 xxxx的最小值與最大值的範圍
240(b11000000) - 247(b11011111) : 1111 0xxx的最小值與最大值的範圍
Solution: class Solution { public: bool validUtf8(vector&lt;int&gt;&amp; data) { ios_base::sync_with_stdio(false); cin.tie(nullptr); //UTF 8 1 to 4 bytes //1 byte character -&gt; 8bit -&gt; the first bit is 0 -&gt; unicode //n byte -&gt;first n bytes -&gt; 1 then n+1 -&gt; 0(at most 4) //starting at 2th byte to n-1 byte -&gt; the most significant 2 bits should be 10 /* suppose n = 4 //first number only 11110xxx = 2^3(xxx) (128,64,32,16,8,4,2,1) 1 1 1 1 0 x x x 128+64+32+16 */ /* 0xxxxx data[i] */ int n = data.size(); int byteCount = 0; for(int i = 0;i&lt;n;i++){ //there may be not only one nbyte code?? if(byteCount == 0){ if(data[i] &gt;= 0 &amp;&amp; data[i] &lt; 128 ) byteCount = 0; // for unicode else if(data[i] &gt;= 192 &amp;&amp; data[i] &lt; 224) byteCount = 1; else if(data[i] &gt;= 224 &amp;&amp; data[i] &lt; 240) byteCount = 2; else if(data[i] &gt;= 240 &amp;&amp; data[i] &lt; 248) byteCount = 3; else return false; }else { if(data[i] &lt; 128 || data[i] &gt; 191) return false; //less/greater than 10xxxxx byteCount--; } } // return byteCount == 0; } };   ]]></content></entry><entry><title>[Leetcode] Bag of Tokens(Medium)</title><url>/leetcodes/leetcode948/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>greedy</tag><tag>sort</tag><tag>two pointer</tag></tags><content type="html"><![CDATA[  LeetCode 948 - Bag of Tokens You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed).
Your goal is to maximize your total score by potentially playing each token in one of two ways:
If your current power is at least tokens[i], you may play the ith token face up, losing tokens[i]power and gaining 1a score. If your current score is at least 1, you may play the ith token face down, gaining tokens[i] power and losing 1 score. Each token may be played at most once and in any order. You do not have to play all the tokens. Return the largest possible score you can achieve after playing any number of tokens.
example
Input: tokens = [100,200], power = 150 Output: 1 Explanation: Play the 0th token (100) face up, your power becomes 50 and score becomes 1. There is no need to play the 1st token since you cannot play it face up to add to your score. Input: tokens = [100,200,300,400], power = 200 Output: 2 Explanation: Play the tokens in this order to get a score of 2: 1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1. 2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0. 3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1. 4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2. How can we solve this problem? 這題的解題思路是這樣透過貪心(gready),也就是說我能用多少power換分就用多少，如果不夠了我就用分換power。換句話說，就是先從最低的token開始換,直到足夠的power後，就以分來換取最高的power,直到不符合條件未知或者沒有任何token可以買為止。
因為要知道當前最大和最小，所以要先排序
Solution: class Solution { public: int bagOfTokensScore(vector&lt;int&gt;&amp; tokens, int power) { //maxinum if(tokens.empty())return 0; int score = 0; sort(tokens.begin(),tokens.end()); /* strategy: get the mininum token if not enough -&gt; get maxinum token if it has enough power -&gt; get this token */ int i = 0; int j = tokens.size() - 1; int res = 0; while(i &lt;= j){ if(power &gt;= tokens[i]){ score += 1; power -= tokens[i++]; res = max(res,score); }else if(score &gt; 0){ score -= 1; power += tokens[j--]; } else break; } return res; } };   ]]></content></entry><entry><title>[Leetcode] The Number of Weak Characters in the Game(Medium)</title><url>/leetcodes/leetcode1996/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"><![CDATA[  LeetCode 1996 - The Number of Weak Characters in the Game You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.
A character is said to be weak if any other character has both attack and defense levels strictly greater than this character&rsquo;s attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj attacki and defensej &gt; defensei.
Return the number of weak characters.
example
Input: properties = [[5,5],[6,3],[3,6]] Output: 0 Explanation: No character has strictly greater attack and defense than the other. Input: properties = [[2,2],[3,3]] Output: 1 Explanation: The first character is weak because the second character has a strictly greater attack and defense. How can we solve this problem? 這題就是要我們找出多少個弱角色(會被攻擊的人)。對於這種包含了2個維度資訊的題目(attack,defense)，直接藉並不好解，所以，通常我們都會固定一個維度去解另外一個維度，這樣就會相對容易許多。
這題我們可以透過固定attack這個維度。因為我們知道高attack的可以攻擊低attackd的人。所以我們根據attack做排序。這樣attack就會是單調遞增排序。我們自然就可以不讓管這個維度(因為已經符合 attacki &lt; attackj 這個條件)。之後我們只需要處理defense這個維度就可以了。
defense這個維度必須以單調遞減的方式處理! 為什麼呢?
假設 Attack : [[1,1],[1,2],[2,4]] -&gt; 這裡會有2個attack為1的角色。如果不以遞減的方式除了,這樣就會不符合條件(相同attack不能互打)。所以一遞減方式會變成這樣[[1,2],[1,1]...]，這樣一來就能避免互打的情況
解決完維度問題後，就很簡單了，只需要透過stack就可以知道有多少個人被攻擊了。只要進來的人defense的比stack top的人defense 大就+1即可。
Solution: class Solution { public: int numberOfWeakCharacters(vector&lt;vector&lt;int&gt;&gt;&amp; pro) { //[attacki, defensei] sort(pro.begin(),pro.end(),[&amp;](auto &amp;a1,auto &amp;a2){ if(a1[0]==a2[0]){ return a1[1]&gt;a2[1]; } return a1[0]&lt;a2[0]; }); /* 3: 6 5: 5 6: 3 */ /* get the maxinum defense value from previous group if previous group defense value is greater the current group characteri -&gt; this guy is the weak one in this case: [9,1] is a weak character [10,5] -&gt;[9,1] [10,4] -&gt;[9,1] [10,3] -&gt;[9,1] [10,2] -&gt;[9,1] [9,2] is a weak character [10,5] -&gt;[9,3] [10,4] -&gt;[9,3] */ int res = 0; stack&lt;int&gt; s; for(int i = 0;i&lt;pro.size();i++){ while(!s.empty() &amp;&amp; s.top() &lt; pro[i][1]){ s.pop(); res++; } s.push(pro[i][1]); } return res; } };   ]]></content></entry><entry><title>[Leetcode] Binary Tree Inorder Traversal(Easy)</title><url>/leetcodes/leetcode94/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>traversal</tag></tags><content type="html"><![CDATA[  LeetCode 94 - Binary Tree Inorder Traversal Given the root of a binary tree, return the inorder traversal of its nodes&rsquo; values.
example
Input: root = [1,null,2,3] Output: [1,3,2] Input: root = [] Output: [] Input: root = [1] Output: [1] How can we solve this problem? 這題很簡單,只要使用中序遍歷即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; inorder(root,res); return res; } void inorder(TreeNode* root,vector&lt;int&gt;&amp; res){ if(!root) return; inorder(root-&gt;left,res); res.emplace_back(root-&gt;val); inorder(root-&gt;right,res); } };   ]]></content></entry><entry><title>[Leetcode] Construct String from Binary Tree(Easy)</title><url>/leetcodes/leetcode606/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>array</tag><tag>recursive</tag><tag>dsf</tag></tags><content type="html"><![CDATA[  LeetCode 606 - Construct String from Binary Tree Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.
Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. example
Input: root = [1,2,3,4] Output: &#34;1(2(4))(3)&#34; Explanation: Originally, it needs to be &#34;1(2(4)())(3()())&#34;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &#34;1(2(4))(3)&#34; Input: root = [1,2,3,null,4] Output: &#34;1(2()(4))(3)&#34; Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output How can we solve this problem? 這題就是要讓我們講以string的方式輸出Binary Tree。只要注意他的規則就可以解決這題。
node的children都會被()包裹住 node如果有left-child沒有right-child可以無視right-child的() node如果有right-child沒有left-child,left-child的位置必須包含一個()
根據以上這幾條輸出規則，透過postorder traversal就可以解決。 postorder traversal : traverse Left-child -&gt; Right-child -&gt; self node
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { string res; solution(root,res); return res; } //Solution A string constructStr(TreeNode* root){ if(!root) return &#34;&#34;; string cur = to_string(root-&gt;val); if(root-&gt;left) cur += &#39;(&#39; + tree2str(root-&gt;left) +&#39;)&#39;; else if(root-&gt;right) cur += &#34;()&#34;; //for no left child but right child case if(root-&gt;right) cur += &#39;(&#39; + tree2str(root-&gt;right) +&#39;)&#39;; return cur; } //Solution B void solution(TreeNode* root,string &amp;res){ if(!root) return; res += to_string(root-&gt;val); if(root-&gt;left || root-&gt;right){ res+= &#34;(&#34;; solution(root-&gt;left,res); res+= &#34;)&#34;; if(root-&gt;right){ res+= &#34;(&#34;; solution(root-&gt;right,res); res+= &#34;)&#34;; } } } };   ]]></content></entry><entry><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><url>/leetcodes/leetcode442/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>hash map</tag></tags><content type="html"><![CDATA[  LeetCode 442 - Find All Duplicates in an Array Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
You must write an algorithm that runs in O(n) time and uses only constant extra space. example
Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Input: nums = [1] Output: [] How can we solve this problem? 這題要我們找出所有在Array裡重複出現2次的數字。解法也很簡單, 因為題目也說了數字會出現1次或者2次,哪我們可以透過Map來計數,但當前數字已經出現過1次,也就代表當前數字是重複了2次,加入到結果即可。
Solution: class Solution { public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; res; // unordered_map&lt;int,int&gt; m; int n = nums.size(); vector&lt;int&gt; m(nums.size() + 1); // 1 - n for(int i = 0;i&lt;n;i++){ if (m[nums[i]] == 0) { m[nums[i]] ++; }else{ res.emplace_back(nums[i]); } } return res; } };   ]]></content></entry><entry><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><url>/leetcodes/leetcode2196/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>array</tag><tag>hash map</tag></tags><content type="html"><![CDATA[  LeetCode 2196 - Create Binary Tree From Descriptions You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,
If isLefti == 1, then childi is the left child of parenti. If isLefti == 0, then childi is the right child of parenti. Construct the binary tree described by descriptions and return its root. The test cases will be generated such that the binary tree is valid. example
Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] Output: [50,20,80,15,17,19] Explanation: The root node is the node with value 50 since it has no parent. The resulting binary tree is shown in the diagram. Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]] Output: [1,2,null,null,3,4] Explanation: The root node is the node with value 1 since it has no parent. The resulting binary tree is shown in the diagram. How can we solve this problem? 這是給定一個2維的Array,根據Array[i]建構一棵Binary tree。主要得問題是哪一個是成為Tree root呢?要怎麼知道有哪些Child Node呢?
我們透過Map來幫助我們記錄所有Child Node,以便之後的建構 因每個Child Node都必須有一個Parent Node,也就是說在Map中能找到的Node必定是有Parent的，當找到1個Node沒有在Map中，也就代表著該Node必定是整棵Binary Tree的Head。
根據1跟2的邏輯,並使用一個Loop來建構Binary Tree即可。 Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* createBinaryTree(vector&lt;vector&lt;int&gt;&gt;&amp; des) { unordered_map&lt;int,TreeNode*&gt; m; TreeNode* head = nullptr; //creating all node -&gt;child node for(int i = 0;i&lt;des.size();i++) m[des[i][1]] = new TreeNode(des[i][1]); // all child node,except head node for(int i = 0;i&lt;des.size();i++){ //getting root node from map if(m.find(des[i][0]) == m.end()){ //getting head node TreeNode* root = new TreeNode(des[i][0]); head = root; m[des[i][0]] = root; } if(des[i][2]){ m[des[i][0]]-&gt;left = m.find(des[i][1]) == m.end() ? new TreeNode(des[i][1]) : m[des[i][1]]; }else { m[des[i][0]]-&gt;right = m.find(des[i][1]) == m.end() ? new TreeNode(des[i][1]) : m[des[i][1]];; } } return head; } };   ]]></content></entry><entry><title>[Leetcode] Binary Tree Pruning(Medium)</title><url>/leetcodes/leetcode814/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>recursive</tag></tags><content type="html"><![CDATA[  LeetCode 814 - Binary Tree Pruning Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.
A subtree of a node node is node plus every node that is a descendant of node.
example
Input: root = [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property &#34;every subtree not containing a 1&#34;. The diagram on the right represents the answer. Input: root = [1,0,1,0,0,0,1] Output: [1,null,1,null,1] How can we solve this problem? 這題是要讓我們移除所有不包含1的sub-tree。所以，我們只要透過DFS判斷一下node的left-sub tree 以及 right-sub tree 是否都不包含1: 1. 如果左右子樹都不包含1且當前node為0, 直接返回nullptr 2. 若當前節點為1就返回自身 2. 左子樹不包含1, 當前node的左子樹設成nullptr;同理右子樹不包含1,當前node 的右子數設為nullptr
Solution: class Solution { public: TreeNode* pruneTree(TreeNode* root) { if(!root) return nullptr; root-&gt;left = solution(root-&gt;left); //contain 1? root-&gt;right = solution(root-&gt;right); //contain 1? if (root-&gt;val == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) return nullptr; //remove itself return root; } // TreeNode* solution(TreeNode* root){ // if(!root) return nullptr; // root-&gt;left = solution(root-&gt;left); //contain 1? // root-&gt;right = solution(root-&gt;right); //contain 1? // if(root-&gt;val == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) return nullptr; //remove itself // return root; // } // bool solutionA(TreeNode* root){ // if(!root) return false; // if(!root-&gt;left &amp;&amp; !root-&gt;right) return root-&gt;val == 1; // bool left = solution(root-&gt;left); //contain 1? // bool right = solution(root-&gt;right); //contain 1? // if(!left) root-&gt;left = nullptr; // if(!right) root-&gt;right = nullptr; // return left || right || root-&gt;val == 1; // } };   ]]></content></entry><entry><title>[開發日記]OTT電影社群APP(一)</title><url>/post/dev-ottapp-1/</url><categories><category>side-project</category><category>ios</category><category>dev-diary</category></categories><tags><tag>ios</tag><tag>dev</tag></tags><content type="html"> 最近這2個月都沒有更新發文章，主要是因為這2個月都在專注重構畢業專題的項目，也是只OTT電影平台。
今天這篇文章主要是跟大家分享這2個月所開發的進度和目前開發到的階段，以此作為這個項目的開發日記。
目前的成果 廢話少說，先上圖！
前端UI: 主界面 包含APP4個主要得核心功能
電影預覽與電影搜尋 - 提供了以電影類別預覽以及根據電影情況的預覽。如熱門電影,最受歡迎等&amp;hellip; 用戶電影評論與影評分享 - 可允許用戶在觀看完電影後，寫下觀後感與他人分享 聊天與通知 - 可與朋友進行即時討論 用戶個人頁 - 包含了用戶基本訊息,發佈的文章,喜歡的電影以及收藏的電影 電影搜尋/預覽界面 功能如下：
讓用戶以文字的方式進行電影的查詢
讓用戶按著電影類別來預覽不同的電影
未實現功能如下：
刷新以及獲取更多資料 電影資訊界面 功能如下：
提供電影基本以及詳細資訊(包含電影說明,演員,成員,宣傳影片等) 為用戶提供OTT資源(如有串流平台提供資源)，並直連至該平台進行觀看 為用戶提供相似的電影 用戶可以點讚或者收藏電影 未實現功能如下：
刷新以及獲取更多資料 用戶社群與文章發佈界面 功能如下：
為用戶推送最新的電影評論文章 為用戶推送關注用戶的最新評論文章 用戶可以對文章直接評論以及點讚 用戶可以自行建立文章，發表電影感想 文章都會提供電影導向連接，可直接跳轉至電影詳細 未實現功能如下：
留言點讚 刷新以及獲取更多資料 聊天與通知界面 這部分的界面目前只使用了假數據進行UI設計，還沒設計對應的API
這部分會使用到Websocket 技術的幫助(還在研究當中QQ)
未實現功能如下：
用戶與用戶之間的對話 為用戶推送點讚,關注,留言的通知 直接搜尋好友進行通訊 刷新以及獲取更多資料 個人與他人資訊界面 功能如下：
用戶可以編輯更新個人資訊 用戶可以觀看用戶發表文章 用戶可以觀看用戶點讚電影 用戶可以觀看用戶收藏列表 用戶可以建立自定義的片單 未實現功能如下：
移除片單 移除片單中的電影 刷新以及獲取更多資料 後端API 已完成 SERVER HEALTH USER API USER GENRE API MOVIE API USER GENRE API POST LIKES API LIKED MOVIE API COMMENT LIKES API FRIEND API COMMENT API 待完成 Websocket 消息推送 Unit Test 部署至K8S以及AWS 總結 以上內容就是我7-8月之間所完成的開發事項。但APP還有很多地方沒有完成和完善！讓我們期待下一次的開發日記(*❦ω❦)
謝謝各位的耐心觀看！</content></entry><entry><title>[Leetcode] Reverse Linked List II(Medium)</title><url>/leetcodes/leetcode92/</url><categories><category>leetcode</category></categories><tags><tag>list</tag><tag>recursive</tag></tags><content type="html"><![CDATA[  LeetCode 92 - Reverse Linked List II Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
example
Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Input: head = [5], left = 1, right = 1 Output: [5] How can we solve this problem? 這一題的問題非常的簡單,就是要讓我們在給定的一個list中翻轉(Reverse)[left,right]之間的Node,並返回結果。這題跟Reverse Linked List I解法類似,不同的是多了個翻轉範圍。
首先，我們要做的是在的翻轉的開始的位置。然後再透過recursive來翻轉List,最後返回的node/head再由left位置的Node的前一個Node接起來(如有)就可以了~
Solution: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { ListNode* theNodeAfter = nullptr; // ListNode* pre = nullptr; // ListNode* starting = nullptr; // ListNode* last = nullptr; // ListNode* first = nullptr; public: ListNode* reverseBetween(ListNode* head, int left, int right) { // if(head-&gt;next == nullptr) return head; // if(left == right) return head; // //getting the starting point // int n = right - left; // starting = head; // while(--left &gt; 0){ // pre = starting; // starting = starting-&gt;next; // } // // cout &lt;&lt; starting-&gt;val &lt;&lt; endl; // reverseList(0,n,starting); //reverse list between left and right // if(pre != nullptr) pre-&gt;next = first; // else head = first; // last-&gt;next = afterBreak; if(left == 1){ //found //reverse the list return reverseList(right,head); //reverse the list and return the new head which node is the right node } head-&gt;next = reverseBetween(head-&gt;next,left - 1,right - 1); //keep finding the starting point return head; } ListNode* reverseList(int right,ListNode* head){ if(right == 1){ theNodeAfter = head-&gt;next; return head; } ListNode* last = reverseList(right-1,head-&gt;next); head-&gt;next-&gt;next=head; head-&gt;next=theNodeAfter; // return last; } // void reverseList(int i ,int n,ListNode* head){ // if(i == n){ // afterBreak = head-&gt;next; // head-&gt;next = nullptr; // first = head; // last = head; // return; // } // reverseList(i+1,n,head-&gt;next); // head-&gt;next =nullptr; // last-&gt;next = head; // last = last-&gt;next; // } };   ]]></content></entry><entry><title>[Leetcode DP] K Inverse Pairs Array(Hard)</title><url>/leetcodes/leetcode629/</url><categories/><tags/><content type="html"><![CDATA[  這題主要是學習DP思想，做個小記錄
LeetCode 629 - K Inverse Pairs Array For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &lt;= i &lt; j &lt; nums.length and nums[i] &gt; nums[j].
Given two integersn and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7.
example:
Input: n = 3, k = 0 Output: 1 Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. Input: n = 3, k = 1 Output: 2 Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. How can we solve this problem? 題解 這題就是說給定一個數字n,從[1,n]中所能組成inverse pair為k組的有多少種組合方法。
INVERSE PAIR 的定義：
i &lt; j 且 num[i] &gt; nums[j]
如 [2,1] 的INVERSE PAIR為1; 相反[1,2]的INVERSE PAIR 為 0
解法 這題我們需要使用到DP(動態規劃)
DP規劃:
題目很明確的問了我們在n array 中所能組成K個inverse pair有多少個，所以DP[i][j]表示的是i個數字在array中,組成j。 定義DP[n+1][k+1] 計算DP的值
假設已知dp[4][j], j:0....k 加入4呢? [x,x,x](1-3的任意組合) + 4 dp[4][j] =&gt; 加入4到array 中為j個 inverse pair   ]]></content></entry><entry><title>[Leetcode DP] Counting Bits(Easy)</title><url>/leetcodes/leetcodes338/</url><categories><category>leetcode</category></categories><tags><tag>bit operation</tag><tag>dynamic programming</tag></tags><content type="html"><![CDATA[  LeetCode 338 - Counting Bits Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1&rsquo;s in the binary representation of i.
example:
Input: n = 2 Output: [0,1,1] Explanation: 0 --&gt; 0 1 --&gt; 1 2 --&gt; 10 Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 --&gt; 0 1 --&gt; 1 2 --&gt; 10 3 --&gt; 11 4 --&gt; 100 5 --&gt; 101 How can we solve this problem? 這題要我們解決的問題是給定一個數字n,回傳0 - n中每個數字包含了多少個為1的bits。例如: n=2 =&gt; 00,01,10,回傳的結果便會是[0,1,1]。
Bit Operation approach 這裡我們可以透過bit operation AND 來解決這個問題。從Truth Table中:
A B Y(AND) 0 0 0 0 1 0 1 0 0 1 1 1 我們可以到只有1AND1才會是True,所有我們只需要對每一個bit與當前counter的值做AND,如果為1就bitCounter++就可以計算出每一個值的bits的數目。
因為一個Int類型為4BYTE,包含了32個bits,所以對於[0,n]中每一個數字都必須做32次的LOOP,因此Time Complexity是O(32N)。
Solution: class Solution { public: vector&lt;int&gt; countBits(int n) { for(int i = 0;i&lt;n+1;i++){ int temp = 0; for(int j = 0;j&lt;=31;j++){ if( (1 &lt;&lt; j) &amp; i) temp++; } res[i]=temp; } return res; } }; Dynamic Programming approach 我們可以先觀察一下每個數字的Binary,以n=8為例: 從圖中我們可以看得到只有1個bit為1的數字都是2i,而我們所需要計算的[2i , 2i+1-1]之間的數字的數目即可。 但是,我們要怎麼計算呢?
首先,我們需要知道怎麼計算[2i , 2i+1-1]裡面的bits的數目,然後我們在觀察一下Binary: 如下圖: 我們可以發現[2i , 2i+1-1]都會想相隔2i-1個，也就是說我們只需要定義一個變數j作為offset 就可以移動到需要計算數字的位置( 0 &lt;= j &lt;= 2i-1 )。例如: i=2(22 = 4),2+0(2),2+1(3)。
接下來,我們可以透過DP來幫助我們計算。
定義BASE CASE:
DP[0] = 0 //number 0 不包含任何1&rsquo;s
根據目前2i,求出DP[2i+j] = DP[j],直到計算到(n)
注意: i 會根據i是否到達2i,最後進行Left-Shift(Double自己)
注意: j 作為[0,2i)的指標
例如:
DP[1] = DP[0] + 1 //比DP[0] 多一Bits
DP[2] = DP[0] + 1 //比DP[0] 多一Bits =&gt; 也可以視為在2的區間的1, DP[1] = DP[2] = 1
DP[3] = DP[1] + 1 //比DP[1] 多一Bits DP[4] = DP[0] + 1 //比DP[1] 多一Bits
Solution: class Solution { public: vector&lt;int&gt; countBits(int n) { //Trying to use DP vector&lt;int&gt; dp(n + 1); //from 0 to n dp[0] = 0; //base case int bits = 1; //2^0 = 1 int i = 0; while(bits &lt;= n){ //bits will be pow of 2 -&gt;1,2,4,8,16,24 while(i&lt;bits &amp;&amp; i + bits &lt;= n){ dp[i + bits] = dp[i] + 1; i++; } i = 0; bits = bits &lt;&lt; 1; //double bits value // cout &lt;&lt; bits; } return dp; } };   ]]></content></entry><entry><title>[Leetcode] Kth Largest Element in an Array(Medium)</title><url>/leetcodes/leetcodes215/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>array</tag><tag>priority queue</tag></tags><content type="html"><![CDATA[  LeetCode 1268 - Search Suggestions System Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
example:
Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 How can we solve this problem? 這題要我們解決的問題是回傳在sorted array(Input Array沒有排序)中第kth大的元素。最簡單的解法是直接排序,然後回傳kth元素即可。但是, 這裡我們也可以使用Priority Queue(Heap)來幫我們解決這個問題。因為Priority Queue的特性,越大的值(MaxHeap)/越小的值(MinHeap)會越接近root,也就是說最大值(MaxHeap)/最小值(MinHeap)會在root。所以我們可以運用MinHeap來幫助的我們解決這個問題,只要Priority Queue裡面的元素多於K個我們就會把top的值移除，因更小的值會在前面,每次pop的值都會是當前最小的值,直到最後，省下來的值的root/top就會是我們的第K個最大的值，而priority queue中最後一個值便會是Input中最大的值。
Solution: class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q; for(int i = 0;i&lt;nums.size();i++){ q.push(nums[i]); if(q.size() &gt; k) q.pop(); } return q.top(); } };   ]]></content></entry><entry><title>[Leetcode] Furthest Building You Can Reach(Medium)</title><url>/leetcodes/leetcodes1642/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>heap</tag><tag>priority queue</tag><tag>greedy</tag></tags><content type="html"><![CDATA[  LeetCode 1642 - Furthest Building You Can Reach You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.
You start your journey from building 0 and move to the next building by possibly using bricks or ladders.
While moving from building i to building i+1 (0-indexed),
If the current building&rsquo;s height is greater than or equal to the next building&rsquo;s height, you do not need a ladder or bricks. If the current building&rsquo;s height is less than the next building&rsquo;s height, you can either use one ladder or (h[i+1] - h[i]) bricks. Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally. example:
Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 Output: 4 Explanation: Starting at building 0, you can follow these steps: - Go to building 1 without using ladders nor bricks since 4 &gt;= 2. - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7. - Go to building 3 without using ladders nor bricks since 7 &gt;= 6. - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9. It is impossible to go beyond building 4 because you do not have any more bricks or ladders. Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 Output: 7 Input: heights = [14,3,19,3], bricks = 17, ladders = 0 Output: 3 How can we solve this problem? 這個要我們解決的問題是給定一定數量的磚塊brick和梯子ladder,問我們最遠能到達哪一棟建築(array index)。 我們主要注意的是題目給定的幾個限制條件。
如果i+1的建築比i建築矮,我們可以不用任何磚塊(bricks)或者梯子ladders 如果i+1的建築比i建築搞，我們必須使用一個梯子ladders或者(h[i+1] - h[i])個磚塊(bricks) 從這裡我們可以看到梯子ladders無論建築有多高，我們都可以到達。相反磚塊(bricks)則需要數量。所以，我們要解決這個問題會優先考慮使用梯子ladders。如果梯子ladders 使用完畢，我們可以將前面2個建築之間高度最小的梯子ladders回收,使用磚塊(bricks)取代。如果磚塊(bricks)也不夠或者超出提供的數量，就代表我們最遠可以到達的建築為i-1(因為i建築,我們沒有足夠的磚塊brick和梯子ladder)。如果梯子的數量跟建築的數量一樣多,直接回傳最後一棟(n-1)即可。
Solution: class Solution { public: int furthestBuilding(vector&lt;int&gt;&amp; h, int bricks, int ladders) { //Using all ladders first //if there is no other ladders,we try to use bricks(mininum one) instead of a ladder //if there have enough ladders //just return n-1(index) priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; laddersUsed; //min heap //O(n*log l(min Head insert)) for(int i = 1;i&lt;h.size();i++){ //use all ladders int climbingHeigh = h[i] - h[i-1]; if(climbingHeigh &lt;= 0) continue; //we can climb it laddersUsed.push(climbingHeigh); //our ladder is enough? if(laddersUsed.size() &lt;= ladders) continue; //our ladder is not enough //try to use bricks to instead if our bricks is not enough too,return previous index(neither bricks nor ladders can reach ith building) bricks -= laddersUsed.top(); laddersUsed.pop(); if(bricks &lt; 0) return i-1; } return h.size() - 1; } //Time Exceed // int dfs(vector&lt;int&gt;&amp; h,int i,int bricks, int ladders){ // if(bricks &lt; 0 || ladders &lt; 0) return i-1; // // if(bricks == 0 &amp;&amp; ladders == 0) return i; // if(i == h.size()-1) return i; // int res = 0; // if(h[i] &gt; h[i+1]) { // res = solution(h,i+1,bricks,ladders); // }else{ // //either bricks ladders // int bricksCase = solution(h,i+1,bricks - (h[i+1]-h[i]),ladders); // int laddersCase = solution(h,i+1,bricks,ladders-1); // res = max(bricksCase,laddersCase); // } // return res; // } };   ]]></content></entry><entry><title>[筆記]TrieTree(前綴樹/字典樹)</title><url>/post/trietree/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>data structure</tag></tags><content type="html"><![CDATA[  Introduction 什麼是TrieTree? Trie稱為前綴樹或字典樹,是有序樹的一種,Node的key通常為String類型。Trie Tree與Binary-Searching Tree不同的點是,Trie Tree的Key並不會直接保存在Node中,而是它在Tree中的位置所決定的。一個Node中的所有的childrens都有相同的Prefix(前綴)。假設有個Node的key 為T,它的children將會是Time, Tim, Test等,因為他們都會相同的Prefix(前綴)T。
Trie Tree 的應用 字符前綴匹配 - 網頁URL,搜尋等 搜索關鍵字時,返回前綴最相似的可能結果 Trie Tree 結構圖 Trie Tree Template class TrieNode{ public: TrieNode(){ //suppose we are considering a string consist with a-z //at most 26 childrens for a node child = vector&lt;TrieNode*&gt;(26); } vector&lt;TrieNode*&gt; child; // bool isWord = false; //indicate current word is a word void AddNode(string&amp; str){ TrieNode*root = this; for(int i = 0;i&lt;str.length();i++){ //adding a node that key is str[i] if(!root-&gt;child[str[i] - &#39;a&#39;]) root-&gt;child[str[i] - &#39;a&#39;] = new TrieNode(); root = root-&gt;child[str[i] - &#39;a&#39;]; } } //Other function define here... //Find a word etc... }; 參考資料 https://zh.wikipedia.org/wiki/Trie   ]]></content></entry><entry><title>[Leetcode] Short Encoding of Words(Medium)</title><url>/leetcodes/leetcode802/</url><categories/><tags><tag>string</tag><tag>array</tag><tag>TrieTree</tag></tags><content type="html"><![CDATA[  820 - Short Encoding of Words A valid encoding of an array of words is any reference string s and array of indices indices such that:
words.length == indices.length The reference string s ends with the &#39;#&#39; character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next &#39;#&#39; character is equal to words[i]. Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.
example:
Input: words = [&amp;#34;time&amp;#34;, &amp;#34;me&amp;#34;, &amp;#34;bell&amp;#34;] Output: 10 Explanation: A valid encoding would be s = &amp;#34;time#bell#&amp;#34; and indices = [0, 2, 5]. words[0] = &amp;#34;time&amp;#34;, the substring of s starting from indices[0] = 0 to the next &amp;#39;#&amp;#39; is underlined in &amp;#34;time#bell#&amp;#34; words[1] = &amp;#34;me&amp;#34;, the substring of s starting from indices[1] = 2 to the next &amp;#39;#&amp;#39; is underlined in &amp;#34;time#bell#&amp;#34; words[2] = &amp;#34;bell&amp;#34;, the substring of s starting from indices[2] = 5 …  ]]></content></entry><entry><title>[Leetcode] Longest Palindromic Substring(Medium)</title><url>/leetcodes/leetcode5/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>dynamic programming</tag></tags><content type="html"><![CDATA[  LeetCode 5 - Longest Palindromic Substring Given a string s, return the longest palindromic substring in s.
example
Input: s = &#34;babad&#34; Output: &#34;bab&#34; Explanation: &#34;aba&#34; is also a valid answer. Input: s = &#34;cbbd&#34; Output: &#34;bb&#34; How can we solve this problem? 要解決這題，我們必須要先知道什麼是Palindrome。可以參考這篇文章 Palindromic string迴文 。而這題要我們找出在給定string中,找到最長的Palindrome。我們可以透過以每個單一字元(index i)以及倆個字元(index i,index i+1)為中心點，並擴展left,right找出他們的局部的最長Palindrome為多少，然後根據這個長度計算starting point i以及記錄長度len,最後以starting point和len得出字串中str[startingPoint,len]為解。
Solution: class Solution { public: string longestPalindrome(string s) { /* Using an easy solution &#34;babad&#34; finding all posible palindrome string starting at index i(mid point) odd case: i-1 i i+1 ? Palindrome i-2 i-1 i i+1 i+2 ?Palindrome what about even case.We&#39;re simply starting at index i and i+1 i-1 [i,i+1] i+2 ?Palindrome */ int n = s.length(); int len = 0; int startPoint = 0; //O(n * n(finding Palindrome)) for(int i = 0;i&lt;n;i++){ int cur = max(getLen(s,i,i,n),getLen(s,i,i+1,n)); // which one is longest? odd or even if(cur &gt; len){ //update our len and starting point len = cur; startPoint = i - (len-1)/2; //(len-1) for even case //suppose the len is 3 and the index is 1 ,then the starting point will be 1 - (3-1)/2 =&gt; 0-&gt; len str[0...2] //suppose the len is 4 and the index is 1 ,then the starting point will be 1 - (4-1)/2 =&gt; 0-&gt; len str[0...2] } } return s.substr(startPoint,len); } //str[i..j] is our middle point of Palindrome int getLen(string&amp;str,int i,int j,int n){ //left(i) right(j) while(i&gt;=0 &amp;&amp; j&lt;n &amp;&amp; str[i] == str[j]){ i--; j++; } //string at i+1 and getting //|y|x2|x1|x|x1|x2|y| =&gt; the length of this string is l - r + 1 -(out of bounds of both i and j =&gt; 2) =&gt; l-r-1 return j-i-1; //string at i+1(is decreased from the loop),total } };   ]]></content></entry><entry><title>[筆記]Palindromic String(迴文字串)</title><url>/post/palindromicstring/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>string</tag><tag>dynamic programming</tag></tags><content type="html"><![CDATA[  Introduction 什麼是Palindromic String 迴文字串 所謂的Palindromic String(迴文字串) 就是以一個字元為中間，而它的左邊以及右邊的組成字元相同。
例子:
abcdcba 以d為中心的左跟右的字元一樣。
cdc左跟右都為c
bcdcb 左跟右都為b
abcdcba 左跟右都為a
要怎麼知道String是否為什麼是palindrome(迴文) 要知道String是否palindrome，我們先得知道Palindromic的規則:
單一的字元都是Palindromic，例如: a,b,g&hellip; 某字元的左右字元相同,例如: xax,xbx,xgx&hellip; 某字元自己跟右邊或者左邊相同也是一個也使一個palindrome。例如aa,bb 如果某子串為palindrome,而左跟右字元相同，它也會是一個palindrome。例如palindromeaba,它的左右2邊都為字元x,xabax也使一個palindrome; 相反，左跟右字元不相同,則只有子字串為palindrome。 判斷是否palindrome string 我可以從子串的中心點(middle point)開始往外擴展i,j,如果i跟j位置的為相同字元,則繼續往外擴。如果過程中有i,j位置的字元不相同,我們就可以知道它不是一個palindrome。
在尋找Palindrome的時候，我們必要要考慮到odd和evencase。
odd case : 會以odd基數的方式擴展。 例如: a -&gt; bab -&gt; cbabc&hellip; even case: 會以even偶數的方式擴展 例如: aa -&gt; baab -&gt; cbaabc&hellip; 什麼時候會出現這種情況呢? 例如這個例子:baab。如果只使考慮到odd case,他會被認為不是一個Palindrome。baa,aab&hellip;都不是合法的Palindrom。所以,我們必須考慮到even case。aa,baab是合法的Palindrom。
Palindrome Template //O(n) bool isPalindrome(string str,int i,int j){ while(i&gt;=0 &amp;&amp; j &lt; str.length()){ if(str[i] != str[j]) return false; i--; j++; } return true; } //中心點為Odd(i) isPalindrome(str,i,i); //中心點為even(i,i+1) isPalindrome(str,i,i+1);   ]]></content></entry><entry><title>[筆記]Longest Common SubString(最長公共子序列)</title><url>/post/lcm/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>dynamic programming</tag></tags><content type="html"><![CDATA[  Introduction 什麼是最長公共子序列? 給定2個字串string A和string B,2個字串中所共同擁有的最長的子字串。
例如:
String A : leetcode String B : ecbod 他們的最長公共子序列便是`ecod` 解釋: String A 包含了 __e_cod_ =&gt; ecod String B 包含了 ec_od =&gt; ecod 要怎麼找到最長公共子序列LCM呢? 我們需要定義一個數組用於保存當前情況下的最優解,也就是使用DP的方式。我們需要以每個字符最為考量,並一一匹配，最後得出整體最優解。 LCM Code Template int longestCommonSubStr(string &amp;s1, string &amp;s2){ int n = s1.length(); int m = s2.length(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=m;j++){ if(s1[i-1] == s2[j-1]) dp[i][j] = 1 + dp[i-1][j-1]; //the LCM of previous size + current matched else dp[i][j] = max(dp[i-1][j],dp[i][j-1]); //strA[0..i-2] str[0...j-1] or strA[0..i-1] str[0...j-2] check which one have the longest LCM } } return dp[n][m]; } 參考資料 经典动态规划：最长公共子序列   ]]></content></entry><entry><title>MetaHuman虛擬數字人初探</title><url>/post/mataverse-matahuman/</url><categories><category>mateverse</category><category>modeling</category></categories><tags><tag>matehuman</tag></tags><content type="html"><![CDATA[  因為元宇宙(Metaverse)這個概念火熱,所有我就趁著這個機會了解一下在元宇宙領域中本人覺得比較有趣的東西。也就是這篇文章所要分享給各位的MetaHuman(虛擬數字人/虛擬數位人)
什麼是MetaHuman(虛擬數字人/虛擬數位人)呢? 所謂的MetaHuman(虛擬數字人)是具有數字化形象的虛擬人物，並且具備特定的相貌、性格和性別等人物特征、具備語音，面部表情和肢體動作表達的能力以及擁有人類的思想會具有外界環境與人交流的互動能力。 這裡只是簡略的介紹一下。如果各位對虛擬數字人技術或者發展剛興趣的,可以參考這份 虛擬數字人白皮書 簡單數字人實作 注:本實作之數字人透過輸入自定義音頻生成，並無溝通等能力
使用工具:
Reallusion Character Creator Reallusion IClone 實作步驟也十分的簡單:
我們將透過Reallusion Character Creator製作我們數字人的外觀,然後再將數字人傳入Reallusion IClone做動畫,也就是透過IClone的音頻生成數字人動畫的功能製作動畫。
Step 1:
進入Reallusion Character Creator製作角色(以博主自定義的角色為例)，如下圖: Step 2:
將剛才在CC(Character Creator) 製作的角色匯入到IClone中,如下圖:
Character Creator中: File-&gt;Export-&gt;Send to IClone 匯入音頻文件
Modify-&gt;Facial-&gt;Create Script-&gt;Audio File 預覽動畫結果，並渲染動畫 Demo展示 燈光一展示: 燈光二展示 結論 有沒有發現很簡單又很好玩呢!我們透過Reallusion工具讓我們能在很短的時間內就可以完成一個屬於自己的MetaHuman。除此之外Reallusion還提供很多很強大的功能，例如:圖片生成3D角色模型,手機臉部動作捕捉,與Unreal Engine 5的MetaHuman工具連動等等，有機會的話再跟大家分享。
參考資料:
Reallusion   ]]></content></entry><entry><title>[Leetcode] Combination Sum III(Medium)</title><url>/leetcodes/leetcode216/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag><tag>recursion</tag><tag>back-tracking</tag></tags><content type="html"><![CDATA[  LeetCode 216 - Combination Sum III Find all valid combinations of k numbers that sum up to n such that the following conditions are true:
Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. example
Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination. How can we solve this problem? 這題主要關注的點是數字範圍為[1,9]，每個結果中，數字只能使用一次，而且數字必須是順序排列。例如:2,3,4,1,2,5。解決這題我們可以用back-traking大法。只要我們當前的Sum大於n我們就直接退回back track回上一步,因為數值只會越來越大，並不是我們想要的。如果Ans我們所需的k個就直接判斷是否等於n，如果是就直接加入到我們的result即可。
Solution: class Solution { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { solution(n,k,0,1); return res; } void solution(int n,int k,int sum,int start){ if(k==0){ if(sum == n) res.push_back(tmp); return; } if(sum &gt; n) return; for(int i = start;i&lt;=9;i++){ tmp.push_back(i); solution(n,k-1,sum + i,i+1); tmp.pop_back(); } } };   ]]></content></entry><entry><title>[Leetcode] Letter Combinations of a Phone Number(Medium)</title><url>/leetcodes/leetcode17/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>recursion</tag><tag>back-tracking</tag></tags><content type="html"><![CDATA[  LeetCode 17 - Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
example
Input: digits = &#34;23&#34; Output: [&#34;ad&#34;,&#34;ae&#34;,&#34;af&#34;,&#34;bd&#34;,&#34;be&#34;,&#34;bf&#34;,&#34;cd&#34;,&#34;ce&#34;,&#34;cf&#34;] Input: digits = &#34;&#34; Output: [] Input: digits = &#34;2&#34; Output: [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;] How can we solve this problem? 這題是要我們拿到Input的數字所能組合出所有字串。解法也很簡單，我們可以透過Map記錄每個數字代表來那些字符，然後再透過Back-tracking技巧來幫助我們組合字串。你有可能會問什麼是Back-tracking。簡單來說就是一個Recursive Function,但他會迴避一些不正常的數值。比如:&ldquo;abc&rdquo;,而&quot;abc&quot;可能不是我們要的。因此退回上一步的&quot;ab&quot;,並嘗試其他數值/結果。
Solution: class Solution { unordered_map&lt;char,string&gt; temp = { {&#39;2&#39;,&#34;abc&#34;}, {&#39;3&#39;,&#34;def&#34;}, {&#39;4&#39;,&#34;ghi&#34;}, {&#39;5&#39;,&#34;jkl&#34;}, {&#39;6&#39;,&#34;mno&#34;}, {&#39;7&#39;,&#34;pqrs&#34;}, {&#39;8&#39;,&#34;tuv&#34;}, {&#39;9&#39;,&#34;wxyz&#34;} }; public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt; res; if(digits.length() == 0) return res; solution(res,0,digits,&#34;&#34;); return res; } void solution(vector&lt;string&gt;&amp; res,int index,string &amp;digits,string phone){ if(index == digits.length()){ res.push_back(phone); return; } auto numList = temp[digits[index]]; for(int i = 0;i&lt;numList.length();i++){ phone += numList[i]; solution(res,index+1,digits,phone); phone.pop_back(); } } };   ]]></content></entry><entry><title>[Leetcode] Flatten Nested List Iterator(Medium)</title><url>/leetcodes/leetcode341/</url><categories><category>leetcode</category></categories><tags><tag>design</tag><tag>recursion</tag><tag>iteration</tag></tags><content type="html"> LeetCode 341 - Flatten Nested List Iterator You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.
Implement the NestedIterator class:
NestedIterator(List&amp;amp;lt;NestedInteger&amp;amp;gt; nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. Your code will be tested with the following pseudocode:
initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res If res matches the expected flattened list, then your code will be judged as correct.
example
Input: nestedList = [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. …</content></entry><entry><title>[Leetcode] 132 Pattern(Medium)</title><url>/leetcodes/leetcode456/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"><![CDATA[  LeetCode 456 - 132 Pattern Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].
Return true if there is a 132 pattern in nums, otherwise, return false. example
Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Input: nums = [3,1,4,2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2]. Input: nums = [-1,3,2,0] Output: true Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. How can we solve this problem? 這題就是要我們找出List有沒有符合132 Pattern。那怎麼才算是132 Pattern呢。從題目定義可以看出在List中任意的nums[i] &lt; nums[k] &lt; nums[j]，也就是說nums[k]為最大,nums[j]為第二大,nums[i]`為第三大。
那要怎麼找到是不是符合呢?
假設我們現在的位置是nums[j],我們是否能在找到[0 - j)這個範圍內找到nums[k]以及nums[i]且符合nums[i] &lt; nums[k] &lt; nums[j]就好了呢?
哪我們應該要怎麼做呢?
因為nums[i]都是會是132 pattern當中最小的的值。因此每當iterate時，記錄當前值的左邊的最小的值(當前這個值可能會是k，最小值可能會是i)。當我要判斷一個值是不是j時，我們只需要拿到比他大的值，然後再透過記錄在此值得最小值，跟j做比較是不是符合nums[i] &lt; nums[j]這個條件，我們就可知道當前的j是不是我們要找的。
解題步驟如下:
我們要記錄每個值的左手邊的最小值，用於判斷是不是nums[i] 我們要用定義一個pointer暫存目前的最小值 當我們要判斷當前的值是否會構成132 Pattern,就從先前的記錄中獲取比較當前值還要大的記錄，並且透過記錄中的最小值判斷是不是也小於j,從而得出結論。 Solution: class Solution { public: bool find132pattern(vector&lt;int&gt;&amp; nums) { //i &lt; k &lt; j //if there exist one return true return solution(nums); } // bool burstForce(vector&lt;int&gt;&amp; nums){ // int n = nums.size(); // for(int i = 0;i&lt;n;i++){ // for(int j = i+1;j&lt;n;j++){ // for(int k = j + 1;k&lt;n;k++) // if(nums[i] &lt; nums[j] &amp;&amp; nums[j] &gt; nums[k] &amp;&amp; nums[i] &lt; nums[k]) return true; // } // } // return false; // } bool solution(vector&lt;int&gt;&amp; nums){ //current k int curMin = nums[0]; stack&lt;pair&lt;int,int&gt;&gt; s; //&lt;num,minBeforeNum&gt; for(int i = 1;i&lt;nums.size();i++){ //nums[i] repersent the j //and top will be our k and check min before k while(!s.empty() &amp;&amp; nums[i] &gt;= s.top().first){ //finding the k before j s.pop(); } //checking the top elements of the stack if(!s.empty() &amp;&amp; s.top().second &lt; nums[i]) return true; //checking //push to stack s.push({nums[i],curMin}); curMin = min(nums[i],curMin); } return false; } };   ]]></content></entry><entry><title>[LeetCode] Remove All Adjacent Duplicates in String II(Medium)</title><url>/leetcodes/leetcode1209/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>stack</tag></tags><content type="html"><![CDATA[  LeetCode 1209 - Remove All Adjacent Duplicates in String II You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.
example
Input: s = &#34;abcd&#34;, k = 2 Output: &#34;abcd&#34; Explanation: There&#39;s nothing to delete. Input: s = &#34;deeedbbcccbdaa&#34;, k = 3 Output: &#34;aa&#34; Explanation: First delete &#34;eee&#34; and &#34;ccc&#34;, get &#34;ddbbbdaa&#34; Then delete &#34;bbb&#34;, get &#34;dddaa&#34; Finally delete &#34;ddd&#34;, get &#34;aa&#34; Input: s = &#34;pbbcggttciiippooaais&#34;, k = 2 Output: &#34;ps&#34; How can we solve this problem? 這題就是要我們刪除掉在String裡面某些相鄰且相同並重複了k次的Characters。例如: aeee,k=3，輸出a。如果我們要解決這個問題就要知道目前string裡面有哪些subString符合條件，但是這裡要注意一個問題就是有些Substring被移除後，會使前(刪除Str)後2個substring符合條件。例如:aeeeaa,但我們刪除eee後,aaa也會符合條件，因此會被移除。
哪我們要怎麼知道哪些characters符合條件呢?
這裡我們可以使用Stack/Array來幫組我們解題。為什麼是用Stack? 因為我們只需要關注當前str[i]是否與前一個str[i-1]一致,如果是一致的我們會加入到Stack.top的Counter裡面。只要Counter的值為k我們就知道是符合條件的String，移除即可。最後，把Stack/Array裡面剩餘的元素串接就可以得出最後答案(注:Stack元素串接需要Reverse結果)。
Solution: class Solution { public: string removeDuplicates(string s, int k) { if(s.length() &lt; k) return s; string res; vector&lt;pair&lt;char,int&gt;&gt; counter; //O(n) for(auto str : s){ //how many same character if(counter.empty() || counter.back().first != str) counter.push_back({str,1}); else{ counter.back().second++; } if(counter.back().second == k) counter.pop_back(); } // for(auto e:vc) cout &lt;&lt; e; //O(i*k &lt;= n ) =&gt; O(n); for(int i = 0;i&lt;counter.size();i++){ for(int j = 0;j&lt;counter[i].second;j++) res+=counter[i].first; } cout &lt;&lt; res &lt;&lt;endl; return res; } };   ]]></content></entry><entry><title>[Leetcode] Implement Stack using Queues(Easy)</title><url>/leetcodes/leetcode225/</url><categories><category>leetcode</category></categories><tags><tag>stack</tag><tag>queue</tag><tag>design</tag></tags><content type="html"><![CDATA[  LeetCode 225 - Implement Stack using Queues Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes:
You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&rsquo;s standard operations. example
Input [&#34;MyStack&#34;, &#34;push&#34;, &#34;push&#34;, &#34;top&#34;, &#34;pop&#34;, &#34;empty&#34;] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False How can we solve this problem? 這題就是要我們用Queue來模擬Stack。做這題之前我們要先知道Queue和Stack的差異。
Queue是First In First Out, 也就是先進去的element會先被拿出來 Stack是First In Last Out, 也就是先進去的element最後才會被拿出來 push(int x):
如果要用Queue來模擬Stack就要注意在Queue中的最後一個元素會是Stack的第一個元素。所以，這題我們可以用比較簡單粗暴的方式來解決。因為我們已經知道後進(Last In)Stack的值會是第一個元素。因此,我們可以直接用一個variable保存最後插入進Queue的element即可。
pop()
如果我們要移除element，就必須要將Queue的最後一個元素搬到最前面，同時因為最前面的元素會被移除，所以我們用於保存最後插入進Queue的variable所記錄的值也必須被改變，變成Queue的倒數第二個element。因此我們要先將Queue中最後的2個element搬到最前面，第一個便是我們stack的top,而第二個是我們要pop的element。最後，我們記錄完top的值後，插入到Queue的尾巴，並返回要Queue的front即可。
clear(): 只需將空的Queue取代成當前不是空的Queue即可。
empty():
只需檢查Queue是否為empty()即可。
Solution: class MyStack { public: queue&lt;int&gt; q; int t; // queue&lt;int&gt; q2; MyStack() { } //O(N) void push(int x) { // q2.push(x); // while(!q.empty()){ // q2.push(q.front());q.pop(); // } // q = q2; // clear(q2); q.push(x); t = x; } //O(1) int pop() { // if(empty()) return -1; // int value = q.front();q.pop(); //get the last 2 elements int size = q.size(); while(size-- &gt; 2) { q.push(q.front()); q.pop(); } //getting the 2th top value in stack t = q.front(); q.push(q.front()); //push it at the back of the queue q.pop(); //getting the 1th top value in stack int popVal = q.front(); q.pop(); return popVal; } void clear(queue&lt;int&gt;&amp; q){ queue&lt;int&gt; empty; swap(empty, q); } int top() { // if(empty()) return -1; // return q.front(); return t; } bool empty() { return q.empty() ? true : false; } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */   ]]></content></entry><entry><title>[Leetcode] Max Number of K-Sum Pairs(Medium)</title><url>/leetcodes/leetcode1679/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>map</tag><tag>two-pointer</tag></tags><content type="html"><![CDATA[  LeetCode 1679 - Max Number of K-Sum Pairs You are given an integer array nums and an integer k.
In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.
Return the maximum number of operations you can perform on the array.
example
Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. Input: nums = [3,1,3,4,3], k = 6 Output: 1 Explanation: Starting with nums = [3,1,3,4,3]: - Remove the first two 3&#39;s, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation. How can we solve this problem? 這題就是要移除Array中2個elements加起來等於k的操作有幾次。
第一個解法，我們可以使用sorting以及two-pointer approach來解決。先將array排序，然後設置i為0,j為n-1,直接使用iteration找出nums[i]+nums[j] = k的數，然後answer+1即可。
Solution: class Solution { public: int maxOperations(vector&lt;int&gt;&amp; nums, int k) { //sort sort(nums.begin(),nums.end()); //O n log n int ans = 0; int i = 0,j = nums.size()-1; while(i &lt; j){ if(nums[i] + nums[j] == k) { ans++; i++; j--; }else if(nums[i] + nums[j] &gt; k)j--; else i++; } return ans; } }; 第二種解法是透過map來記錄。首先，會透過x = k - nums[i]得出一個數，如果這個數不存在map裡面或者map[x] &lt;= 0就代表沒有，就把目前的nums[i]加入到map。如果存在，就將answer+1並且從map中移除map[x]的數量(map[x]--)。
Solution: class Solution { public: int maxOperations(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int,int&gt; temp; int ans = 0; for(int i = 0;i&lt;nums.size();i++){ int sum = k - nums[i]; if(temp[sum] &gt; 0){ //exist this value; //for example:[3,1,3,4,3] //3,1,3(we are here) 6-3=3 and 3:1 and we found a pair(3,3)=6 ,and remove the existing value ans++; temp[sum]--; }else temp[nums[i]]++; } return ans; } };   ]]></content></entry><entry><title>[Leetcode] Shortest Unsorted Continuous Subarray(Medium)</title><url>/leetcodes/leetcode581/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"><![CDATA[  LeetCode 581 - Shortest Unsorted Continuous Subarray Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.
Return the shortest such subarray and output its length.
example:
Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Input: nums = [1,2,3,4] Output: 0 Input: nums = [1] Output: 0 How can we solve this problem? 這題比較難懂一點點，這裡先做一下題目的解釋。這題主要先問的是在輸入的Array裡面找到一個最小需要排序的Sub-array。
從例子[2,6,4,8,10,9,15]中，我們可以很明顯的看到[6,4,8,10,9]並不是ascending order(順序),而這個sub-array要進行排序的話，所有elements都需要進行排序，所以，他的length是5。
再舉另外一個例子[1,3,2,3,3]，這個Array我們可以看到[3,2,3,3]並不是順序的，但是在這個sub-array裡面,只有[3,2]需要排序,所以，他的結果會是2。
那我們應該要怎麼解呢? 一個最簡單的解法是定義一個額外的array，而這個array的element跟原來的一樣，但是已經被排序過的。因此，只要比較原本的array和排序過的array有幾個element的位置不一樣就知道結果了。但Time Complexity是是O(n log n) - 排序的時間，而Space Complexity則是O(n)
Solution: vector&lt;int&gt; temp = nums; sort(temp.begin(),temp.end()); //n log n int start = nums.size() - 1; int end = 0; //finding the starting point which is not as same as the sorted array //finding the ending print which is not as same as the sorted array for(int i =0;i&lt;nums.size();i++){ if(nums[i] != temp[i]){ start = min(i,start); // end = max(end,i); } } return end - start &gt;= 0 ? end - start + 1 : 0; 另外一種解法是通過Two-pointer approach來解。我們先要找到左手邊有問題的地方的最小值(1,4,7,5,3,6 最小值為3)以及右手邊有問題的地方的最大值(1,4,7,5,3,6 最大值為7)。然後,要找出左手邊第一個被影響的index(nums[index] &gt; 最小值)。同理也要找出右手邊第一個被影響的最index(nums[index] &lt; 最大值)。這樣我們就能找出有問題的區間[left,right]，在根據left,right得出最終結果。 Solution: 解法二:
int start = INT_MAX; int end = INT_MIN; for(int i = 1;i&lt;nums.size();i++){ if(nums[i] &lt; nums[i-1]) start = min(nums[i],start); } for(int i = nums.size() - 2;i&gt;=0;i--){ if(nums[i] &gt; nums[i + 1]) end = max(nums[i],end); } int left,right; //scanning the value from the left to the right that is less than maximum value for(left = 0;left&lt;nums.size();left++){ //finding the descending point if(start &lt; nums[left]) break; } //scanning the value from the right to the left that is less than minimum value for(right = nums.size() - 1;right &gt;= 0;right--){ if(end &gt; nums[right]) break; } //we need to find out the right-most point return right - left &gt;= 0 ? right - left + 1 : 0;   ]]></content></entry><entry><title>[Leetcode] Sort Array By Parity(Easy)</title><url>/leetcodes/leetcode905/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"><![CDATA[  LeetCode 905 - Sort Array By Parity Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
Return any array that satisfies this condition.
example:
Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Input: nums = [0] Output: [0] How can we solve this problem? 這個問題很簡單，就是把偶數移動到Array的前面，基數移動到後面。我們這裡可以使用Two-pointer approach, i為尋找前面的基數，而j 為尋找後面的偶數，只要nums[i]為基數,nums[j]為偶數就進行交換。
Solution: class Solution { public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; nums) { int i = 0; int j = nums.size() - 1; //O(n) while(i &lt; j){ //i is even skip //j is odd skip //i is odd and j is even swap if(nums[i] % 2 == 0) i++; else if(nums[j] % 2 == 1) j--; else swap(nums[i++],nums[j--]); } return nums; } };   ]]></content></entry><entry><title>[Leetcode] Backspace String Compare(Easy)</title><url>/leetcodes/leetcode844/</url><categories><category>leetcode</category></categories><tags><tag>string</tag></tags><content type="html"><![CDATA[  LeetCode 844 - Backspace String Compare Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
example:
Input: s = &#34;ab#c&#34;, t = &#34;ad#c&#34; Output: true Explanation: Both s and t become &#34;ac&#34;. Input: s = &#34;ab##&#34;, t = &#34;c#d#&#34; Output: true Explanation: Both s and t become &#34;&#34;. Input: s = &#34;a#c&#34;, t = &#34;b&#34; Output: false Explanation: s becomes &#34;c&#34; while t becomes &#34;b&#34;. How can we solve this problem? 這題主要要什麼比較2個String移除於#前的字符後是否為相同的String，就相當於Backspace(#) 字符。 這題有2種解法:
要使用到額外的空間，保存2個移除字符後的String再進行比較。 透過pointerr的方式來決定哪個位置是要被移除的，然後將之後的字符將其進行取代，最後在比較倆者在r長度內的字符是否相同，即可。可見下圖為例: Solution: class Solution { public: bool backspaceCompare(string s, string t) { int slen = s.length(); int tlen = t.length(); int i = 0; int rpSStrIndex = 0; while(i &lt; slen ){ if(s[i] == &#39;#&#39;) { if(rpSStrIndex &gt; 0) rpSStrIndex--; } else s[rpSStrIndex++] = s[i]; i++; } i = 0; int rpTStrIndex = 0; while(i &lt; tlen){ if(t[i] == &#39;#&#39; ){ if(rpTStrIndex &gt; 0) rpTStrIndex--; } else t[rpTStrIndex++] = t[i]; i++; } cout &lt;&lt; rpSStrIndex &lt;&lt; rpTStrIndex; //there length is not same if(rpSStrIndex != rpTStrIndex) return false; //compare each string between replaced Index for(i = 0;i&lt;rpSStrIndex;i++){ if(s[i] != t[i]) return false; } return true; } };   ]]></content></entry><entry><title>[Leetcode] Trim a Binary Search Tree(Medium)</title><url>/leetcodes/leetcode669/</url><categories><category>leetcode</category></categories><tags><tag>binary Search Tree</tag><tag>binary Tree</tag><tag>recursion</tag></tags><content type="html"><![CDATA[  LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.
Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.
example
Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] How can we solve this problem? 這題就是要我們將一顆BST的少於low的部分以及大於heigh的部分移除。這題打算使用遞歸來解決。我們只要將比low小的Node的右子樹接到他的父節點，並取代比low還小的Node，而比heigh大的Node的左子樹接到他的父節點，並取代比heigh還大的Node即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { //space : O(tree node size for all nodes value are between low and height) //time : O(tree node size for all nodes) return TrimBST(root,low,high); } TreeNode* TrimBST(TreeNode* root,int low,int height){ if(!root) return nullptr; //if the root value is less than height ,go right sub-tree //if the root value is greater than low ,go left sub-tree if(root-&gt;val &lt; low){ // root-&gt;left = nullptr; return TrimBST(root-&gt;right,low,height); }else if(root-&gt;val &gt; height){ // root-&gt;right = nullptr; return TrimBST(root-&gt;left,low,height); } //left root-&gt;left = TrimBST(root-&gt;left,low,height); //right root-&gt;right = TrimBST(root-&gt;right,low,height); // cout &lt;&lt; root-&gt;val &lt;&lt; &#34;\n&#34;; return root; } };   ]]></content></entry><entry><title>[Leetcode] Search in a Binary Search Tree(Easy)</title><url>/leetcodes/leetcode700/</url><categories><category>leetcode</category></categories><tags><tag>binary search tree</tag><tag>recursion</tag><tag>binary Tree</tag></tags><content type="html"><![CDATA[  LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
example
Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5 Output: [] How can we solve this problem? 在解決問題之前，我們需要知道什麼是Binary Search Tree。根據BST的定義:
Binary Search Tree 基於Binary Tree left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value Binary Search Tree的key/value都是unique的 現在我們知道什麼是BST了。這個問題是要在BST中找val，我們通過以下幾個條件以及遞歸幫我們求解:
left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value 如果val是小於root,就移動到左子樹(left sub-tree)，否者移動到右子樹(right sub-tree),直到找到val並返回root的pointer或者沒有找到返回null
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(root == nullptr) return root; //check val if(root-&gt;val &gt; val){ //go to left return searchBST(root-&gt;left,val); // }else if(root-&gt;val &lt; val){ return searchBST(root-&gt;right,val); }else{ return root; } } };   ]]></content></entry><entry><title>[Leetcode] Shift 2D Grid(Easy)</title><url>/leetcodes/leetcode1260/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag></tags><content type="html"><![CDATA[  LeetCode 1260 - Shift 2D Grid Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times.
example
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] How can we solve this problem? 其實這個問題很簡單，我們只需要關心grid的最後得column，因為最後一個Column被right-shift到第一個Column的時候，最後一個element會被移動到0th。其餘的column只要right-shift by 1 step即可。 我們可以參考以下數學公式:
n是row size 以及 m 是 column size
left-shifting : currentColum + k % n, moving by k step shifting row : (j + k) / n), if it is in the last column, (j + k) / m will be 1. Otherwise will be 0 total row shifting step : (i + (j + k) / n)) % m. For example, suppose n = 3 , j = 2 , m = 3 and i = 2: (2 + ((2+1)/3)) % 3 = 0 so that it will move to [0][0] Solution: class Solution { public: vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) { //just be careful the last element on [m-1][n-1] //n - k int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(m,0)); for(int i = 0 ;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ //here we need to know how many time does the colums j pass the col 0,then we need to movie the i of that time // (j + k) % m =&gt; total time walk passed int moveJ = (j + k) % m; //if current moving j is the last one int walkPassedZeorTimes = (j + k)/m; int moveI = (i + walkPassedZeorTimes) % n; res[moveI][moveJ] = grid[i][j]; } } return res; } };   ]]></content></entry><entry><title>[Leetcode] Spiral Matrix II(Medium)</title><url>/leetcodes/leetcode59/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"><![CDATA[  LeetCode 59 - Spiral Matrix II Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
example
Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Input: n = 1 Output: [[1]] How can we solve this problem? 這題跟Spiral Matrix做法差不多，我們不難發現他的移動模式就是(右→下↓左←上)，我們只需要通過幾個變數來限制移動的步數。另外，這題需要我們返回一個n2的array，所以，需要額外定義一個counter來記錄每次插入的數值為多少，因此，只要counter 到達n2的大小就知道是否完成插入所需的值。
Solution: class Solution { public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { //total step n^2 vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n,0)); int c = 1; int upperRow = 0,lowerRow = n - 1; int upperCol = 0,lowerCol = n - 1; while(c &lt;= n*n){ //moving left if(upperCol &lt;= lowerCol){ //n step for(int i = upperCol;i&lt;=lowerCol;i++){ res[upperRow][i] = c++; } } upperRow ++; //moving down //moving down if(upperRow &lt;= lowerRow){ for(int i = upperRow;i&lt;=lowerRow;i++){ res[i][lowerCol] = c++; } } lowerCol--; //moving right if(lowerCol &gt;= upperCol){ for(int i = lowerCol;i&gt;=upperCol;i--){ res[lowerRow][i] = c++; } } lowerRow --; //moving up if(lowerRow &gt;= upperRow){ for(int i = lowerRow;i&gt;=upperRow;i--){ res[i][upperCol] = c++; } } upperCol ++; } return res; } };   ]]></content></entry><entry><title>[Leetcode] Game of Life(Medium)</title><url>/leetcodes/leetcode289/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"><![CDATA[  LeetCode 289 - Game of Life According to Wikipedia&rsquo;s article: &ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&rdquo;
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.
example
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] How can we solve this problem? 要解決這個，我們需要知道目前的cell的狀態(活/死)。要知道目前cell的狀態，我們可以用過條件判斷他身邊的cells(最多9個細胞)即可。
Solution: class Solution { public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) { int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(m,0)); //O(N^2 for checking each cells) : time //O(N^2 for storing new cells states) : space for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ int total = checkState(board,i,j,n,m); if(board[i][j] == 1) res[i][j] = (total &lt; 2 || total &gt; 3 ) ? 0 : 1; else res[i][j] = total == 3 ? 1 : 0; } } board = res; } int checkState(vector&lt;vector&lt;int&gt;&gt;&amp; board,int i,int j,int n,int m){ // //neighbors bounds // int rowStart = (i - i) &lt; 0 ? 0 : i - 1; // int rowEnd = (i + 1) &gt; n - 1 ? n - 1 : i + 1; // int colStart = (j - 1) &lt; 0 ? 0 : j - 1; // int colEnd = (j + 1) &gt; m - 1 ? m - 1 : j + 1; int livesCells = 0; //top left if(i - 1 &gt;= 0 &amp;&amp; j -1 &gt;= 0){ livesCells += board[i-1][j-1]; } //top if(i - 1 &gt;= 0){ livesCells += board[i-1][j]; } //top right if(i - 1 &gt;= 0 &amp;&amp; j + 1 &lt; m){ livesCells += board[i-1][j + 1]; } //left if(j - 1 &gt;= 0){ livesCells += board[i][j - 1]; } //right if(j + 1 &lt; m){ livesCells += board[i][j + 1]; } //bottom left if(i + 1 &lt; n &amp;&amp; j - 1 &gt;= 0){ livesCells += board[i+1][j-1]; } //bottom if(i + 1 &lt; n ){ livesCells += board[i+1][j]; } //bottom right if(i + 1 &lt; n &amp;&amp; j + 1 &lt; m){ livesCells += board[i+1][j+1]; } return livesCells; } };   ]]></content></entry><entry><title>[Leetcode] Baseball Game(Easy)</title><url>/leetcodes/leetcode682/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"><![CDATA[  LeetCode 682 - Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&rsquo; scores.
At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:
An integer x - Record a new score of x. &ldquo;+&rdquo; - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. &ldquo;D&rdquo; - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. &ldquo;C&rdquo; - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. example
Input: ops = [&#34;5&#34;,&#34;2&#34;,&#34;C&#34;,&#34;D&#34;,&#34;+&#34;] Output: 30 Explanation: &#34;5&#34; - Add 5 to the record, record is now [5]. &#34;2&#34; - Add 2 to the record, record is now [5, 2]. &#34;C&#34; - Invalidate and remove the previous score, record is now [5]. &#34;D&#34; - Add 2 * 5 = 10 to the record, record is now [5, 10]. &#34;+&#34; - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Input: ops = [&#34;5&#34;,&#34;-2&#34;,&#34;4&#34;,&#34;C&#34;,&#34;D&#34;,&#34;9&#34;,&#34;+&#34;,&#34;+&#34;] Output: 27 Explanation: &#34;5&#34; - Add 5 to the record, record is now [5]. &#34;-2&#34; - Add -2 to the record, record is now [5, -2]. &#34;4&#34; - Add 4 to the record, record is now [5, -2, 4]. &#34;C&#34; - Invalidate and remove the previous score, record is now [5, -2]. &#34;D&#34; - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. &#34;9&#34; - Add 9 to the record, record is now [5, -2, -4, 9]. &#34;+&#34; - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. &#34;+&#34; - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. How can we solve this problem? 這題就是一個簡單的籃球比賽模擬。我們只要關心遊戲rule，並透過額外的container(array/stack)進行分數保存即可。
Solution: class Solution { public: int calPoints(vector&lt;string&gt;&amp; ops) { //ops : + D C x // vector&lt;int&gt; s; //or using a stack stack&lt;int&gt; sk; //O(n) //O(n) for(auto i : ops) { if(i == &#34;+&#34;){ int a = sk.top(); sk.pop(); int b = sk.top(); sk.push(a); sk.push(a+b); }else if(i == &#34;D&#34;){ sk.push(sk.top() * 2); }else if(i == &#34;C&#34;){ sk.pop(); }else{ sk.push(stoi(i)); } } int res = 0; //O(n) while(!sk.empty()){ res += sk.top();sk.pop(); } return res; } };   ]]></content></entry><entry><title>[Note]Creational Singleton Pattern</title><url>/post/creational-singleton-pattern/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Singleton Pattern(單例模式)呢? 定義:一個Class在系統中只會存在一個實例(instance),整個系統中只提供1個可使用的instance,以確保唯一性,並節省系統資源。
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
class的建構子(constructor)對外隱藏,外部無法通過constructor進行實例化，但會提供一個靜態(static)方法，以獲取這個class的唯一實例。 TaskManager
//Constructor 對外隱藏，並提供一個靜態Static 讓外部只透過這個存取 class TaskManager{ private: TaskManager(); void displayProcess(); void displayServices(); static TaskManager* taskManager = nullptr; //保存唯一Instance public: //外部只能透過靜態Static 方法存取 並new一個TaskManger的Instance 如果是null的 //此方法為工廠 static TaskManager* getInstance(){ if(taskManager == nullptr){ taskManager = new TaskManager(); } return TaskManager; } } LoadBalance
//LoadBalance 🌰 //用於計算服務器負載，所以必須使用單例 class LoadBalance{ public: static LoadBalance* getInstance(){ if(loadBalance == nullptr){ loadBalance = new LoadBalance(); } return LoadBalance; } private: static LoadBalance* loadBalance; LinkedList* serverList = nullptr; LoadBalance(); void addServer(std::string server){ serverList-&amp;amp;gt;add(server);//add a server } std::string …</content></entry><entry><title>[Leetcode] Top K Frequent Elements(Medium)</title><url>/leetcodes/leetcode347/</url><categories><category>leetcode</category></categories><tags><tag>map</tag><tag>priority queue</tag><tag>array</tag></tags><content type="html"><![CDATA[  LeetCode 347 - Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
example
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] How can we solve this problem? 這一題需要我們返回K個數量最多的element。所以，我們可以使用map記錄我們array中element的個數，然後在把他們以&lt;frequency,element&gt;存到priority queue/max queue，最後只要返回priority queue中的k個element即可。
Solution: class Solution { public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; res; unordered_map&lt;int,int&gt; map; priority_queue&lt;pair&lt;int,int&gt;&gt; q; for(auto i : nums) map[i]++; //counter numbers for(auto it : map) q.push({it.second,it.first}); //according to the second for priority while(k-- &gt; 0) { res.push_back(q.top().second); q.pop(); } return res; } };   ]]></content></entry><entry><title>[Leetcode] Kth Largest Element in a Stream(Easy)</title><url>/leetcodes/leetcode703/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>priority queue</tag></tags><content type="html"><![CDATA[  LeetCode 703 - Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. example:
Input [&#34;KthLargest&#34;, &#34;add&#34;, &#34;add&#34;, &#34;add&#34;, &#34;add&#34;, &#34;add&#34;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 How can we solve this problem? 首先，我們要知道這個問題在問什麼。很簡單，這個問題問的是array中k個大元素。舉例 [1,2,3,4,5 ] k=3，需要我們求出三個最大的element，所以會是[3,4,5]。因此。我們只需要關心最大的K的element即可，其他都可以拋棄掉。
Solution: class KthLargest { private: priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q; int k; public: KthLargest(int k, vector&lt;int&gt;&amp; nums) { for(auto e : nums) { q.push(e); if(q.size() &gt; k) q.pop(); } this-&gt;k = k; } int add(int val) { q.push(val); if(q.size() &gt; k) q.pop(); return q.top(); } };   ]]></content></entry><entry><title>長庚大學-畢業專題獎項</title><url>/achievement/my-first-reward/</url><categories><category>CGU</category><category>Reward</category></categories><tags/><content type="html"> Reward 這是我跟組員們一起討論、辛苦了多個日夜，能一起做寫程式，分享知識的感覺真的很棒&amp;gt;&amp;lt;。雖然不知道以後還沒有機會一起合作，但還是非常感謝他們願意陪我躲在實驗室裡面一整天(╥╯^╰╥)。希望他們能好好生活，好好學習！
My Teammates</content></entry><entry><title>[Note]Creational Abstract Factory</title><url>/post/creational-abstract-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Abstract Factory(抽象工廠)呢? 定義: 又稱為Kit模式。提供一個創建系列相關或者互相依賴的Interface，而無需指定其具體的class
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過定義不同組件的Abstraction類,並把Abstraction類組合在一起。通過繼承抽象工廠的方式，定義不同的工廠類，生成不同的Product。 由以下例子可見，有2組不同的UI分別是Summary以及Spring，他們都分包實現了Abstraction 類，然後在透過實現各自的工廠類，生成Summary以及Spring的Product //🌰UI //Button TextField ComboBox //Abstract Class UI class Button{ public: virtual void display() = 0; } class TextField{ public: virtual void display() = 0; } class ComboBox{ public: virtual void display() = 0; } //Abstract Class Factory //用於把不同類型的UI/主題Group 在一起 class UIFactory { public: virtual Button* createButton() = 0; virtual TextField* createTextField() = 0; virtual ComboBox* createComboBox() = 0; } //Spring class SpringButton : public Button{ public: void Draw(){ //Draw Spring style Button } } class SpringTextField : public TextField{ public: void Draw(){ //Draw Spring stype TextField } } class SpringComboBox : public ComboBox{ public: void Draw(){ //Draw Spring stype ComboBox } } //Summer class …</content></entry><entry><title>[Note]Simple RateLimiter Example Based on IP</title><url>/post/simple-ratelimiter-example-based-on-ip/</url><categories><category>golang</category><category>backend</category><category>note</category><category>system design</category></categories><tags><tag>gin</tag><tag>rate limiter</tag></tags><content type="html"><![CDATA[  基於Gin實作Rate Limiter 假設我們有2個APIs,而每個API都需要消耗1個Tokens
uri method desc /api/posts/{id} GET return a simple demo message /ping GET return pong 我們先設置一下rate limiter桶子的容量只能放下一個tokens,而tokens則會每秒生產5個。存取API時,若沒有Token可以用，就需要等待token下一次生產並放到桶子裡，才能繼續進行下去。
var ( Rate = rate.Every(time.Millisecond * 200) //1s x 10 token ReqLimiter = rate.NewLimiter(RateLimiterRate, 1) ) Post API Controller exapmle type PostCase struct { } func (p *PostUseCase) GetPost(ctx *gin.Context) { //get params id id := ctx.Param(&amp;#34;id&amp;#34;) //from the path //use a token if err := limiter.ReqLimiter.Wait(ctx); err != nil { ctx.JSON(http.StatusRequestTimeout, gin.H{}) return } //wait for a token is available or return ctx.JSON(http.StatusOK, gin.H{ &amp;#34;msg&amp;#34;: &amp;#34;succeed:&amp;#34; + id, }) } Ping API Controller exapmle type HealthCheck struct { } func (hc *HealthCheck) Pong(ctx *gin.Context) { limiter.ReqLimiter.Wait(ctx) ctx.JSON(http.StatusOK, gin.H{ &amp;#34;msg&amp;#34;: &amp;#34;Pong&amp;#34;, }) } 基於ClientIP 的Rate limiter 由於上面的的例子都是所有人 …  ]]></content></entry><entry><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><url>/post/token-bucket-intro/</url><categories><category>golang</category><category>backend</category><category>note</category><category>algorithm</category><category>system design</category></categories><tags><tag>golang package</tag><tag>rate limiter</tag></tags><content type="html"> Token Bucket(令牌桶算法) 什麼是Token Bucket 呢? 簡單來說就是運用Token Bucket的系統會以一個設定的速率往桶子(Bucket)裡面丟令牌(Token)。如果請求(Request)需要被處理時，就必需得Bucket裡的Token。當桶子裡面的沒有Token可以分配/獲取時，也就是說Bucket現在是空的(Token已經被其他令牌拿完了)，系統則會拒絕這個請求的服務。
根據算法(Algorithm)的定義:
A token is added to the bucket every 1/r seconds. 一個Token會以每1/r秒加入到Bucket裡面。 The bucket can hold at the most b tokens. If a token arrives when the bucket is full, it is discarded. Bucket可以保存最多b個tokens。如果在bucket以及滿了的情況下，有一個token被加入到bucket，這個token會被丟棄 例子: 假設一個n bytes的packet(封包)送達 假設目前最少有n個token在桶子裡面，這n個token就會被拿出來，然後packet就會被送到網絡上(剛好n bytes 封包有n個tokens) 假設目前桶子裡面可存取的tokens少於n個，就不會有tokens被拿出來(因為需要n個tokens 才能傳送n bytes的封包)，這個封包會被考慮為不符合的封包/不合規的封包 Go 實現/使用Token Bucket Go 的time/rate package 提供了Limiter的實作，而這個Limiter便是實作了Token Bucket的方式來達到限流的目的。
今天我們就來學習一下這麼使用go 提供Limiter來實作Rate Limiter
要如何新增一個Limiter呢? func NewLimiter(r Limit, b int) *Limiter
他有2個參數:
r: rate的type是Limit(一個float64的值)，表示著每秒會產生多少個Token,也就是每1/r秒生產1個token到bucket裡 b: Token Bucket 的桶子的Capacity(容量) //r 設置100表示每秒會產生100 …</content></entry><entry><title>[Note]Creational-Factory</title><url>/post/creational-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Factory(工廠)呢? 定義:建立一個接口,讓子類自己決定實現哪一個Factory,其重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
可透過子類繼承Factory的抽象類自主決定生產什麼樣的Product。 生產的Product在透過里氏替換原則(Lisko Subsititution princeple)替換成繼承與Logger的子類，即可換成的需要的Logger。 class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc... Logger* logger = new DatabaseLogger(); //init this logger etc... return logger } } //Client to use int main(){ Factory *factory = new FileLoggerFactory(); Logger *logger = factory-&amp;gt;createLogger(); //return the Product that it is initialized Logger-&amp;gt;wirteLog(); return; //如果想讓系統有更多靈活性和課擴展性，可以透過xml來進行配置，不需透過修過client的代碼 //只需更新xml中的設置，在代碼中新增新的Product 以及新增的Factory 並重新編譯便可 //除了默認的設置方法外，還想透過傳入String的方法來自定義設計，例如連接要DB，文件的路徑等等 //可以透過Override Abstruct class 的func來進行設置 /* class Factory{ public: virtual Logger* createLogger() = 0; virtual Logger* createLogger(string config) = 0; virtual Logger* createLogger(Object obj) = 0;//通過Obj裡面的成員進行設置等 } */ } 優點 Client無需知道Object的設置的細節，也無需知道實質Object的名稱，只需通過工廠即可 工廠(Factory)以及產品(Product)都是透過Polymorphism(多態)來實現，也是工廠模式的關鍵，工廠可以自主的決定要生產什麼產品，在內部進行設置產品(封裝在內部) 加入新的Product時無需修改Abstract class 以及 具體的工廠和產品的類，只要擴展新增即可，符合Open-Close principle 透過繼承抽象類使系統更容易擴展 缺點 新增產品時，要加入新的產品類以及工廠類，增加了系統的複雜度，而且需要從新編譯，增加了開銷 為了擴展性,加入了抽象類，Client都使用Abstract class 進行編程，增加了系統的抽象性和理解難度 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Creational-Simple Factory</title><url>/post/creational-simple-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"><![CDATA[  什麼是Simple Factory(簡單工廠)呢? 簡單而言就是: 由一個工廠來生產全部產品 定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過Factory 類的Static 方法調用方法，傳入參數生成相關的Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == &#34;A&#34;){ return new ProductA(); } else if(type == &#34;B&#34;){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct(&#34;A&#34;); //get ProductA instance Product* B = Factory::getProduct(&#34;B&#34;); //get ProductB instance } 優點 Client可以自行決定生產哪個Product Client免除直接建立Product的責任，只僅僅消費產品 Client無需關心具體的類名與相關設置參數 缺點 Factory 的職責太重。所有的Product 都由一個Object 生產，一旦不能正常工作，便會影響整個系統的運作 如有不同的Product會增加系統中的class的數目，增加了系統複雜度以及理解難度 擴展十分困難，添加需要修改Factory的邏輯。如果生存的Product較多時，可能會使其邏輯過於複雜，不利於系統的擴展與維護 違背原則 違背了Open-Close Principe 如果有新的Product 需要生成，就必修要修改Factory類 參考資料:
史上最全设计模式导学目录（完整版）   ]]></content></entry><entry><title>[Note]Design Pattern Princeple</title><url>/post/design-pattern-princeple/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>learning</tag><tag>note</tag></tags><content type="html"> 什麼是Design Pattern(設計模式)呢? 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，如何解決問題的一種方案
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。 設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
Design Pattern 有什麼原則呢? 原則(Princeple) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) Design Pattern 分成哪幾種呢? 主要分成3大類，一共23個
創建型模式(6個) 結構型模式(7個) 行為型模式(11個) 創建型模式(6個) 簡單工廠模式(Simple Factory Pattern) 工廠模式(Factory Pattern) 抽象工廠模式(Abstract Factory Pattern) 單例模式(Singleton …</content></entry><entry><title>[Note]What Is JWT(Json Web Token)-EN</title><url>/post/jwt-note/</url><categories><category>backend</category><category>development</category><category>web develpment</category><category>note</category><category>english</category></categories><tags><tag>web develpment</tag><tag>token</tag></tags><content type="html"><![CDATA[  What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:
Header Payload Signature JWT Header Header typically consists of two parts
type : what&rsquo;s the type of the token algorithm : what algorithm does this token use to sign/encrypt. such as SHA256,RAS or HMAC { &#34;typ&#34; : &#34;jwt&#34;, &#34;alg&#34; : &#34;HS256&#34; } This information will be encoded by base64Url algorithm in order to generate the JWT Header
JWT payload In payload is typically saving some users information and other useful information.
Be carefulthat payload must not include any secret information due to base64Url algorithm is easy to be decrypted.
JWT Payload standard claims
{ &#34;sub&#34; :&#34;&#34;,//subject &#34;aud&#34; :&#34;&#34;,//audience &#34;jti&#34; :&#34;&#34;,//jwt id &#34;iat&#34; :&#34;&#34;,//Issued at &#34;iss&#34; :&#34;&#34;,//Issuer - who is the publisher of the jwt &#34;nbf&#34; :&#34;&#34;,//Not Before - JWT is not available before the time jwt set. // other user information that developer set //for example: &#34;user_name&#34; : &#34;jackson_tmm&#34;, &#34;email&#34; : &#34;admin@admin.com&#34; } This information will be encoded by base64Url algorithm in order to generate the JWT Payload
Signature The Signature is used to authenticate whether information has been modified during transmission and authenticate the sender that sent this JWT.
To Generate JWT Token Following this function
HMACSHA256( base64UrlEncode(header) + &#34;.&#34; + base64UrlEncode(payload), your-256-bit-secret) And these three partes will be combined by a . as following format: xxx.yyy.zzz
//exmaple eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ How it work between Client and server sequenceDiagram Client->>Server:POST /authentication {username:xxx..} Note over Client,Server: User logs in alt is authenticated Server->>Client:HTTP Status:200 {"token":eyxxx.xx.x} Note over Server,Client: Loged in Succeed else Unauthorized Server->>Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Loged in Failed end Client->>Server: POST /user/profile {"Authorization":"Bear token"} Note over Server,Client: Get User Profile with token alt succeed Server-->Client: HTTP Status:200 {"profile":eyxxx.xx.x} Note over Server,Client: Succeed and response a profile else Unauthorized Server-->Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Unauthorized(token error) end   ]]></content></entry><entry><title>[CGU]Graduation Project</title><url>/project/final-project/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> OTT Movies recommender system-IOS Client Project have been changed/updated
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database Demo Video</content></entry><entry><title>About me 關於我</title><url>/about.html</url><categories/><tags/><content type="html"> Introduction 你好~ 歡迎來到我的網站!
我是Jackson.tmm, 是一個從香港來到台灣讀大學的四年級學生。目前就讀於長庚大學-資訊工程學系(Computer Science And Information Engineering)。目前已經畢業了。我目前主要是研究學習後端開發的技術。
Resume(EN) 2020年 - 基於IOS的微博UI Clone 2020年 -第一次學習IOS開發的Demo 2020年 - 基於IOS的Netfilx UI Clone 2020年 - 第一次嘗試自學建模的作品 - 雷神之錘 2020年 - 第二次嘗試自學建模的作品 - 美國隊長盾 2020年 - 送給自己20歲的生日禮物的一顆排球模型 2020年 - 香港霓虹燈 2020年 - 模擬水還是很好玩的(渲染了12小時 (◑‿◐) ) 2020年 - 燈籠魚(Lophiiformes)作品 2020年 - 第一次學遊戲開發的作品 2021年 - 第一次網絡課學習建模的作業 2021年 - 第一次網絡課學習建模的結課作品(還沒上貼圖&amp;gt;&amp;lt;,有空就上) 2022年 - 電影資源社群平台App 2023/2024年 - 通訊軟體App 2024年 - 日本71天自由行 Interest 跑步，看電影，一個人到處跑 遊戲設計，遊戲美術，3D建模 搞設計，寫程式 跟朋友分享、交流 特別喜歡宇宙/人類起源相關的奇怪知識 Current Plan 學更多有關後端開發，系統設計相關的技術 學好英文(看電影不要看字幕，能更外國人交流的程度) 考雅思 做好自己,不比較,但一起學習一起進步 Contact Me: Email @Jacksontmm in Telegram</content></entry></search>