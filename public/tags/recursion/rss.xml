<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recursion on Jackson.tmm</title><link>http://localhost:1414/tags/recursion/</link><description>Recent content in Recursion on Jackson.tmm</description><generator>Hugo 0.125.2</generator><language>zh-TW</language><lastBuildDate>Fri, 16 Sep 2022 20:42:00 +0800</lastBuildDate><atom:link href="http://localhost:1414/tags/recursion/rss.xml" rel="self" type="application/rss+xml"/><item><title>[Leetcode] Maximum Score from Performing Multiplication Operations(Medium)</title><link>http://localhost:1414/leetcodes/leetcode1770/</link><pubDate>Fri, 16 Sep 2022 20:42:00 +0800</pubDate><guid>http://localhost:1414/leetcodes/leetcode1770/</guid><description>LeetCode 1770 - Maximum Score from Performing Multiplication Operations You are given two integer arrays nums and multipliers of size n and m respectively, where n &amp;gt;= m. The arrays are 1-indexed. You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will: Choose one integer x from either the start or the end of the array nums. Add multipliers[i]</description></item><item><title>[Leetcode] Combination Sum III(Medium)</title><link>http://localhost:1414/leetcodes/leetcode216/</link><pubDate>Tue, 10 May 2022 11:41:43 +0800</pubDate><guid>http://localhost:1414/leetcodes/leetcode216/</guid><description>LeetCode 216 - Combination Sum III Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. example Input: k = 3,</description></item><item><title>[Leetcode] Letter Combinations of a Phone Number(Medium)</title><link>http://localhost:1414/leetcodes/leetcode17/</link><pubDate>Mon, 09 May 2022 21:50:34 +0800</pubDate><guid>http://localhost:1414/leetcodes/leetcode17/</guid><description>LeetCode 17 - Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. example Input: digits = &amp;#34;23&amp;#34; Output: [&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;] Input: digits = &amp;#34;&amp;#34; Output: []</description></item><item><title>[Leetcode] Flatten Nested List Iterator(Medium)</title><link>http://localhost:1414/leetcodes/leetcode341/</link><pubDate>Sun, 08 May 2022 06:30:23 +0800</pubDate><guid>http://localhost:1414/leetcodes/leetcode341/</guid><description>LeetCode 341 - Flatten Nested List Iterator You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: NestedIterator(List&amp;lt;NestedInteger&amp;gt; nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there</description></item><item><title>[Leetcode] Trim a Binary Search Tree(Medium)</title><link>http://localhost:1414/leetcodes/leetcode669/</link><pubDate>Fri, 15 Apr 2022 18:29:14 +0800</pubDate><guid>http://localhost:1414/leetcodes/leetcode669/</guid><description>LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&amp;rsquo;s descendant should remain a descendant). It can be proven that there</description></item><item><title>[Leetcode] Search in a Binary Search Tree(Easy)</title><link>http://localhost:1414/leetcodes/leetcode700/</link><pubDate>Thu, 14 Apr 2022 15:05:44 +0800</pubDate><guid>http://localhost:1414/leetcodes/leetcode700/</guid><description>LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node&amp;rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. example Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5</description></item></channel></rss>