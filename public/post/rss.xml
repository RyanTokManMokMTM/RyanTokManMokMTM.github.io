<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Jackson.tmm</title><link>http://localhost:1313/post/</link><description>Recent content in Posts on Jackson.tmm</description><generator>Hugo</generator><language>zh-TW</language><lastBuildDate>Mon, 02 Dec 2024 23:31:33 +0800</lastBuildDate><atom:link href="http://localhost:1313/post/rss.xml" rel="self" type="application/rss+xml"/><item><title>[筆記] 資料庫索引(index)</title><link>http://localhost:1313/post/note/database-index/</link><pubDate>Mon, 02 Dec 2024 23:31:33 +0800</pubDate><guid>http://localhost:1313/post/note/database-index/</guid><description>&lt;h2 id="前言">前言
&lt;a class="header-anchor" href="#%e5%89%8d%e8%a8%80">&lt;/a>
&lt;/h2>&lt;p>之前的文章中，我們有簡單探討過事務相關的課題，而在這篇文章就主要討論 Index 索引相關的課題！ 而索引也跟B+ tree 相關，如果不了解B+ tree的同學可以去參考之前討論平衡樹的文章。&lt;/p>
&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>不知道大家有沒有在學習或者在網上在找資料優惠資料庫查詢效率的時候大部分的答案都是說「&lt;strong>加索引&lt;/strong>」，在這篇文章中就會對「索引」進行簡單的探討。
在開始之前想先給讀者一些問題進行思考，並在閱讀本文過後再給出回答：&lt;/p>
&lt;ol>
&lt;li>什麼是索引？&lt;/li>
&lt;li>為什麼加了「索引」可以提高查詢效率？&lt;/li>
&lt;li>加索引是否就能提高效率，會造成其他問題嗎？&lt;/li>
&lt;/ol>
&lt;h2 id="索引index">索引(Index)
&lt;a class="header-anchor" href="#%e7%b4%a2%e5%bc%95index">&lt;/a>
&lt;/h2>&lt;h4 id="什麼是索引">什麼是索引
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%af%e7%b4%a2%e5%bc%95">&lt;/a>
&lt;/h4>&lt;p>相信大家都有看過書對吧？沒看過也沒有關係，這邊就簡單介紹一下索引的概念吧！&lt;br>
如果大家在要幾百頁的書本裡面找到某一個特定的資料，那我們是不是會選擇到書本目錄中尋找呢？而這一頁也就是所謂的「目錄/索引頁(Index)」，透過查閱索引頁就能很快的找到&lt;/p>
&lt;p>&lt;strong>書本目錄為例：&lt;/strong>&lt;br>
&lt;strong>Harry Potter And The Chamber Of Secrets 的目錄頁：&lt;/strong>&lt;br>
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/harry-potter-index.png" alt="book-index" />&lt;/p>
&lt;p>如果我們要看&lt;em>Ch.9&lt;/em>，透過查看目錄就可以知道它在書本的 page 148，直接跳到148頁就好了。&lt;/p>
&lt;p>在資料庫的層面上，也是一樣的情況，我們可以直接透過索引來快速的找到資料。那資料庫的索引到底長什麼樣子呢？&lt;br>
假設我們有以下情境：
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/data.png" alt="data" />&lt;/p>
&lt;p>現在從圖中我們可以看得出來，數據頁1因滿了，插入新數據後就會被分成兩頁了，這樣如果我們要查詢數據的時候要怎麼知道數據都放在了那一頁上呢？&lt;br>
這裡我們是不是就需要一個新的數據頁來保存那些數據在那一頁，而這個用來保存數據的頁就叫做&lt;strong>索引頁&lt;/strong>。
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/index-page.png" alt="index-page" />&lt;/p>
&lt;p>隨著數據的增加，索引頁也會增加，也就變成我們我們熟悉的「B+ Tree」，所以索引樹也就是B+ Tree。
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/B&amp;#43;index-tree.png" alt="B&amp;#43;index-page" />&lt;/p>
&lt;h4 id="資料庫索引的種類">資料庫索引的種類
&lt;a class="header-anchor" href="#%e8%b3%87%e6%96%99%e5%ba%ab%e7%b4%a2%e5%bc%95%e7%9a%84%e7%a8%ae%e9%a1%9e">&lt;/a>
&lt;/h4>&lt;ol>
&lt;li>Primary key index(主鍵索引/聚簇索引)&lt;/li>
&lt;li>Secondary Index (普通索引 / 二級索引)&lt;/li>
&lt;li>Composite Index (複合索引 / 聯合索引)&lt;/li>
&lt;/ol>
&lt;h5 id="primary-key-index主鍵索引聚簇索引">Primary key index(主鍵索引/聚簇索引)
&lt;a class="header-anchor" href="#primary-key-index%e4%b8%bb%e9%8d%b5%e7%b4%a2%e5%bc%95%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95">&lt;/a>
&lt;/h5>&lt;p>主鍵索引是一種唯一的索引，由InnnoDB自己生成的index。
主鍵索引有以下特點：&lt;/p>
&lt;ol>
&lt;li>主鍵索引樹中的非葉子節點用單鏈表連接。&lt;/li>
&lt;li>主鍵索引樹中的葉子節點中包含了完整的資料&lt;/li>
&lt;/ol>
&lt;h5 id="secondary-index-普通索引--二級索引">Secondary Index (普通索引 / 二級索引)
&lt;a class="header-anchor" href="#secondary-index-%e6%99%ae%e9%80%9a%e7%b4%a2%e5%bc%95--%e4%ba%8c%e7%b4%9a%e7%b4%a2%e5%bc%95">&lt;/a>
&lt;/h5>&lt;p>主鍵索引只有在查詢條件包含主鍵時，才會生效。如果要查詢的條件不包含主鍵，那麼就不會生效。怎麼辦呢？ 若要加快其他條件的查詢效率，我們可以為條件添加一個索引。&lt;strong>添加索引後，會為該條件建立一顆新的索引頁&lt;/strong>。 也就是主建索引頁跟二級索引頁是分開的。&lt;br>
為&lt;code>age&lt;/code>這個欄位了一個index，就會建立一個新的索引頁。而這個二級索引頁跟主鍵索引頁的區別是：&lt;/p>
&lt;ol>
&lt;li>二級索引頁除了包含主鍵ID外，還包含了age這個欄位的值。&lt;/li>
&lt;li>二級索引頁中的葉子節點不包含全部的數據。&lt;/li>
&lt;li>二級索引頁排序根據age欄位的值。&lt;/li>
&lt;/ol>
&lt;h5 id="composite-index-複合索引--聯合索引">Composite Index (複合索引 / 聯合索引)
&lt;a class="header-anchor" href="#composite-index-%e8%a4%87%e5%90%88%e7%b4%a2%e5%bc%95--%e8%81%af%e5%90%88%e7%b4%a2%e5%bc%95">&lt;/a>
&lt;/h5>&lt;p>複合索引（Composite Index）是指在一個資料表中同時使用多個欄位來建立索引的情況。這邊跟普通索引的差不多的，只是建立的索引會包含多個不同的欄位。
例如為&lt;code>age&lt;/code>和&lt;code>name&lt;/code>這兩個欄位建立一個複合索引。不過這裡值得注意的是,&lt;strong>建立(&lt;code>age&lt;/code>,&lt;code>namge&lt;/code>)以及建立(&lt;code>name&lt;/code>,&lt;code>age&lt;/code>)是不一樣的，他們會建立不同索引樹！&lt;/strong>
這邊先不說這兩個索引樹的差別，先賣個關子xD。
而這個複合索引頁跟二級索引的區別是：&lt;/p>
&lt;ol>
&lt;li>複合索引除了主鍵ID外，還包含了多個欄位的數據。&lt;/li>
&lt;li>其他的二級索引無疑&lt;/li>
&lt;/ol>
&lt;p>在討論其他課題前，在這邊有一條問題要大家思考：&lt;br>
Q: &lt;strong>除了主鍵索引樹外，主建ID在這邊的作用會是什麼呢？ 這裡交給讀者思考一下，哈哈哈。&lt;/strong>&lt;/p>
&lt;h4 id="innodb索引規則">InnoDB索引規則
&lt;a class="header-anchor" href="#innodb%e7%b4%a2%e5%bc%95%e8%a6%8f%e5%89%87">&lt;/a>
&lt;/h4>&lt;p>在討論添加索引的規則之前，我們先來看看一句查詢是如何透過索引來找到資料的。
假設我們現在有如下這個資料庫表：
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/example-index-user.png" alt="user-example" />
&lt;em>這邊只是簡單的示範一下，圖中只包含前幾筆資料用作演示&lt;/em>&lt;/p>
&lt;h5 id="查詢條件包含主鍵">查詢條件包含主鍵
&lt;a class="header-anchor" href="#%e6%9f%a5%e8%a9%a2%e6%a2%9d%e4%bb%b6%e5%8c%85%e5%90%ab%e4%b8%bb%e9%8d%b5">&lt;/a>
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因為我們的User表格包含了主鍵索引樹，對主鍵索引樹進行Binary search就很快的找到了，id = 12的資料。
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/pk-index-search.png" alt="pk-index-search" />
&lt;em>查詢路徑為橘色路徑&lt;/em>
最後得出結果為:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">12&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Jonna&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;age&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">18&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>從上面的圖中可以看到,查詢條件包含了主鍵的情況下，透過索引就很快的找到資料。&lt;/p>
&lt;h5 id="查詢條件不包含主鍵">查詢條件不包含主鍵
&lt;a class="header-anchor" href="#%e6%9f%a5%e8%a9%a2%e6%a2%9d%e4%bb%b6%e4%b8%8d%e5%8c%85%e5%90%ab%e4%b8%bb%e9%8d%b5">&lt;/a>
&lt;/h5>&lt;p>現在為User表格添加二級以及聯合索引,索引分別為一下：&lt;/p>
&lt;p>二級索引： &lt;code>age&lt;/code>, 並生成一些索引樹(index), 這邊我們簡稱為「Age 二級索引樹」。
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/2nd-index-tree.png" alt="age-2nd-index" />&lt;/p>
&lt;p>聯合索引： （&lt;code>age&lt;/code>,&lt;code>name&lt;/code>） 並生成一些索引樹(index), 這邊我們簡稱為「Age&amp;amp;Name 聯合索引樹」。&lt;br>
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/composite-index-tree.png" alt="composite-index" />&lt;/p>
&lt;p>從上面圖可以看得出來 &lt;em>「二級索引」&lt;/em> 以及 &lt;em>「聯合索引」&lt;/em> 的主要區別是:&lt;/p>
&lt;ul>
&lt;li>聯合索引會包含1個或者多個非唯一欄位的數據&lt;/li>
&lt;li>二級索引會包含1個唯一欄位的數據&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>現在來模擬包含「二級索引」以及「聯合索引」的查詢情境：&lt;/p>
&lt;ol>
&lt;li>查詢「二級索引」的查詢語句&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>,&lt;span style="color:#f92672">`&lt;/span>age&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> age &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>這裡的查詢語句包含了 &lt;code>where age = 18&lt;/code> 這個查詢條件，而且我們也為&lt;code>age&lt;/code>這個欄位建立了索引，所以直接透過「Age 二級索引樹」查詢資料，以下為查詢路徑:
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/2nd-index-search.png" alt="age-2nd-index-search" />&lt;/p>
&lt;p>從圖中可以清晰看到，透過Binary Search 很快就能找到&lt;code>age = 18&lt;/code>的資料。而在葉子節點中，也包含了查詢的資料 (select &lt;code>id&lt;/code>,&lt;code>age&lt;/code>)，因此直接返回就好了。
最終結果為：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span> : &lt;span style="color:#ae81ff">54&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;age&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">18&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>查詢「聯合索引」的查詢語句&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>age&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>name&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> age &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">89&lt;/span> &lt;span style="color:#66d9ef">and&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Ken&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>這裡的查詢語句包含了 &lt;code>where age = 89 and name = &amp;quot;Ken&amp;quot;&lt;/code> 這個查詢條件，而且我們也為&lt;code>age&lt;/code>和&lt;code>name&lt;/code>欄位建立了聯合索引，所以直接透過「Age&amp;amp;Name 聯合索引樹」查詢資料，以下為查詢路徑:
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/composite-index-search.png" alt="composite-index-search" />
從圖中可以清晰看到，透過Binary Search 很快就能找到&lt;code>age = 89&lt;/code>和&lt;code>name = &amp;quot;Ken&amp;quot;&lt;/code>的資料。而在葉子節點中，也包含了查詢的資料 (select &lt;code>id&lt;/code>,&lt;code>age&lt;/code>,&lt;code>name&lt;/code>)，因此直接返回就好了。
最終結果為：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span> : &lt;span style="color:#ae81ff">44&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;age&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">89&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Ken&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span> : &lt;span style="color:#ae81ff">77&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;age&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">89&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Ken&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有人可能會問：&lt;strong>「上面兩個查詢語句都包含了查詢『索引樹的數據』，但如果要獲取其他數據怎麼辦？」&lt;/strong>&lt;br>
還記得上面有問過讀者一個問題嗎？&lt;strong>「ID在除了主建索引樹外的索引中的作用會是什麼呢？」&lt;/strong>。這裡就可以回答以上的這個問題了，哈哈哈！&lt;br>
我們有了這個主鍵ID，是不是就拿著這個ID回到主鍵索引樹就可以獲取完整的數據了(主鍵索引樹葉子包含了完整的數據)! 這個透過其他索引樹拿取ID再回到主鍵索引樹獲取數據的方式就是 &lt;strong>「回表 (Back to the table)」&lt;/strong>。&lt;/p>
&lt;p>但是除了回表外，這裡的ID還有另外的作用。就是當數據都一樣的情況下，怎麼排序？因為主鍵是唯一的，是不是就可以透過ID來排序了！&lt;br>
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/duplicate-data-sorting-by-id.png" alt="duplicated-data-sorting" />&lt;/p>
&lt;h4 id="運用索引">運用索引
&lt;a class="header-anchor" href="#%e9%81%8b%e7%94%a8%e7%b4%a2%e5%bc%95">&lt;/a>
&lt;/h4>&lt;p>從上面的介紹過後，我們都對「索引是什麼」以及「索引如何加快查詢」有個基本的理解，但是在運用上，我們要如何運用索引提高查詢效率呢？接下來給大家介紹一下。&lt;br>
其實要進一步提高索引的效率，就是減少「回表」這個動作。&lt;/p>
&lt;p>為什麼要減少回表或者避免回表呢？&lt;br>
假設現在我們獲取到了查詢數據的ID，需要透過查詢主鍵索引樹來獲取完整的數據，主鍵索引樹數據如果沒有在記憶體中，是不是就是需要從硬碟從讀取出來，然後再將這些數據回到記憶體中，這樣的話就是一個回表的動作，這樣的話對查詢效率來說是不好的。 所以能避免IO就避免IO的操作！&lt;/p>
&lt;p>以下介紹的方法都是減少回表的方法，這些方法都是在查詢的時候透過索引來獲取數據的。&lt;/p>
&lt;h5 id="索引覆蓋index-cover">索引覆蓋(Index Cover)
&lt;a class="header-anchor" href="#%e7%b4%a2%e5%bc%95%e8%a6%86%e8%93%8bindex-cover">&lt;/a>
&lt;/h5>&lt;p>其實上面的例子就有出現過索引覆蓋的方法，簡單來說就是查詢的數據在索引樹中已經包含了，也就沒有必要再透過回表的方式來獲取數據了。&lt;br>
例如上述的&lt;code>select age from user where age = 18&lt;/code> 這個查詢語句中，查詢的數據在二級索引樹中已經包含了，所以就不用再透過回表的方式來獲取數據了，直接返回就好了。&lt;/p>
&lt;h5 id="索引下推index-pushdown">索引下推(Index Pushdown)
&lt;a class="header-anchor" href="#%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8index-pushdown">&lt;/a>
&lt;/h5>&lt;h4 id="索引失效">索引失效
&lt;a class="header-anchor" href="#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88">&lt;/a>
&lt;/h4>&lt;p>有些情況下索引會失效，譬如說使用了一些函數、比較運算子等等。但這邊就先不討論這些情況，就討論一下最左匹配原則。&lt;/p>
&lt;h6 id="最左匹配原則leftmost-match">最左匹配原則(Leftmost Match)
&lt;a class="header-anchor" href="#%e6%9c%80%e5%b7%a6%e5%8c%b9%e9%85%8d%e5%8e%9f%e5%89%87leftmost-match">&lt;/a>
&lt;/h6>&lt;p>什麼是最左匹配原則呢？我們建立聯合索引的時候，會根據從左至右的順序來建立索引樹，例如(A,B,C)這個索引樹的規則就是這樣的:
如果數據A欄位的數據相同，就會根據B的數據來進行比較，如果B欄位的數據也相同，就會根據C欄位的數據來進行比較。最後葉子節點的排序就是根據這個索引(A,B,C)。&lt;/p>
&lt;p>&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/sql-index/leftmost-match.png" alt="leftmost-match" />
從圖中先根據&lt;code>age&lt;/code>欄位進行了排序，同樣為&lt;code>age = 1&lt;/code>的，則根據&lt;code>name&lt;/code>繼續排序，最後再根據&lt;code>code&lt;/code>進行排序，若都一樣則會用ID作為最後排序。&lt;br>
若符合最左匹配原則的話，就可以透過這顆索引樹來獲取數據，而不需要全表掃描。什麼情況是符合最左匹配原則呢？很簡單，只要查詢順序根據建立索引時候的順序來進行查詢就好了。&lt;/p>
&lt;p>我們的索引是: (&lt;code>age&lt;/code>,&lt;code>name&lt;/code>,&lt;code>code&lt;/code>),以下情況都可以走這個索引&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>age&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> age &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因為&lt;code>age&lt;/code>是在最左邊，所以符合最左匹配原則。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>age&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> age &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span> &lt;span style="color:#66d9ef">and&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Jonna&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>這裡也可以的，因為(&lt;code>age&lt;/code>,&lt;code>name&lt;/code>) 都符合了這個規則，所以可以走這個索引。&lt;/p>
&lt;p>但如果是這種情況就會失效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>age&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">`&lt;/span>Andy&lt;span style="color:#f92672">`&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因為我們的索引是是先更具&lt;code>age&lt;/code>來進行排序的，如果要先找&lt;code>name&lt;/code>這筆數據的話，而&lt;code>name&lt;/code>沒有&lt;code>age&lt;/code>過濾的情況下尋找，就跟全表掃描一樣的效果。因為只看&lt;code>name&lt;/code>的數據在這個索引樹中是沒有排序可言的，可能&lt;code>Andy&lt;/code>在最前面，另外一個&lt;code>Andy&lt;/code>在最後面，都不知道哪個在前面，所以就是全表掃描的效果。&lt;/p>
&lt;p>所以一句話概況就是最左的一樣要有,才能走這顆索引樹。&lt;/p>
&lt;h2 id="總結">總結
&lt;a class="header-anchor" href="#%e7%b8%bd%e7%b5%90">&lt;/a>
&lt;/h2>&lt;h2 id="參考資料">參考資料
&lt;a class="header-anchor" href="#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99">&lt;/a>
&lt;/h2></description></item><item><title>[筆記] 淺談資料庫事務(Transcation)</title><link>http://localhost:1313/post/note/database-transaction/</link><pubDate>Sat, 23 Nov 2024 22:11:45 +0800</pubDate><guid>http://localhost:1313/post/note/database-transaction/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>這篇文章主要是想要討論一下資料庫筆一個重要的概念&lt;strong>事務(Transcation)&lt;/strong>。接下來的文章主要會分成一下幾個部分繼續討論：&lt;/p>
&lt;ol>
&lt;li>什麼是資料庫的事務(Transcation)&lt;/li>
&lt;li>事務(Transcation)的4大特性為何&lt;/li>
&lt;li>一致性問題和解決方法&lt;/li>
&lt;li>MVCC和鎖的簡單介紹&lt;/li>
&lt;/ol>
&lt;h2 id="什麼是事務transcation">什麼是事務(Transcation)
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%af%e4%ba%8b%e5%8b%99transcation">&lt;/a>
&lt;/h2>&lt;p>在資料庫系統中，我們都會對數據進行讀寫操作，但是如果我們要對數據做一系列的操作(2個或以上的操作)，正在被操作的數據我們不希望能被其他人修改從而影響了結果，而且即便途中操作失敗，也希望他能回到原本的狀態。而資料庫為我們提供一個這樣的方法使得數據的操作要麼是&lt;strong>全部都成功，要麼全部都是失敗&lt;/strong>，這就是事務(Transcation)，也可以稱之為「交易」。&lt;/p></description></item><item><title>2024年軟體工程師(Software engineer)面試總結</title><link>http://localhost:1313/post/share/2024-swe-interview-summary/</link><pubDate>Sun, 10 Nov 2024 15:29:39 +0800</pubDate><guid>http://localhost:1313/post/share/2024-swe-interview-summary/</guid><description>&lt;h2 id="簡介-intro">簡介 Intro
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b-intro">&lt;/a>
&lt;/h2>&lt;p>在過去的幾個月裡一直在找新的工作機會，從2024/8/27起開始在各大招聘平台投遞履歷以及約面談。這篇文章主要是想分享這段時間面試經歷以及復盤面試！&lt;/p></description></item><item><title>[筆記] 平衡樹 Balance Tree</title><link>http://localhost:1313/post/note/balance-tree/</link><pubDate>Thu, 31 Oct 2024 15:28:20 +0800</pubDate><guid>http://localhost:1313/post/note/balance-tree/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>在講述Balance Tree之前，我們先來看一種情況。現在我們根據數據來建立一棵Binary Search Tree，譬如說以下的數據 : [4,5,6,7,8,9,10], 我們就會建立出以下這顆 Binary Search Tree:&lt;br>
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/helper/balance-tree/unblanceTree.png" alt="unbalance-tree" />&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP(完結) - 總結</title><link>http://localhost:1313/post/project/chat-app-final-summary/</link><pubDate>Sun, 21 Apr 2024 23:12:11 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-final-summary/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>Hi, 已經有一段時間沒有更新了，因為最近在研究多人串流的問題。這篇文章主要是分享我做了些什麼以及對這個project做個總結，這裡的意思就是這個project終於完成了！！花了我近1年的時間呢。&lt;br>
雖然這個project已完成，但是依然還有些問題，如果我們之後還有這個能力在修復～ 這些問題使得串流沒有這麼的穩定，但還是可以玩的呢！&lt;br>
在進入今天主題之前，如果你不記得或不知道這個project關於什麼的話，可以回去閱讀這幾篇文章：&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-story-alignment-updated/" title="ChatApp(Ⅶ)" >
 ChatApp(Ⅶ)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-story-multiple-img-updated/" title="ChatApp(Ⅷ)" >
 ChatApp(Ⅷ)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-sticker-shop-updated/" title="ChatApp(IX)" >
 ChatApp(IX)
 
&lt;/a>&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 貼圖更新(III)</title><link>http://localhost:1313/post/project/chat-app-sticker-shop-updated/</link><pubDate>Sat, 11 Nov 2023 11:08:40 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-sticker-shop-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>如果您想了解該項目的內容，請閱讀以下文章&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-story-alignment-updated/" title="ChatApp(Ⅶ)" >
 ChatApp(Ⅶ)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-story-multiple-img-updated/" title="ChatApp(Ⅷ)" >
 ChatApp(Ⅷ)
 
&lt;/a>&lt;/p>
&lt;h2 id="demo">Demo
&lt;a class="header-anchor" href="#demo">&lt;/a>
&lt;/h2>&lt;p>&lt;video src="http://localhost:1313/videos/chat-app/sticker-shop.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;h2 id="簡介-1">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b-1">&lt;/a>
&lt;/h2>&lt;p>正如我在
&lt;a href="http://localhost:1313/post/chat-app-sticker-updated/" title="這篇文章" >
 這篇文章
 
&lt;/a>中提到的，我添加了一個關於貼紙的新功能，它可以在聊天中使用提供的貼圖資源。但這還不夠，對用戶來說也不靈活。因此，我開發了更多關於貼紙功能的內容。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 限時動態更新(III)</title><link>http://localhost:1313/post/project/chat-app-story-view-updated/</link><pubDate>Thu, 09 Nov 2023 20:23:44 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-story-view-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>如果您想了解該項目的內容，請閱讀以下文章。

&lt;a href="http://localhost:1313/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-story-alignment-updated/" title="ChatApp(Ⅶ)" >
 ChatApp(Ⅶ)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-story-multiple-img-updated/" title="ChatApp(Ⅷ)" >
 ChatApp(Ⅷ)
 
&lt;/a>&lt;/p>
&lt;h2 id="demo">Demo
&lt;a class="header-anchor" href="#demo">&lt;/a>
&lt;/h2>&lt;p>&lt;video src="http://localhost:1313/videos/chat-app/instance-story-view.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;h2 id="描述">描述
&lt;a class="header-anchor" href="#%e6%8f%8f%e8%bf%b0">&lt;/a>
&lt;/h2>&lt;p>在先前的版本中，用戶只能查看好友的故事並回覆該限時動態。它除了回覆故事之外不能和朋友有任何互動，所以在這個版本中，我打算為它添加更多的互動功能。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 限時動態更新(II)</title><link>http://localhost:1313/post/project/chat-app-story-multiple-img-updated/</link><pubDate>Sun, 10 Sep 2023 12:49:44 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-story-multiple-img-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>如果您想了解該項目的內容，請閱讀以下文章。

&lt;a href="http://localhost:1313/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;/p>
&lt;p>這是關於限時動態功能的demo，類似於instagram（我的UI參考來自instagram xD）。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 限時動態更新(I)</title><link>http://localhost:1313/post/project/chat-app-story-alignment-updated/</link><pubDate>Tue, 05 Sep 2023 20:19:33 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-story-alignment-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>如果您想了解該項目的內容，請閱讀以下文章。&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;/p>
&lt;h2 id="demo">Demo
&lt;a class="header-anchor" href="#demo">&lt;/a>
&lt;/h2>&lt;p>&lt;video src="http://localhost:1313/videos/chat-app/instance-story-alignment.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;h2 id="todo">TODO
&lt;a class="header-anchor" href="#todo">&lt;/a>
&lt;/h2>&lt;p>在先前的版本中，它確實允許用戶將多個&lt;code>文本&lt;/code>添加到他們的&lt;code>限時動態&lt;/code>中。但如果不使用眼睛就很難對齊所有文字項目。因此，在這個版本中，我決定添加一個對齊工具來幫助他們，這類似於「Instagram」對齊工具。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 貼圖更新(I)</title><link>http://localhost:1313/post/project/chat-app-sticker-updated/</link><pubDate>Wed, 24 May 2023 21:32:47 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-sticker-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>關於這個專案我就不多說了，如果你對這個專案有興趣的話，請看我之前的貼文。在之前的文章中，我已經詳細介紹了這個專案。

&lt;a href="http://localhost:1313/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:1313/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;/p>
&lt;p>&lt;video src="http://localhost:1313/videos/chat-app/sticker-demo.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;p>在demo影片中，您可以看到貼圖功能與網路上任何其他即時通訊應用程式類似。用戶能夠存取我們提供的所有可用貼圖並將其發送給其他用戶或群組。但問題是我們如何提供使用者貼圖資源，貼圖從哪裡來呢？&lt;br>
為了解決第一個問題，我們可以透過在客戶端或使用者能夠存取它之前將所有必要的圖像上傳到伺服器來建立貼圖資源。每個建立的貼圖資源都會被分配一個唯一的ID作為其貼圖ID。與相同貼圖ID相關的所有資源都將以標準化格式重新命名，以便於存取。 &lt;code>stickerID_index.format&lt;/code>。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - RTC小更新</title><link>http://localhost:1313/post/project/chat-app-voice-chat/</link><pubDate>Sat, 13 May 2023 23:58:58 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-voice-chat/</guid><description>&lt;h4 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h4>&lt;p>我在
&lt;a href="http://localhost:1313/post/chat-app-init" title="[開發者日記] 聊天通訊APP(一)" >
 [開發者日記] 聊天通訊APP(一)
 
&lt;/a>中有提及過這app會有&lt;/p>
&lt;ul>
&lt;li>語音通訊&lt;/li>
&lt;li>視頻通訊&lt;/li>
&lt;/ul>
&lt;p>這次他們真的來了！！廢話少說先看視頻&lt;br>
&lt;video src="http://localhost:1313/videos/chat-app/voice-chat.mp4" controls="controls" width="500" height="300">&lt;/video>&lt;/p>
&lt;h4 id="說明">說明
&lt;a class="header-anchor" href="#%e8%aa%aa%e6%98%8e">&lt;/a>
&lt;/h4>&lt;p>雖然現在只有展示了語音通訊(Voice-chat),但是他們的工作原理其實是差不多的，就差在有沒有傳送視頻數據而已。老實說，這個功能其實言研究了2個月都不知道要從何入手，而github上的simple-demo又是UIKit的版本，所以就一直拖，一直研究。知道最近就想試試也無妨，最多也就不成功，萬一它成功了呢！於是我便開始寫，寫了1-2天，發現失敗了，哈哈哈。然後debug了一下，發現好像是沒有連接上的問題，於是又花了一整天來測試是否有成功連接，當成功連接上且文字數據傳送成功的那一刻，那個激動的心啊❤️！！！然後打開視訊，還真的成功了！！！！好開心！&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP(四) - 最終章</title><link>http://localhost:1313/post/project/chat-app-final/</link><pubDate>Mon, 01 May 2023 19:25:38 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-final/</guid><description>&lt;h3 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h3>&lt;p>在之前
&lt;a href="http://localhost:1313/post/chat-app-init" title="序章" >
 序章
 
&lt;/a>中，雖然已經大概介紹過這個app在幹嘛。但是因為這次是&lt;strong>最終章&lt;/strong>的成品展示(或許有些部分沒實現😂)，所以就允許我囉嗦得再說一次吧！&lt;/p>
&lt;p>這個app主要是focus在Websocket，也就是實時通訊上。雖然但是HTTP的部分還是不能少的🤣，哈哈哈。所以這個App的Server-side包含了HTTP和Websocket 2個部分。HTTP的部分主要是用作CURD,而Websocket的部分則是用於個人通訊和群組通訊。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP(三) - 聊天小更新</title><link>http://localhost:1313/post/project/chat-app-update/</link><pubDate>Sat, 29 Apr 2023 20:17:18 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-update/</guid><description>&lt;p>廢話少說直接上影片&lt;/p>
&lt;p>&lt;video src="http://localhost:1313/videos/chat-app/message-update1.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;p>對上一次的
&lt;a href="http://localhost:1313/post/chat-app-demo/" title="demo" >
 demo
 
&lt;/a>中，雖然也包含了個人聊天和群組聊天的部分，但是只支援普通文本和圖片的傳送，而這次修復了文件發送，音頻發送已經視頻發送的部分。而音頻可以直接聆聽接收到的音頻，而視頻則可以直接觀看。&lt;br>
除此之外還添加了系統資訊，例如：群組的建立，群組加入，群組退出並通知群組人員。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP(二) - Demo</title><link>http://localhost:1313/post/project/chat-app-demo/</link><pubDate>Mon, 24 Apr 2023 12:24:38 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-demo/</guid><description>&lt;p>這篇文章主要是展示一下整個App的Demo，廢話不多說，先上視頻:&lt;br>
&lt;video src="http://localhost:1313/videos/chat-app/full-demo-1.mp4" controls="controls" width="500" height="300">&lt;/video>&lt;/p>
&lt;h3 id="demo說明">Demo說明
&lt;a class="header-anchor" href="#demo%e8%aa%aa%e6%98%8e">&lt;/a>
&lt;/h3>&lt;p>這個App的詳細介紹在
&lt;a href="http://localhost:1313/post/chat-app-init" title="[開發者日記] 聊天通訊APP(一)" >
 [開發者日記] 聊天通訊APP(一)
 
&lt;/a>中已經有基本的介紹，這裡就不作過多的介紹了。&lt;br>
這裡主要是說明一下以上Demo中所展示的內容：&lt;/p></description></item><item><title>[開發日記] 聊天通訊APP(一) - 序章</title><link>http://localhost:1313/post/project/chat-app-init/</link><pubDate>Wed, 19 Apr 2023 17:08:14 +0800</pubDate><guid>http://localhost:1313/post/project/chat-app-init/</guid><description>&lt;p>因為之前的&lt;code>OTT電影社群APP&lt;/code>中有包含通訊的功能，但是那個App所實現的功能就只是簡單的存文字聊天而已，而那個app主要的focus點並不在通訊上，所以只有簡簡單單的實作了通訊，沒有到完整的通訊，例如：發送文字，發送圖片，發送文件等等的通訊功能。所以這次的side project所實作的app則主要focus在&lt;strong>通訊&lt;/strong>這個點上。&lt;/p></description></item><item><title>[筆記] Linked List 資料結構</title><link>http://localhost:1313/post/note/note-linkedlist/</link><pubDate>Fri, 10 Mar 2023 14:42:22 +0800</pubDate><guid>http://localhost:1313/post/note/note-linkedlist/</guid><description>&lt;p>Linked List是一個很常用的資料結構，&lt;/p>
&lt;h2 id="設計linked-list">設計Linked List
&lt;a class="header-anchor" href="#%e8%a8%ad%e8%a8%88linked-list">&lt;/a>
&lt;/h2></description></item><item><title>[筆記] Binary Search 演算法</title><link>http://localhost:1313/post/note/note-binarysearch/</link><pubDate>Thu, 09 Mar 2023 13:48:46 +0800</pubDate><guid>http://localhost:1313/post/note/note-binarysearch/</guid><description>&lt;p>Binary Search 演算法是用於在一個有序array中搜尋一個值的演算法 - TC:O(log n)。相較於Linear Search(線性搜尋) - TC:O(n),其效率大大提高。&lt;/p></description></item><item><title>[筆記] KMP - Knuth-Morris-Pratt 演算法</title><link>http://localhost:1313/post/note/note-kmp/</link><pubDate>Mon, 06 Mar 2023 12:32:40 +0800</pubDate><guid>http://localhost:1313/post/note/note-kmp/</guid><description>&lt;p>KMP(Knuth-Morris-Pratt) 算法是一個用於字符串匹配的一個算法，但確實有點抽象和複雜，因此打算寫一篇筆記來紀錄一下這個算法！&lt;br>
給定一個&lt;code>text&lt;/code>以及&lt;code>pattern&lt;/code>字符串，透過KMP 算法可以在&lt;code>text&lt;/code>中是否存在&lt;code>pattern&lt;/code>這個字符串。&lt;/p></description></item><item><title>2022年LeetCode年度總結(Summary)</title><link>http://localhost:1313/post/coding/lc-sumarry-of-2022/</link><pubDate>Sun, 01 Jan 2023 12:42:37 +0800</pubDate><guid>http://localhost:1313/post/coding/lc-sumarry-of-2022/</guid><description>&lt;h1 id="leetcode-總結">Leetcode 總結
&lt;a class="header-anchor" href="#leetcode-%e7%b8%bd%e7%b5%90">&lt;/a>
&lt;/h1>&lt;p>&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/lc-2022/lc-2022.png" alt="lc-2022" />&lt;/p>
&lt;p>雖然在2021年暑假的這段時間有刷過一整子大概有50道題左右，但是2021年9月到12月在忙畢業專題因此就停止了。直到我12月份去找投實習&lt;code>MataApp 的全棧實習生&lt;/code>時，公司給我發來了一份&lt;code>OA&lt;/code>或叫&lt;code>面試題&lt;/code>並要求在2小時內完成。當時就很激動的便開始寫了(實習問的都有多難),結果都的是算法題(當時一臉懵逼)。最後我花了將近5個小時的時間才完成(超時),收到了深深的打擊(收到了感謝信)，也下定了決心2022年好好認真刷題。&lt;/p></description></item><item><title>透過Kops工具在AWS中部署K8S集群</title><link>http://localhost:1313/post/coding/kuberneters-on-aws/</link><pubDate>Fri, 23 Dec 2022 14:39:46 +0800</pubDate><guid>http://localhost:1313/post/coding/kuberneters-on-aws/</guid><description>&lt;h2 id="這篇文章主要是講述如何在aws雲服務中部署kubernetes集群">這篇文章主要是講述如何在AWS雲服務中部署Kubernetes集群
&lt;a class="header-anchor" href="#%e9%80%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%bb%e8%a6%81%e6%98%af%e8%ac%9b%e8%bf%b0%e5%a6%82%e4%bd%95%e5%9c%a8aws%e9%9b%b2%e6%9c%8d%e5%8b%99%e4%b8%ad%e9%83%a8%e7%bd%b2kubernetes%e9%9b%86%e7%be%a4">&lt;/a>
&lt;/h2>&lt;p>首先，我們需要準備使用一下工具進行設置&lt;/p>
&lt;ul>
&lt;li>KOps - 一個能讓我們輕鬆無痛部署Kubernetes到任何雲服務的工具，可以想象為集群的kubectl&lt;/li>
&lt;li>AWS IAM - 申請一個能讓Kops存取權限的賬號&lt;/li>
&lt;li>AWS S3 Bucket - 用來作為存取Kubernets資料的資料庫&lt;/li>
&lt;li>AWS Route53 - 用於使用自定義Domain Name 並連接到Master Node中&lt;/li>
&lt;li>GoDady - 作為DNS 服務供應商&lt;/li>
&lt;/ul>
&lt;h4 id="前置工作">前置工作
&lt;a class="header-anchor" href="#%e5%89%8d%e7%bd%ae%e5%b7%a5%e4%bd%9c">&lt;/a>
&lt;/h4>&lt;h5 id="在電腦中安裝kops工具用於幫助我們部署集群">在電腦中安裝&lt;code>KOps&lt;/code>工具用於幫助我們部署集群
&lt;a class="header-anchor" href="#%e5%9c%a8%e9%9b%bb%e8%85%a6%e4%b8%ad%e5%ae%89%e8%a3%9dkops%e5%b7%a5%e5%85%b7%e7%94%a8%e6%96%bc%e5%b9%ab%e5%8a%a9%e6%88%91%e5%80%91%e9%83%a8%e7%bd%b2%e9%9b%86%e7%be%a4">&lt;/a>
&lt;/h5>&lt;blockquote>
&lt;p>想要了解更多關於KOps的讀者，可以參閱
&lt;a href="https://kops.sigs.k8s.io/" title="kOps-Kubernetes Operations" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 kOps-Kubernetes Operations
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/p></description></item><item><title>[總結]Leetcode 週賽第319場復盤總結</title><link>http://localhost:1313/post/coding/leetcode-contest319/</link><pubDate>Sun, 13 Nov 2022 11:45:46 +0800</pubDate><guid>http://localhost:1313/post/coding/leetcode-contest319/</guid><description>&lt;h1 id="今日為2022年11月13日週日---leetcode-週賽第319場">今日為2022年11月13日(週日) - Leetcode 週賽第319場
&lt;a class="header-anchor" href="#%e4%bb%8a%e6%97%a5%e7%82%ba2022%e5%b9%b411%e6%9c%8813%e6%97%a5%e9%80%b1%e6%97%a5---leetcode-%e9%80%b1%e8%b3%bd%e7%ac%ac319%e5%a0%b4">&lt;/a>
&lt;/h1>&lt;blockquote>
&lt;p>目前參加週賽主要的目的是學習跟訓練，所有當前主要focus在解Easy 跟 Medium的題目，Hard的題目暫且先跳過了&lt;/p>
&lt;/blockquote>
&lt;h3 id="週賽題目如下">週賽題目如下:
&lt;a class="header-anchor" href="#%e9%80%b1%e8%b3%bd%e9%a1%8c%e7%9b%ae%e5%a6%82%e4%b8%8b">&lt;/a>
&lt;/h3>&lt;ol>
&lt;li>Convert the Temperature - &lt;strong>Easy&lt;/strong>&lt;/li>
&lt;li>Number of Subarrays With LCM Equal to K - &lt;strong>Medium&lt;/strong>&lt;/li>
&lt;li>Minimum Number of Operations to Sort a Binary Tree by Level - &lt;strong>Medium&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h3 id="convert-the-temperature---easy">Convert the Temperature - Easy
&lt;a class="header-anchor" href="#convert-the-temperature---easy">&lt;/a>
&lt;/h3>&lt;p>You are given a non-negative floating point number rounded to two decimal places &lt;code>celsius&lt;/code>, that denotes &lt;strong>the temperature in Celsius&lt;/strong>.&lt;/p></description></item><item><title>Leetcode Weekly Contest 331(第一次參加競賽)</title><link>http://localhost:1313/post/coding/leetcodeweeklycontest331/</link><pubDate>Sun, 18 Sep 2022 16:32:34 +0800</pubDate><guid>http://localhost:1313/post/coding/leetcodeweeklycontest331/</guid><description>&lt;blockquote>
&lt;p>今天是我第一次參加&lt;strong>Leetcode 雙週賽&lt;/strong>，所以想記錄一下今天的競賽題目。希望能透過博客來記錄自己的競賽狀況。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>本週AC題數為:4/4&lt;/strong>&lt;/p>
&lt;h2 id="題目">題目
&lt;a class="header-anchor" href="#%e9%a1%8c%e7%9b%ae">&lt;/a>
&lt;/h2>&lt;h3 id="2413-smallest-even-multipleeasy---ac">2413. Smallest Even Multiple(EASY) - AC
&lt;a class="header-anchor" href="#2413-smallest-even-multipleeasy---ac">&lt;/a>
&lt;/h3>&lt;p>Given a positive integer &lt;code>n&lt;/code>, return the smallest positive integer that is a multiple of both &lt;code>2&lt;/code> and &lt;code>n&lt;/code>.&lt;/p></description></item><item><title>[筆記]Traversal Graph(圖)</title><link>http://localhost:1313/post/coding/bt-traversal/</link><pubDate>Thu, 08 Sep 2022 10:34:50 +0800</pubDate><guid>http://localhost:1313/post/coding/bt-traversal/</guid><description>&lt;blockquote>
&lt;p>總所周知Binary Tree也是圖的一種(單向無環圖)。所以,今天這裡以Binary Tree 為例。&lt;/p>
&lt;/blockquote>
&lt;h1 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h1>&lt;p>如果今天我們需要以&lt;strong>特定&lt;/strong>的方式遍歷一棵*Binary Tree(圖的一種)*我們怎麼做呢? 我們可以透過DSF(深度優先搜尋)以及BFS(廣度優先搜尋)來幫助我們遍歷&lt;strong>Binary Tree&lt;/strong>&lt;/p></description></item><item><title>[開發日記]OTT電影社群APP(一)</title><link>http://localhost:1313/post/project/dev-ottapp-1/</link><pubDate>Tue, 06 Sep 2022 12:36:22 +0800</pubDate><guid>http://localhost:1313/post/project/dev-ottapp-1/</guid><description>&lt;blockquote>
&lt;p>最近這2個月都沒有更新發文章，主要是因為這2個月都在專注重構畢業專題的項目，也是只OTT電影平台。&lt;br>
今天這篇文章主要是跟大家分享這2個月所開發的進度和目前開發到的階段，以此作為這個項目的開發日記。&lt;/p></description></item><item><title>[筆記]TrieTree(前綴樹/字典樹)</title><link>http://localhost:1313/post/note/trietree/</link><pubDate>Tue, 21 Jun 2022 11:19:28 +0800</pubDate><guid>http://localhost:1313/post/note/trietree/</guid><description>&lt;h1 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h1>&lt;h2 id="什麼是trietree">什麼是TrieTree?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%aftrietree">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>Trie稱為前綴樹或字典樹,是有序樹的一種,Node的key通常為String類型。Trie Tree與Binary-Searching Tree不同的點是,Trie Tree的Key並不會直接保存在Node中,而是它在Tree中的位置所決定的。一個Node中的所有的childrens都有相同的Prefix(前綴)。假設有個Node的key 為&lt;code>T&lt;/code>,它的children將會是&lt;code>Time&lt;/code>, &lt;code>Tim&lt;/code>, &lt;code>Test&lt;/code>等,因為他們都會相同的Prefix(前綴)&lt;code>T&lt;/code>。&lt;/p></description></item><item><title>[雕刻日常]數位雕刻基礎-人頭骨雕刻目前最好的一次!</title><link>http://localhost:1313/post/share/sculpturetrain1/</link><pubDate>Fri, 17 Jun 2022 23:28:22 +0800</pubDate><guid>http://localhost:1313/post/share/sculpturetrain1/</guid><description>&lt;h2 id="直接上圖">直接上圖!
&lt;a class="header-anchor" href="#%e7%9b%b4%e6%8e%a5%e4%b8%8a%e5%9c%96">&lt;/a>
&lt;/h2>&lt;p>&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/design/head-train.jpg" alt="head" />&lt;/p></description></item><item><title>[筆記]Palindromic String(迴文字串)</title><link>http://localhost:1313/post/note/palindromicstring/</link><pubDate>Thu, 16 Jun 2022 12:26:03 +0800</pubDate><guid>http://localhost:1313/post/note/palindromicstring/</guid><description>&lt;h1 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h1>&lt;h2 id="什麼是palindromic-string-迴文字串">什麼是Palindromic String 迴文字串
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afpalindromic-string-%e8%bf%b4%e6%96%87%e5%ad%97%e4%b8%b2">&lt;/a>
&lt;/h2>&lt;p>所謂的Palindromic String(迴文字串) 就是以一個字元為中間，而它的左邊以及右邊的組成字元相同。&lt;br>
例子:&lt;br>
&lt;code>abcdcba&lt;/code> 以&lt;code>d&lt;/code>為中心的左跟右的字元一樣。&lt;br>
&lt;code>cdc&lt;/code>左跟右都為&lt;code>c&lt;/code>&lt;br>
&lt;code>bcdcb&lt;/code> 左跟右都為&lt;code>b&lt;/code>&lt;br>
&lt;code>abcdcba&lt;/code> 左跟右都為&lt;code>a&lt;/code>&lt;/p></description></item><item><title>[筆記]Longest Common SubString(最長公共子序列)</title><link>http://localhost:1313/post/coding/lcm/</link><pubDate>Tue, 14 Jun 2022 13:11:28 +0800</pubDate><guid>http://localhost:1313/post/coding/lcm/</guid><description>&lt;h1 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h1>&lt;h2 id="什麼是最長公共子序列">什麼是最長公共子序列?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%af%e6%9c%80%e9%95%b7%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97">&lt;/a>
&lt;/h2>&lt;p>給定2個字串&lt;code>string A&lt;/code>和&lt;code>string B&lt;/code>,2個字串中所共同擁有的最長的子字串。&lt;br>
例如:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>String A : leetcode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String B : ecbod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">他們的最長公共子序列便是&lt;/span>&lt;span style="color:#f92672">`&lt;/span>ecod&lt;span style="color:#f92672">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">解釋&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String A &lt;span style="color:#960050;background-color:#1e0010">包含了&lt;/span> __e_cod_ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> ecod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String B &lt;span style="color:#960050;background-color:#1e0010">包含了&lt;/span> ec_od &lt;span style="color:#f92672">=&amp;gt;&lt;/span> ecod
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="要怎麼找到最長公共子序列lcm呢">要怎麼找到最長公共子序列LCM呢?
&lt;a class="header-anchor" href="#%e8%a6%81%e6%80%8e%e9%ba%bc%e6%89%be%e5%88%b0%e6%9c%80%e9%95%b7%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97lcm%e5%91%a2">&lt;/a>
&lt;/h2>&lt;p>我們需要定義一個數組用於保存當前情況下的最優解,也就是使用&lt;code>DP&lt;/code>的方式。我們需要以每個字符最為考量,並一一匹配，最後得出整體最優解。
&lt;img src="http://localhost:1313/imgs/img-lazy-loading.gif" data-src="http://localhost:1313/imgs/leetcodesHelper/lcm.png" alt="LCM" />&lt;/p></description></item><item><title>MetaHuman虛擬數字人初探</title><link>http://localhost:1313/post/share/mataverse-matahuman/</link><pubDate>Sun, 12 Jun 2022 15:01:27 +0800</pubDate><guid>http://localhost:1313/post/share/mataverse-matahuman/</guid><description>&lt;p>因為元宇宙(Metaverse)這個概念火熱,所有我就趁著這個機會了解一下在元宇宙領域中本人覺得比較有趣的東西。也就是這篇文章所要分享給各位的&lt;strong>MetaHuman(虛擬數字人/虛擬數位人)&lt;/strong>&lt;/p></description></item><item><title>[Note]Creational Singleton Pattern</title><link>http://localhost:1313/post/design-pattern/creational-singleton-pattern/</link><pubDate>Sat, 09 Apr 2022 11:19:39 +0800</pubDate><guid>http://localhost:1313/post/design-pattern/creational-singleton-pattern/</guid><description>&lt;h2 id="什麼是singleton-pattern單例模式呢">什麼是Singleton Pattern(單例模式)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afsingleton-pattern%e5%96%ae%e4%be%8b%e6%a8%a1%e5%bc%8f%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>定義:一個Class在系統中只會存在一個實例(instance),整個系統中只提供1個可使用的instance,以確保唯一性,並節省系統資源。&lt;/p></description></item><item><title>[Note]Creational Abstract Factory</title><link>http://localhost:1313/post/design-pattern/creational-abstract-factory/</link><pubDate>Sun, 03 Apr 2022 19:38:20 +0800</pubDate><guid>http://localhost:1313/post/design-pattern/creational-abstract-factory/</guid><description>&lt;h2 id="什麼是abstract-factory抽象工廠呢">什麼是Abstract Factory(抽象工廠)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afabstract-factory%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%bb%a0%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>定義: 又稱為Kit模式。提供一個創建系列相關或者互相依賴的Interface，而無需指定其具體的class&lt;/p>
&lt;/blockquote>
&lt;h3 id="簡單例子">簡單例子
&lt;a class="header-anchor" href="#%e7%b0%a1%e5%96%ae%e4%be%8b%e5%ad%90">&lt;/a>
&lt;/h3>&lt;p>&lt;em>注: 以下程式單純用於解釋，並不能實際執行&lt;/em>&lt;/p></description></item><item><title>[Note]Simple RateLimiter Example Based on IP</title><link>http://localhost:1313/post/note/simple-ratelimiter-example-based-on-ip/</link><pubDate>Wed, 30 Mar 2022 16:05:57 +0800</pubDate><guid>http://localhost:1313/post/note/simple-ratelimiter-example-based-on-ip/</guid><description>&lt;h3 id="基於gin實作rate-limiter">基於Gin實作Rate Limiter
&lt;a class="header-anchor" href="#%e5%9f%ba%e6%96%bcgin%e5%af%a6%e4%bd%9crate-limiter">&lt;/a>
&lt;/h3>&lt;p>假設我們有2個APIs,而每個API都需要消耗1個&lt;code>Tokens&lt;/code>&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">uri&lt;/th>
 &lt;th style="text-align: left">method&lt;/th>
 &lt;th style="text-align: left">desc&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">/api/posts/{id}&lt;/td>
 &lt;td style="text-align: left">GET&lt;/td>
 &lt;td style="text-align: left">return a simple demo message&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">/ping&lt;/td>
 &lt;td style="text-align: left">GET&lt;/td>
 &lt;td style="text-align: left">return pong&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>我們先設置一下rate limiter桶子的容量只能放下一個tokens,而tokens則會每秒生產5個。存取API時,若沒有Token可以用，就需要等待token下一次生產並放到桶子裡，才能繼續進行下去。&lt;/strong>&lt;/p></description></item><item><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><link>http://localhost:1313/post/note/token-bucket-intro/</link><pubDate>Tue, 29 Mar 2022 18:33:07 +0800</pubDate><guid>http://localhost:1313/post/note/token-bucket-intro/</guid><description>&lt;h2 id="token-bucket令牌桶算法">Token Bucket(令牌桶算法)
&lt;a class="header-anchor" href="#token-bucket%e4%bb%a4%e7%89%8c%e6%a1%b6%e7%ae%97%e6%b3%95">&lt;/a>
&lt;/h2>&lt;h4 id="什麼是token-bucket-呢">什麼是Token Bucket 呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%aftoken-bucket-%e5%91%a2">&lt;/a>
&lt;/h4>&lt;blockquote>
&lt;p>簡單來說就是運用Token Bucket的系統會以一個設定的速率往桶子(Bucket)裡面丟令牌(Token)。如果請求(Request)需要被處理時，就必需得Bucket裡的Token。當桶子裡面的沒有Token可以分配/獲取時，也就是說Bucket現在是空的(Token已經被其他令牌拿完了)，系統則會拒絕這個請求的服務。&lt;/p></description></item><item><title>[Note]Creational-Factory</title><link>http://localhost:1313/post/design-pattern/creational-factory/</link><pubDate>Sun, 27 Mar 2022 16:55:17 +0800</pubDate><guid>http://localhost:1313/post/design-pattern/creational-factory/</guid><description>&lt;h2 id="什麼是factory工廠呢">什麼是Factory(工廠)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%affactory%e5%b7%a5%e5%bb%a0%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>定義:建立一個接口,讓子類自己決定實現哪一個Factory,其&lt;strong>重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題&lt;/strong>&lt;/p></description></item><item><title>[Note]Creational-Simple Factory</title><link>http://localhost:1313/post/design-pattern/creational-simple-factory/</link><pubDate>Sun, 27 Mar 2022 16:42:45 +0800</pubDate><guid>http://localhost:1313/post/design-pattern/creational-simple-factory/</guid><description>&lt;h2 id="什麼是simple-factory簡單工廠呢">什麼是Simple Factory(簡單工廠)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afsimple-factory%e7%b0%a1%e5%96%ae%e5%b7%a5%e5%bb%a0%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>簡單而言就是: 由一個工廠來生產全部產品
定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object&lt;/p></description></item><item><title>[Note]Design Pattern Princeple</title><link>http://localhost:1313/post/design-pattern/design-pattern-princeple/</link><pubDate>Sun, 27 Mar 2022 16:18:55 +0800</pubDate><guid>http://localhost:1313/post/design-pattern/design-pattern-princeple/</guid><description>&lt;h2 id="什麼是design-pattern設計模式呢">什麼是Design Pattern(設計模式)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afdesign-pattern%e8%a8%ad%e8%a8%88%e6%a8%a1%e5%bc%8f%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，&lt;strong>如何解決問題的一種方案&lt;/strong>&lt;/p></description></item><item><title>[Note]What Is JWT(Json Web Token)-EN</title><link>http://localhost:1313/post/note/jwt-note/</link><pubDate>Thu, 24 Mar 2022 13:52:49 +0800</pubDate><guid>http://localhost:1313/post/note/jwt-note/</guid><description>&lt;h2 id="what-is-jwtjson-web-token">What is JWT(Json Web Token)?
&lt;a class="header-anchor" href="#what-is-jwtjson-web-token">&lt;/a>
&lt;/h2>&lt;p>The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.&lt;br>
It&amp;rsquo;s used for &lt;em>identity authentication&lt;/em> between client and the server that allows accessing resources in the server.&lt;/p>
&lt;h2 id="the-structure-of-jwt">The Structure of JWT
&lt;a class="header-anchor" href="#the-structure-of-jwt">&lt;/a>
&lt;/h2>&lt;p>JWT consists of three parts including:&lt;/p></description></item></channel></rss>