<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>2023年度總結(2023 annual summary)</title><url>https://ryantokmanmokmtm.github.io/memories/summary-of-2023/</url><categories/><tags><tag>2023</tag></tags><content type="html"> 2023目標進度條目標： 找到合適的工作 -> 算了找了工作 競賽積分達到1700+ : 鴿了 嘗試拿下Knight 段位 : 鴿了 英文聽說讀寫好好練 -> 持續學習 多參與活動 -> 參與的活動還是很多的 考好雅思 -> 持續學習 年初 1月份的時候， 大概2年半快3年沒回家是時候應該要回家一趟了。於是就訂了1月10號的機票回家。或許是太久沒有踏入這個成長的地方感覺真的變的不一樣了，真的有種離鄉別井多年回到家的感覺，很懷念且很感動！然而這個時候還在疫情影響恢復的初期，所以大家都帶著口罩以免感染。在疫情這2年，我在台灣都沒有感染過，回來第一週就被感染，真的有夠不幸，嗚嗚嗚。不過我的症狀並沒有像網路上說的一樣呼吸困難，發燒等痛苦的症狀，只有喉嚨像被刀割。雖然很痛苦，但是一週後就康復了。很幸運，不用去住醫院，不幸的是我爸被我傳染了，但他也很快也就康復了！
這次回來其實我覺得自己是一個遊客多過像一個本地人。康復後的第一個時間就是到處跑，去以前經常去的地方，以前沒去過的地方等等。對於以前經常去過的地方對比以前我有了不一樣的感覺，還會特地放下腳步觀察以前曾不會去留意的事和物十分的有趣；而對於沒去過的地方就當作是旅遊來看，哈哈哈。除此之外，也跟了很多以前的朋友，同學吃飯，聊了很多這些年發生和學生時代發生過的事情，真的是回憶滿滿！最後也去了「香港迪士尼樂園」，上一次去已經是10幾年前，也就是小學4年級的時候學校帶過去，我對那次的記憶基本上已經很模糊了，只記得一小部分～這次來真的讓我很感動，使我回憶起來迪士尼角色陪伴我成長的片段，特別是晚上的「迪士尼星夢光影之旅」的點綴，更加讓人差點眼淚止不住的流，嗚嗚嗚。期待下一才再來看的時候，有別的不一樣的感覺！
新年過後，2月10號我便回到了台灣繼續我的尋找工作之旅，但是在2月這段時間我也有在陸續投遞CV同時在思考自己是否應該必須留在台灣工作，台灣知否真的適合自己等問題，也跟朋友們和家人討論，經過一段時間的掙扎後，我便下定了決心，離開🇹🇼。在現階段🇹🇼感覺不是很適合我，可以現暫時離開回🇭🇰工作，如果日後真的很想要再回🇹🇼，還可以另尋他法。痛定思痛就跟房東說出了自己要離開🇹🇼的決心，於4月1號退租。其實說出口的這段時間還是有點猶豫的，但說出來了就不能在回頭了。再剩下的最後這1個多月裡，除了處理如何把東西寄回家，不能寄回家的得另尋他法能丟棄的則丟棄。因為🇹🇼廢物，特別是大型的廢物不能隨便的處理掉，這也是對我一項挑戰，最後也成功處理！除此之外，也跟各好朋友們約吃飯，畢竟可能這是我們最後一次見面了，嗚嗚嗚。
很快的就到3月31號了，我本來打算是要一個人好好享受完這個最後一晚，我便去了新光三越聽聽歌吃吃飯。到了晚上10點多，我便回家收拾一下行李睡覺的，結果系花和莉淇姐姐就問我要不要晚上12點去夜店，我就想說反正都最後一天了，就個瘋個夠！洗漱完便搭了捷運末班車的出發了。結果瘋到了快3點，4點，而且這也是我第一次喝酒還頭暈的，也是第一次去夜店！什麼第一次都獻給了他們，哈哈哈。最後4點便回家睡覺，不然明天回家沒精神就完了。特別感恩我妹能前來機場送我，這也是第一次有朋友送我機，差點感動到哭出來，我還是很喜歡我妹的，嗚嗚嗚。
4月中旬，Ivan來香港工作，這是第一次有台灣的同學來香港（認識的），太開心了。第一天都跟Ivan到處吃吃喝喝，還他們喝了「喜茶」，他們都說好喝。雖然他是前來工作的，但是他還是給了我一張去Web3.0活動的門票，據說這張門票超級貴，難得搞到這樣的票，我跟他前去觀摩。在觀摩的途中，還帶我掙了一波小錢，不愧是大師！一周的時間很快就過去了，在他離開的當天，我便陪他去機場送他離開～還順走了我的行李箱為之後快閃台北埋下伏筆。
年中 回到了香港已經快1～2週還是很不習慣，廣東話講出來卡卡的，物價也沒有很習慣，還停留在了台灣的習慣，這個可以慢慢來。但是這次回來主要目的是找工作，於是我便開啟了我在香港找工作的旅程，找了大概快1個月還是沒有面試機會，就又開始迷茫和焦慮同時又得只婆婆歷史的消息。現在回想還是有點後悔沒有去送婆婆最後一程。最後找5月初了的時候得到了一個面試機會，我本以為面試的過程會跟🇹🇼的差不多，結果只是簡單和我聊天，問我大學的時候做了些什麼之類就結束了。感覺面試沒有很嚴謹，公司規模也沒有很大，但是這個之後也沒有獲得其他面試機會了，嗚嗚嗚。不過這家公司最後給我發了offer，我就想「要不先工作累積工作經驗，以後再跳也是可以」的心情接受了offer，在找不到工作我感覺就要掛了，嗚嗚嗚。
大概5月底開始上班，第一天上班的心情是既激動又緊張，不過公司的人很好，中午的時候還一起吃飯，一起聊天，讓我的緊張的心情減少了許多～還好後面來了一位跟我同年的女生跟我一起工作，雖然他只工作了大概1個多月的時間便離職了，但這段一起吃飯，分享食物，下班，聊工作的時光在無聊的工作和生活中添加了一些樂趣。感謝他這段時間的陪伴！
大概6月初的時候馬思唯要來香港辦演唱會，於是龍哥跟我相約一同前去。那會才剛上班沒有信用卡，還好有龍哥在，而且是VIP的位置，超級讚。演唱會那天我請了下午的班，背著電腦跟鍵盤前去，哪有人會背著電腦和鍵盤去看演唱會，哈哈哈。因為是VIP所以必須提前去排隊，VIP可以提前入場聽預熱。當天聽了一整晚的說唱，雖然站的很累，雖然我沒有很常聽馬思唯的歌，但是那天真的很開心！
7月份的時候，我邊跟高中同學一起去澳門，這也是我住了這麼久第一次澳門看看。我們去吃了很多當地的食物，去了很多不同的旅遊景點，還在不同的賭場穿梭。第一次見到賭場是多麼的壯觀，心想：「原來現實生活中的賭場是這樣子的！跟我想像的差很多！」，我們還下手玩了幾把，但是我們都不太會玩，所以只玩了「比大小的🎲」，最後還贏了$100，雖說不多，但是來回車錢已經回本了，哈哈哈。最後我們也去吃了葡菜，真的不錯吃欸～～
年底 時間過得很快，已經9月份了，我在9月16有計畫去台北玩2天，順便拿回那個被順走的行李箱，哈哈哈。剛好9月16號當天Cakeresume有舉辦職涯活動，我便跟Ivan和他的女朋友，還有學長一同前去逛展。逛了一整個下午，看到了很多公司在招聘，還有一些前輩和在校學生的「你問我答」的留言板，看了他們的留言學習了很多！到了晚上我們便去了新光三越吃飯，吃飯的時候跟學長聊了很多中國議題，這也是我開始關注中國議題的開始～吃完飯後我們正打算要離開，我卻發現手機不見了，還好只是留在了店家，有成功拿回來，嚇死～到後面，我們就分開各自回家了。去青旅報道的時候發生一些小插曲，就是訂到了女生的房間，不過還好有人退訂，不然那天真的要直接睡大街，可喜可賀！整理完後我便去了西門町看電影和逛逛～ 到了另外一天，我便跟大師一同吃飯和逛街，逛了一整個下午，大概5點就前往機場，但是這裡又發生了一些小插曲，就是週日的機場爆滿，離飛機飛行的時間不到1個小時，本因為會搭不上飛機，還好有讓這班飛機的乘客優先checkIn，不然真的會趕不上。但是checkIn只是第一關，出關的時候也是爆幹多人，但這邊就只能乖乖等待並內心祈禱。過完海關離最後的登機時間不到10分鐘，這裡就「狗衝」的過去，幸好最後也順利搭上。
這次的快閃「台北」之類真的既驚險又好玩啊，哈哈哈～～～～～
10月份的時候有聽龍哥說PGONE會在11月的時候來🇭🇰開演唱會，於是我便一直留意他們的官方帳號，直到最後看到會在11月11號舉辦的時候，超級興奮！！！但是不知道會不會搶得到票就是了。到了搶票的日子，而當天是上班日，我整個早上心不在焉的一直在當心搶票的事情。10點整開搶，結果直接要排隊，第一次搶票，完全沒經驗，哈哈哈。不過最後有搶到，雖然不是前面的座位，但是有搶到票就很開心了！到了11月11號這天，我便滿心歡喜的參與，我本以為場地會跟馬思唯那次的差不多，結果場地大很多只不過是坐票，有點失落，不過也好不用站一整晚。一整場下來聽到了很多新歌，也聽到了很多經典歌曲，特別是《中二病》有夠經典，「夢回到2017年的夏天」！有一點不好的是我帶了個沒電的行動電源，真的是被自己給氣死，啊啊啊。還好手機給力30%的電撐了一整個晚上，感謝我的手機！
很快今年到達了尾聲，12月中旬便跟高中同學們一起深圳玩一天，對上一次去深圳已經是2019年的事情了。這次的行程可比上次的開心許多了，可能是因為上次沒有什麼資金吧，哈哈哈。這次出去吃吃喝喝，還去逛了華強北，據說是「高仿聖地」我也見識到了，而且還去了吃很多美食，我印象最深刻的是福田的「榴蓮麵包」，「榴蓮手搖」超好吃，還有晚餐時候吃的「椰子雞」的雞肉超嫩，湯也好濃郁，讓人口水直流！晚飯過後，我們還去瘋了一把，在街機店換了280個幣遊玩，有夠爽！除此之外，不知為何他們卻愛上了「刮刮樂」，有看到「刮刮樂」就會忍不住的去玩上幾把，結果可想而知被當韭菜的份，哈哈哈哈，圖一樂還是可以的！
到了12月31號這天，我跟朋友打算去迪士尼跨年，剛好迪士尼第一次辦跨年活動，而去也剛好開了新的forzen園區。這次的目標是去迪士尼體驗「跨年」和遊玩「forzen」園區的新設施。上一次來迪士尼是年初的時候，這次來不知道會不會有新的感覺呢，哈哈哈。這天迪士尼的開園時間是早上的10:00～00:30，但我們有買提前1小時進園的票，就遊玩時間直接演出了一個小時，我們就已經做好了累死的準備。一整天下遊玩和表演看下來真的讓人感到開心，感動和興奮，累的感覺可以說是不值得一提。我們從早上玩到了晚上9點左右，因為晚上的「跨年倒數活動」和「迪士尼星夢光影之旅」表演是11:25才開始，所以要先去佔領位置，大概等了2小時左右，漫長的等待終於結束了，表演終於開始！不得不說表演真的很壯觀，就算累也是值得的！整天下來雖然門票很貴，但是我覺得整體是值得的！最後要離開的時候，真的讓人依依不捨，嗚嗚嗚。然而回家的地鐵直接塞死，哈哈哈。
2024新年快樂，接下來1年繼續加油！
小習慣🏅 每日記帳 每日日記和感恩日記 習慣追蹤 閱讀書籍📚 成就🏅 📚：3 🎬：12 🧳：3 總結 多了很多戶外活動 除了上班時間，寫程式的時間和學習的時間減少了 多跟朋友見面了 2024目標 去一次外國旅遊 持續學習(Coding&amp;Language) 完成ChatApp 體驗不同的事物 認識新朋友</content></entry><entry><title>香港迪士尼跨年(迪士尼第一次跨年活動)</title><url>https://ryantokmanmokmtm.github.io/memories/last-day-of-2023/</url><categories/><tags><tag>memories</tag><tag>2023</tag><tag>disney</tag></tags><content type="html"> 因為2023年年初的時候有去香港迪士尼遊玩一天，就想著就在迪士尼來在完美的ending。於是便有了年尾去迪士尼度過最後一天的念頭，剛好今年迪士尼也是第一次舉辦跨年活動，開心！！！！
所以就想透過此文章記錄一次這個完美的時刻！嘿嘿😁
享受快樂的時光❤️❤️❤️❤️</content></entry><entry><title>[Development Diary] Real Time Communication APP - Sicker Updated(II)</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-sticker-shop-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> Intro If you want to checkout what is this project about, please go through articles below.
ChatApp(I)
ChatApp(II)
ChatApp(III)
ChatApp(IV)
ChatApp(V)
ChatApp(VI)
ChatApp(Ⅶ)
ChatApp(Ⅷ)
Demo Video
TODO And Description As I mentioned in this article, I&rsquo;ve added a new feature about stickers, which is able to use the provided sticker resources in the chat. But that is not enough and is not flexible for the user. So, I&rsquo;ve developed some more about the sticker feature.
First, due to the fact that a user can only use stickers that are provided by ADMIN, the user isn&rsquo;t allowed to add any other sticker resources without ADMIN. And also, all the users in the app have the same stickers, so there are no different stickers for different users. Therefore, I added a sticker shop to the app that allows users to choose what sticker they want to use.
Second, in the previous version, users accessed sticker resources via API to fetch the data,which wasn&rsquo;t effective to fetch the same resources frequently. So, I added a feature that requires users to download the stickers to their devices before they can use them. Once the user has downloaded the sticker resources, the downloaded resources can be shared across different accounts on the same device if the account has the same sticker.
Summary In this version, I have updated a few things about the sticker feature.
Sticker Shop for users adding their favorite sticker to their account:(Sticker Shop's sticker can now only be added by API) Download the sticker locally and share the same resources across different accounts on the same devices. That the ends of my sharing, thanks you for your reading time ^^, see ya!</content></entry><entry><title>[Development Diary] Real Time Communication APP - Story updated(III)</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-story-view-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> Intro If you want to checkout what is this project about, please go through articles below.
ChatApp(I)
ChatApp(II)
ChatApp(III)
ChatApp(IV)
ChatApp(V)
ChatApp(VI)
ChatApp(Ⅶ)
ChatApp(Ⅷ)
Demo Video
TODO &amp;&amp; Description In the previous version, a user could only view their friend&rsquo;s story and reply to the story. It can&rsquo;t have any interaction with their friends except replying to the story, so in this version, I planned to add more interaction features to it.
There are three main features I have updated. The first is that the story can be liked; the second is that the story owner can view who sees the story and be able to send a message to the viewer; and the last thing is to share a story with any friend. All these features are not difficult to implement, so I have nothing to share with you about tech issues.
In this article, it is just a simple record of what I have updated in this version.
Hope you have a good day. Enjoy!</content></entry><entry><title>[Development Diary] Real Time Communication APP - Story Updated(II)</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-story-multiple-img-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> Intro If you want to checkout what is this project about, please go through articles below. ChatApp(I)
ChatApp(II)
ChatApp(III)
ChatApp(IV)
ChatApp(V)
ChatApp(VI)
Here is the demonstration video about the story feature, is similar to instagram(I took the reference from instagram for the UI xD).
What i have done for this feature?
Allowed user to add text or image to his story. For making story editor more flexible, added a item alignment system and item scaling, rotation and movable. Baisc attribute for the item, for example: Text - (text color, bold,background etc), image(border) Allowed friends to like the story by pressing the like button. summary</content></entry><entry><title>[Development Diary] Real Time Communication APP - Story Updated(I)</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-story-alignment-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> Intro If you want to checkout what is this project about, please go through articles below.
ChatApp(I)
ChatApp(II)
ChatApp(III)
ChatApp(IV)
ChatApp(V)
ChatApp(VI)
Demo Video
TODO In the previous version, it did allow users to add multiple texts to their instance story. But it’s hard to align all the text items without barely using their eyes to do so. So, in this version, I decided to add an alignment tool to help them, which is similar to the Instagram alignment tool.
HOW To implement this feature, we need to know the width and height of the item the user wants to align first. Due to the item&rsquo;s able to scale and rotate, the width and the height will be different than the original size, so we need to get the correct size before we can start to align.
You may wonder how we can get the correct size after scaling and rotation. For&rsquo;scaling&rsquo;, which is a bit easier than roatation, we just need to multiply the size by the scale factor, and then we can get the correct scaled size. But for calculating the size after rotation, we need some math to help us, which we learned from high school, which is trigonometric functions. Applying this math, we can calculate the width and height easily.
After we get the correct size, we can start to align the item. Alignment functions are just a simple calculation, so I&rsquo;m not going to share the details here, but I will provide all those functions here for your reference!
To calculate the size
GeometryReader{ proxy -> Color in DispatchQueue.main.async { self.currentItemSize = proxy.size let newWidthAfterRotate1 = self.currentItemSize.height * sin(box.angle.radians) let newWidthAfterRotate2 = self.currentItemSize.width * cos(box.angle.radians) let newHeightAfterRotate1 = self.currentItemSize.height * cos(box.angle.radians) let newHeightAfterRotate2 = self.currentItemSize.width * sin(box.angle.radians) self.currentItemSize.width = abs(newWidthAfterRotate1) + abs(newWidthAfterRotate2) self.currentItemSize.height = abs(newHeightAfterRotate1) + abs(newHeightAfterRotate2) self.currentItemSize.width *= (box.scaleFactor + box.lastScaleFactor) //new width after scale self.currentItemSize.height *= (box.scaleFactor + box.lastScaleFactor) //new heigh after scale //https://i.stack.imgur.com/C6NVo.png } return Color.clear } Alignment functions - Leading Alignment
private func leadingAlignmentChecking(proxyFrame : CGSize,newLocation : CGSize) -> CGSize { var location = newLocation let startWidth = location.width - (self.currentItemSize.width / 2) let leadingAignment = -(proxyFrame.width / 2 - 10) if !isLeadingAlignment { if startWidth >= leadingAignment &amp;&amp; startWidth &lt;= leadingAignment + 3{ withAnimation{ isLeadingAlignment = true } } }else { //TODO:To leave the alignment status if startWidth &lt;= leadingAignment - 10 || startWidth >= leadingAignment + 10{ withAnimation{ isLeadingAlignment = false } } } withAnimation{ location.width = isLeadingAlignment ? leadingAignment + (self.currentItemSize.width / 2) : location.width } return location } Alignment functions - Traling Alignment
private func tralingAlignmentChecking(proxyFrame : CGSize,newLocation : CGSize) -> CGSize{ var location = newLocation let endWidth = location.width + (self.currentItemSize.width / 2) let tralingAignment = proxyFrame.width / 2 - 10 if !isTralingAlignment { if endWidth >= tralingAignment &amp;&amp; endWidth &lt;= tralingAignment + 3{ withAnimation{ isTralingAlignment = true } } }else { //TODO:To leave the alignment status if endWidth &lt;= tralingAignment - 10 || endWidth >= tralingAignment + 10{ withAnimation{ isTralingAlignment = false } } } withAnimation{ location.width = isTralingAlignment ? tralingAignment - (self.currentItemSize.width / 2) : location.width } return location } Alignment functions - Top Alignment
private func topAlignmentChecking(proxyFrame : CGSize,newLocation : CGSize) -> CGSize{ var location = newLocation let startHeight = location.height - (self.currentItemSize.height / 2) let topAignment = -((UIScreen.main.bounds.height / 1.22) / 2 - 50) if !isTopAlignment { if startHeight >= topAignment &amp;&amp; startHeight &lt;= topAignment + 3{ withAnimation{ isTopAlignment = true } } }else { //TODO:To leave the alignment status if startHeight &lt;= topAignment - 10 || startHeight >= topAignment + 10{ withAnimation{ isTopAlignment = false } } } withAnimation{ location.height = isTopAlignment ? topAignment + (self.currentItemSize.height / 2) : location.height } return location } Alignment functions - Bottom Alignment
private func bottomAlignmentChecking(proxyFrame : CGSize,newLocation : CGSize) -> CGSize{ var location = newLocation let endHeight = location.height + (self.currentItemSize.height / 2) let bottomAignment = ((UIScreen.main.bounds.height / 1.22) / 2 - 50) if !isBottomAlignment { if endHeight >= bottomAignment &amp;&amp; endHeight &lt;= bottomAignment + 3{ withAnimation{ isBottomAlignment = true } } }else { //TODO:To leave the alignment status if endHeight &lt;= bottomAignment - 10 || endHeight >= bottomAignment + 10{ withAnimation{ isBottomAlignment = false } } } withAnimation{ location.height = isBottomAlignment ? bottomAignment - (self.currentItemSize.height / 2) : location.height } return location } Alignment functions - Vertical Alignment
private func verticalAlignmentChecking(proxyFrame : CGSize,newLocation : CGSize) -> CGSize{ var location = newLocation if !isVerticalAlignment { if location.height >= 0 &amp;&amp; location.height &lt;= 3 { withAnimation{ isVerticalAlignment = true } } }else { //TODO: To leave the alignment status if location.height &lt;= -10 || location.height >= 10{ withAnimation{ isVerticalAlignment = false } } } withAnimation{ location.height = isVerticalAlignment ? 0 : location.height } return location } Alignment functions - Horizontal Alignment
private func horizontalAlignmentChecking(proxyFrame : CGSize,newLocation : CGSize) -> CGSize{ var location = newLocation if !isHorizontalAlignment { if location.width >= 0 &amp;&amp; location.width &lt;= 3 { withAnimation{ isHorizontalAlignment = true } } }else { //TODO:To leave the alignment status if location.width &lt;= -10 || location.width >= 10{ withAnimation{ isHorizontalAlignment = false } } } withAnimation(){ location.width = isHorizontalAlignment ? 0 : location.width } return location } That the ends of my sharing, thanks you for your reading time ^^, see ya!</content></entry><entry><title>My First Full Time as Swe</title><url>https://ryantokmanmokmtm.github.io/post/my-first-full-time-week1/</url><categories><category>job diary</category></categories><tags/><content type="html"> Introducation Today is my full-time job as a software engineer. I have been working for one week. So this post is going to share my feeling about my first full-time job this week.
Before I jump into the topic, I want to share my interview experience with this company and the company in the Financial technology industry that works on blockchain technology and Web3. In the interview process, I needed to finish a written examination about basic programming within 45mins. After I finished it, I had to interview the manager and the manager asked about my experience during my college and introduced what are the company working on, that&rsquo;s all, he didn&rsquo;t ask me about some technical problem or algorithm, that wasn&rsquo;t what I expected in an interview, haha.
Then, one week later, I got an offer of this job in this company.
Working During this working week, I have done nothing rather than learn about blockchain and study their previous project. While I studied their project, I spent a lot of time building up the project environment. Let&rsquo;s share what was I struggle with in those projects.
The first project is a front-end project which is using NextJS to develop. When I tried to run in the development mode, it couldn&rsquo;t load all the static resources such as image, javascript, and CSS, but this problem was just happening in the Window system. If I try to run in docker or Macos environment, all the resources can load successfully. But I didn&rsquo;t know why before backend tech told me the reason, it was caused by the path being different between macOS/Linux. Something like that: win: \xxx\yyy\ddd and /xxx/yyy/ddd
The second project is a backened project which is using Kotlin/Java and Spring-boot framework. I have&rsquo;t leanrned Kotlin/Java and Spring before, so i need to spend time in setting up the enviroment. It wasn&rsquo;t the biggest challenge i was facing on, the main challenge was when i tried to run any server-applicated that was inside the project, it always failed due to SQL-Connection problem, but the sql connection was already connected. It was so weird. After i done some experiment, I found out the resson caused the problem, was the scheme&rsquo;s character-set wan&rsquo;t set to UTF-8. damn it,haha.
Summary I think working in a small company is not such bad think that i through, all the people who are wokring here are really nice and feel free to communicate with them. ^^
In the future, if i get much more feeling about working, i will be share here again!
By a unreconcilied person</content></entry><entry><title>[Development Diary] Real Time Communication APP - Sicker Updated(I)</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-sticker-updated/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> Intro I won&rsquo;t mention much about the project again, if you&rsquo;re interested in what is the project about, please check out my previous posts. In the previous posts, i&rsquo;ve introduced the project in detail.
ChatApp(I)
ChatApp(II)
ChatApp(III)
ChatApp(IV)
ChatApp(V)
In the demonstration video, you can see that the sticker feature is similar to any other Real-time communication app on the internet. User be able to access all available stickers that we are provided and send it to another user or group. But the problem is how can we provide sticker resources to user and where are the sticker come from?
To solve the first problem, we can create a sticker resource by uploading all the necessary image to the server before client or user be able to access it. Each created sticker resources will be assigned a unique identifier as its stickerID. All resources releated to a same sticker id will be renamed in a standardized format for easy access. stickerID_index.format.
I designed 2 apis for creating and fetching sticker.
POST /api/v1/sticker -> To create a group of sticker and upload all related sticker to the server GET /api/v1/sticker/:id -> To obtain a related sticker resources with a given id
To solve the second problem, for now i just simply download the sticker form Line by Web crawler (there is illegal problem if the app is published xD). So the sticker is just for testing!
summary A sticker is an image in png format. To implement the sticker feature ,we just need to obtain a sticker&rsquo;s path and send it to the recevier,similar to sending a normal image. However, there is no need to upload the image to server because the sticker resources are already saved on server.
That is all what i want to share today!
Sorry about my bad english - I&rsquo;am still improving my english! ^^</content></entry><entry><title>[Leetcode] Maximum Twin Sum of a Linked List(M)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2130/</url><categories><category>leetcode</category></categories><tags><tag>list</tag><tag>two pointer</tag></tags><content type="html"> LeetCode 2130 - Maximum Twin Sum of a Linked List In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &lt;= i &lt;= (n / 2) - 1.
For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4. The twin sum is defined as the sum of a node and its twin. Given the head of a linked list with even length, return the maximum twin sum of the linked list.
example
Input: head = [5,4,2,1] Output: 6 Explanation: Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6. There are no other nodes with twins in the linked list. Thus, the maximum twin sum of the linked list is 6. Input: head = [4,2,2,3] Output: 7 Explanation: The nodes with twins present in this linked list are: - Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7. - Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4. Thus, the maximum twin sum of the linked list is max(7, 4) = 7. Input: head = [1,100000] Output: 100001 Explanation: There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001. How can we solve this problem? The question told us the length of the given list will be even. So, We can try to use two-pointer approach to find out which node is the n/2th. After we found it out, there&rsquo;s a problem we are facing on, is that the twins node of the n/2th is n/2 - 1th node. Thus, we need to reverse all nodes before n/2th node. Then we can keep moving the pointer and find the maxinum twin&rsquo;s til the end of the list.
A simple graph of this approch
Orignal List: a->b->c->d->e->f the n/2th node : d reverse all nodes before b: a&lt;-b&lt;-c d->e->f both list has the same length ,the ending condtion will be either list a or list b. Solution(Recursion): 我們可以在initial透過Recursive Function來遍歷Input,並把所有Integer先Push到Array/List裡面。然後在定義一個pointer用於存取Next的值即可。
/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger> &amp;getList() const; * }; */ //calling hasNext -> next class NestedIterator { vector&lt;int> ans; // vector&lt;NestedInteger> list; int cur = 0; void getValue(vector&lt;NestedInteger>&amp; data){ for(int i = 0;i&lt;data.size();i++){ if(data[i].isInteger()) ans.push_back(data[i].getInteger()); else getValue(data[i].getList()); } } public: NestedIterator(vector&lt;NestedInteger> &amp;nestedList) { getValue(nestedList); } int next() { return ans[cur++]; } bool hasNext() { return cur &lt; ans.size() ? true:false; } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Solution: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: int pairSum(ListNode* head) { ListNode* slow = head, *fast = head; ListNode* pre = nullptr ,*cur = nullptr, *nxt = nullptr; int ans = 0; while(fast != nullptr){ fast = fast->next; if(fast != nullptr){ fast = fast->next; } //reverse the head list cur = slow; nxt = slow->next; cur->next = pre; pre = cur; slow = nxt; } ListNode* left = pre,*right = slow; while(left != nullptr &amp;&amp; right != nullptr){ ans = max(ans , left->val + right->val); left = left->next; right = right->next; } return ans; } };</content></entry><entry><title>[Anouncement] All everything in the blog will be only in english from now on</title><url>https://ryantokmanmokmtm.github.io/post/new-anouncement/</url><categories><category>anouncement</category></categories><tags><tag>anouncement</tag></tags><content type="html"> Dear all readers,
Hi, as my English ability is not good enough. I&rsquo;ve decided to pratice more in English, especially in writing , reading and speaking. Writing an article in Enlgish is a good way for me to pratice.
Here, I apologize to all readers who can only read in Chinese. I realize that i need to take time to learn English. I hope that all of you can understand me.
best regards
Jakson.tmm</content></entry><entry><title>Chat App</title><url>https://ryantokmanmokmtm.github.io/project/chat-app/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> Chat App - Frontend
Chat App - Backend
簡介 因為之前的OTT電影社群APP中有包含通訊的功能，但是那個App所實現的功能就只是簡單的存文字聊天而已，而那個app主要的focus點並不在通訊上，所以只有簡簡單單的實作了通訊，沒有到完整的通訊，例如：發送文字，發送圖片，發送文件等等的通訊功能。所以這次的side project所實作的app則主要focus在通訊這個點上。
主要功能 Chat-App主要會包含一下之功能
用戶登入/註冊 修改用戶資料 新增用戶為好友(聊天) 刪除用戶 新增聊天群 加入聊天群 退出聊天群 修改聊天群資訊(群主特權) 查看群資訊 查看用戶資訊 單聊 - 與已加好友通訊 群聊 - 與加入之群組通訊 語音通訊 視頻通訊 特別之功能 - 限時動態(24小時動態) - 已新增
限時動態的新增與刪除 - 完成 好友動態查看 - 完成 好友動態回覆 - 完成 限時動態內容多元 - 未添加(目前只允許圖片) 技術棧/工具 SwiftUI UIKit Go-Zero MySQL Gorm Docker Websocket WebRTC K8S AWS App 測試影片 開發階段Demo #1
開發階段Demo #2
開發階段Demo #3
開發階段Demo #4
開發階段Demo #5
開發階段Demo #6
開發階段Demo #7
開發階段Demo #8
開發階段Demo #9
開發階段Demo #10</content></entry><entry><title>[開發者日記] 聊天通訊APP - RTC小更新</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-voice-chat/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 我在[開發者日記] 聊天通訊APP(一)中有提及過這app會有
語音通訊 視頻通訊 這次他們真的來了！！廢話少說先看視頻
說明 雖然現在只有展示了語音通訊(Voice-chat),但是他們的工作原理其實是差不多的，就差在有沒有傳送視頻數據而已。老實說，這個功能其實言研究了2個月都不知道要從何入手，而github上的simple-demo又是UIKit的版本，所以就一直拖，一直研究。知道最近就想試試也無妨，最多也就不成功，萬一它成功了呢！於是我便開始寫，寫了1-2天，發現失敗了，哈哈哈。然後debug了一下，發現好像是沒有連接上的問題，於是又花了一整天來測試是否有成功連接，當成功連接上且文字數據傳送成功的那一刻，那個激動的心啊❤️！！！然後打開視訊，還真的成功了！！！！好開心！
而我這裡用到是WebRTC這個框架。根據網絡上的文章以及我的理解說：要使用P2P連結，就要先繞過NAT，知道自己的Public IP，並通過STUN/TRUN Server來操作！哪這裡我是怎麼做的呢？
首先，要先跟另外一方交換SDP(Session Description Protocal),這裡的資訊包括很多，例如攝像機的sepc，解碼的資訊等等，有興趣可以自行google！而這裡我是透過Websocket 進行交換的。發起人發送offer的SDP，而接收人返回answer的SDP。這樣設備的資訊就交換完成了 接下來就是交換IP和進行連結,這邊我是有過google的public 的ICEServer，並把Ice Server 返回回來的candidate資訊也交換一樣，然後就可以建立P2P連結了！ 以上便是解決這個問題的心得，如果之後還有什麼心得，會繼續更新！
更新 視頻通訊 - Video Chat 這邊就不拍Demo視頻了🤣
支援Mic/Speaker/Video開啟與關閉，鏡頭與切換 其實視訊的部分也只是Voice Chat開啟了視訊數據傳輸而已啦，哈哈哈！其他部分都一樣的呢。這邊就不多說了。
這裡基本上所有功能都實現了，剩下就只是測試和部署。讚
參考資料 WebRTC
Swift-RTC
SwiftUI-RTC
何謂 WebRTC</content></entry><entry><title>[開發者日記] 聊天通訊APP(四) - 最終章</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-final/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 簡介 在之前序章中，雖然已經大概介紹過這個app在幹嘛。但是因為這次是最終章的成品展示(或許有些部分沒實現😂)，所以就允許我囉嗦得再說一次吧！
這個app主要是focus在Websocket，也就是實時通訊上。雖然但是HTTP的部分還是不能少的🤣，哈哈哈。所以這個App的Server-side包含了HTTP和Websocket 2個部分。HTTP的部分主要是用作CURD,而Websocket的部分則是用於個人通訊和群組通訊。
Tech Stack SwiftUI Golang Go-Zero Gorm Mysql Redis Docker/Docker-compose App的功能如下：
基礎功能： 用戶登入與註冊 用戶資料修改，包括用戶頭像，名字和狀態訊息(Status Message) 獲取用戶資訊 尋找好友(透過名字查找) 新增/刪除好友 獲取已加好友列表 建立群組，其中建立群組可以選擇要邀請加入的好友，在建立時會一同加入到群組中。 尋找群組(透過群名) 加入未加入的群組/離開已加入的群組 群組資訊修改(群組權限)，可修改群組頭像和群組名稱 獲取群友類表 獲取已加入群組列表 額外功能: 新增用戶的限時動態(24小時) 獲取用戶好友動態 獲取特定限時動態 刪掉特定限時動態 回覆特定好友之限時動態 - 透過Websocket 發送訊息給動態用戶 核心功能 個人聊天 - 透過Websocket 發送訊息 群組聊天 - 透過Websocket 發送訊息 各聊天室都支援以下訊息: 文字 圖片(如:jpg,png) 文件(如:pdf,docx,txt,ppt,etc.) 音頻(如:wav,mp3) 視頻(暫只支援mp4) 功能細節(後端) HTTP API的部分就不一一詳細解說了，也僅僅是CRUD而已，😂哈哈哈。
用戶API - POST /api/v1/user/signup -> 用戶註冊 - POST /api/v1/user/signin -> 用戶登入 - GET /api/v1/user/info -> 獲取特地用戶資訊 - GET /api/v1/user/profile -> 獲取朋友資訊 - PATCH /api/v1/user/info -> 更新資訊 - PATCH /api/v1/UpdateUserStatus -> 更新狀態資訊 - POST /api/v1/UploadUserAvatar -> 上傳並更新用戶頭像 - POST /api/v1/UploadUserCover -> 上傳並更新用戶背景 - GET /api/v1/user/search -> 搜尋用戶 群組API - POST /api/v1/group -> 建立群組 - POST /api/v1/group/join/:group_id -> 加入特定群組 - DELTE /api/v1/group/leave/:group_id -> 離開特定群組 - GET /api/v1/group -> 獲取群組資訊 - GET /api/v1/group/members/:group_id -> 獲取群組人員 - POST /api/v1/group/avatar/:group_id -> 更新群組頭像 - PATCH /api/v1/group -> 更新群組資訊 - GET /api/v1/group/search -> 搜尋群組 - GET /api/v1/group/info/uuid/:uuid -> 以UUID搜尋群組 朋友API - POST /api/v1/user/friend -> 新增好友 - DELETE /api/v1/user/friend -> 刪除好友 - GET /api/v1/user/friends -> 獲取好友列表 限時動態API - POST /api/v1/story -> 新增限時動態 - DELETE /api/v1/story -> 刪除限時動態 - GET /api/v1/stories -> 獲取特地限時動態 - GET /api/v1/stories/active -> 獲取好友限時動態 訊息API - GET /api/v1/message -> 獲取特地群組信息 - DELETE /api/v1/message -> 刪除特別訊息 文件API - POST /api/v1/file/image/upload -> 上傳圖片 - POST /api/v1/file/upload -> 上傳任何文件 接下來就核心的Websocket的部分了！
因為要進行通訊，那我們就得預先定義好前端和後端都看得懂的格式，否則難以進行溝通。以下是我定義的格式(我是使用ProtoBuffer)：
message Message { string avatar = 1; //user avatar path string fromUserName = 2; //sender user name string fromUUID = 3; //sender uuid string toUUID = 4; //receiver uuid string content = 5; //sending content int32 contentType = 6; //sending content type. For example 1: text, 2: file, 3: audio, 4: video.... int32 type = 7; //For example: "heatbeat" for checking server/client health , video call/audio call ->"webrtc" int32 messageType = 8; //1: single 2: group string groupName = 9; // will have data iff messageType = 2 string groupAvatar = 10; //will have data iff messageType = 2 string urlPath = 11; //file url path or other path string fileName = 12; //sending file name int32 fileSize = 13; //sending file size int32 storyAvailableTime = 14; //reply story created time } avatar : 用於存放發送者的頭像URL[] fromUserName : 發送者的名字 fromUUID ： 發送者的UUID toUUID : 接收者的UUID content : 發送的內容,也就是文字內容 contentType ： 發送的內容類型(這個待會會說有哪些類型)！ type : 發送的訊息類型，是心跳監測呢？還是系統訊息呢？還是普通的用戶通訊訊息呢？ messageType : 單人聊天或者群組聊天的訊息 groupName : 群組的名稱 - 主要用於前端建立房間的緩存 groupAvatar : 群組的頭像 - 主要用於前端建立房間的緩存 urlPath : 發送文件的URL，可以是圖片，文件，音頻或者是其他 fileName : 發送的文件名字 - 用於前端顯示 fileSize : 發送文件的大小 - 用於前端顯示 storyAvailableTime : 顯示動態的建立時間 - 用於前端顯示限時動態的是否可用 剛才說了contentType是發送內容的訊息嘛，那我定義了哪些呢？
const ( TEXT = iota + 1 IMAGE FILE AUDIO VIDEO STORY SYS ) 從上可見，我定義了7種。這7種分別是什麼呢？
messageType 可以為1(單聊)或者2(群聊)，且type為4(訊息類型)
TEXT - 是純文件類型,只有content中有內容。 IMAGE - 是圖片類型, urlPath中會有該圖片的url FILE - 是文件類型，urlPath包含文件的url,fileName包含文件的名稱,fileSize包含文件的大小 AUDIO - 是音頻類型，urlPath包含音頻的url VIDEO - 是視頻類型，urlPath包含視頻的url STORY - 是限時動態類型，urlPath包含了限時動態的url，storyAvailableTime包含了限時動態的建立的時間 messageType 只會為2(群聊)，且type為4(訊息類型)。因為目前系統訊息用於通知用戶加入，離開群組等訊息。
SYS - 群組系統訊息 ,content中有系統訊息內容。 以上的格式是怎麼用於訊息發送的呢？ A為發送者(UUID:123)，B為接收者(UUID:321)。
情境一：發送文字。 A 發送Hello!給B，以下是發送內容：
{ "avatar":"/default.jpg", "fromUserName":"A", "fromUUID" : "123", "toUUID" : "321", "content" : "Hello!", "contentType":1, //1 為text, "type": 4, //4 為訊息 "messageType" : 1, //1為單人聊天 } B接收的內容如下:
{ "avatar":"/default.jpg", "fromUserName":"A", "fromUUID" : "123", "toUUID" : "321", "content" : "Hello!", "contentType":1, //1 為text, "type": 4, //4 為訊息 "messageType" : 1, //1為單人聊天 } 情境二：發送圖片。 在透過websocket發送內容之前，會先透過API上傳圖片到Server，然後Server會回傳圖片的URL。然後再發送該URL即可。
假設Server回傳的URL如下：
{ "code":200, "path":"/image.jpg" } A 發送圖片給B，以下是發送內容：
{ "avatar":"/default.jpg", "fromUserName":"A", "fromUUID" : "123", "toUUID" : "321", "contentType":2, //2 為image, "type": 4, //4 為訊息 "messageType" : 1, //1為單人聊天 "urlPath" : "/image.jpg" } B接收的內容如下:
{ "avatar":"/default.jpg", "fromUserName":"A", "fromUUID" : "123", "toUUID" : "321", "contentType":1, //1 為image, "type": 4, //4 為訊息 "messageType" : 1, //1為單人聊天 "urlPath" : "/image.jpg" } 因為知道contentType是2,所以知道是圖片類型，也知道urlPath保存了圖片的URL。
以上都是單聊的情況，那群聊呢？群聊就跟單聊有些不一樣了呢😂
因為群聊是的接收對象會是群組的UUID,如果不處理一下的話，哪發送者會是發送訊息的人，在Client-side做處理的時候會出錯(因為發送者是A，不是群，哈哈哈)
群組訊息發送思路： 發送者 : A -> Group // A 發送訊息到群組 接收者 : B &lt;- Group // B 接收來自群組的訊息 A為發送者(UUID:123)，B為接收者(UUID:321), 群組G(UUID:G123)。
情境一：發送文字。 A 發送Hello!給到群組G，以下是發送內容：
{ "avatar":"/default.jpg", "fromUserName":"A", "fromUUID" : "123", "toUUID" : "G123", //發送給群組UUID為G123的群組 "content" : "Hello!", "contentType":1, //1 為text, "type": 4, //4 為訊息 "messageType" : 2, //2為群組聊天 "groupName":"groupName#1", //UUID：G123 群名字 "groupAvatar":"/defaultGroup.jpg", //UUID：G123 群頭像URL } B接收的內容如下:
{ "avatar":"/default.jpg", "fromUserName":"A", "fromUUID" : "G123", // 群組UUID為G123的發送訊息 "toUUID" : "321", //接收者UUID為321 "content" : "Hello!", "contentType":1, //1 為text, "type": 4, //4 為訊息 "messageType" : 2, //2為單人聊天 "groupName":"groupName#1", //UUID：G123 群名字 "groupAvatar":"/defaultGroup.jpg", //UUID：G123 群頭像URL } 情境二：發送圖片。 在透過websocket發送內容之前，會先透過API上傳圖片到Server，然後Server會回傳圖片的URL。然後再發送該URL即可。
假設Server回傳的URL如下：
{ "code":200, "path":"/image.jpg" } A 發送圖片給B，以下是發送內容：
{ "avatar":"/default.jpg", "fromUserName":"A", "fromUUID" : "123", //發送者UUID "toUUID" : "G123", //群組UUID "contentType":2, //2 為image, "type": 4, //4 為訊息 "messageType" : 1, //2為群組聊天 "urlPath" : "/image.jpg", "groupName":"groupName#1", //UUID：G123 群名字 "groupAvatar":"/defaultGroup.jpg", //UUID：G123 群頭像URL } B接收的內容如下:
{ "avatar":"/default.jpg", "fromUserName":"A", "fromUUID" : "G123", //群組UUID "toUUID" : "321", //接收者UUID "contentType":2, //2 為image, "type": 4, //4 為訊息 "messageType" : 1, //2為群組聊天 "urlPath" : "/image.jpg", "groupName":"groupName#1", //UUID：G123 群名字 "groupAvatar":"/defaultGroup.jpg", //UUID：G123 群頭像URL } 以上便是在個人聊天和群組聊天中透過自定義資料結構的基本用法，雖然只說明了2種用法,分別是文本和圖片，但對於其他類型也是一樣的，只是資料不一樣而已罷了！😁
你有可能會問：欸，如果在通訊的過程中，用戶沒有在線或者沒有連接上server，哪訊息不就消息了嗎？哪用戶不就收不到訊息了？ 這個問題問的好，對於這個問題我也google很久解決方案。最後找到了解決方案，也就是將離線的消息，也就是用戶接收不到的消息用一個Container保存起來。當用戶上線時，或者重新連接到server時，就將這個消息發送 給他就好了(傳輸過程中丟失的問題，暫時不考慮蛤🤣)！這樣用戶就能在離線的情況下也能收到發送給他們的消息了！
而在這個APP裡面我是透過Redis來實現的。因為我們的消息一但發送給用戶就會馬上刪除掉了，如果用SQL的話，就頻繁的做IO，影響效能。所以這裡就使用Redis來幫我實現。而是用來Hash的數據類型來保每個用戶的離線消息！
獲取用戶離線消息
len, err := variable.RedisConnection.LLen(ctx, u.Uuid).Result() if err != nil { logx.Error("getting Redis length err ", err) return } messages, err := svcCtx.RedisClient.LRange(ctx, u.Uuid, 0, len).Result() if err != nil { w.WriteHeader(http.StatusBadRequest) logx.Errorf("get offline messages error %s ", err.Error()) return } 新增用戶離線消息
ctx := context.Background() _, err := variable.RedisConnection.RPush(ctx, mem.MemberInfo.Uuid, messageBytes).Result() if err != nil { logx.Error("offline message to redis err %s", err.Error()) } 而每條離線消息就只是把傳輸的Message 序列化成String而已，也就是每條離線消息都是String。當獲取的時候只要反序列化就可以繼續傳送了，非常的方便！
最終Demo
Source Code Frontend Backend</content></entry><entry><title>[開發者日記] 聊天通訊APP(三) - 聊天小更新</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-update/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 廢話少說直接上影片
對上一次的demo中，雖然也包含了個人聊天和群組聊天的部分，但是只支援普通文本和圖片的傳送，而這次修復了文件發送，音頻發送已經視頻發送的部分。而音頻可以直接聆聽接收到的音頻，而視頻則可以直接觀看。
除此之外還添加了系統資訊，例如：群組的建立，群組加入，群組退出並通知群組人員。
更新 - 聊天 支援文本，圖片，音頻，文件，視頻 群組系統通知 實作方法: 文本 ： 這個就比較簡單，就直接講發送文本設置到content field，透過Websocket發送即可。 圖片 ： 這個就不能直接發送了(也是可以直接發送，但是這樣content就會超大，你們猜猜用什麼方法，哈哈哈)。這邊我是透過先將圖片上傳到server，並將上傳API回傳的path，透過websocket發送。 文件，音頻，視頻：這個也是跟圖片發送相似，透過先上傳，再websocket發送。</content></entry><entry><title>[開發者日記] 聊天通訊APP(二) - Demo</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-demo/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 這篇文章主要是展示一下整個App的Demo，廢話不多說，先上視頻:
Demo說明 這個App的詳細介紹在[開發者日記] 聊天通訊APP(一)中已經有基本的介紹，這裡就不作過多的介紹了。
這裡主要是說明一下以上Demo中所展示的內容：
用戶登入和註冊 用戶資訊修改，包括上傳Avatar, Cover, 修改Status Message等 新增好友 給好友發訊息，另外一方如果上線則會即時收到訊息,否則會視為離線消息保存，待用戶上線後再發送。 建立用戶群組 加入用戶群組 查找群組 群組通訊,只有加入了群組的使用者才能收到訊息 單人聊天，其中一方為好友即可發送訊息，無須都戶為好友 發布個人動態到限時動態，只有加了好友者才能觀看 下拉刷新更新好友動態 給動態留言，並透過socket發送給特定之用戶 Backend Github
IOS Client Github</content></entry><entry><title>[開發日記] 聊天通訊APP(一) - 序章</title><url>https://ryantokmanmokmtm.github.io/post/chat-app-init/</url><categories><category>dev-diary</category><category>side-project</category></categories><tags><tag>side-project</tag></tags><content type="html"> 因為之前的OTT電影社群APP中有包含通訊的功能，但是那個App所實現的功能就只是簡單的存文字聊天而已，而那個app主要的focus點並不在通訊上，所以只有簡簡單單的實作了通訊，沒有到完整的通訊，例如：發送文字，發送圖片，發送文件等等的通訊功能。所以這次的side project所實作的app則主要focus在通訊這個點上。
這次的聊天通訊App主要會包含一下之功能
用戶登入/註冊 修改用戶資料 新增用戶為好友(聊天) 刪除用戶 新增聊天群 加入聊天群 退出聊天群 修改聊天群資訊(群主特權) 查看群資訊 查看用戶資訊 單聊 - 與已加好友通訊 群聊 - 與加入之群組通訊 語音通訊(暫定) 視頻通訊(暫定) 特別之功能 - 限時動態(24小時動態)
限時動態的新增與刪除 好友動態查看 好友動態回覆 app 截圖 階段性Demo
進度 完成
用戶登入/註冊 好友添加/移除 好友查詢 建立群組 單聊/群聊 發布/移除個人限時動態 查看好友限時動態 限時動態留言 離線消息推送(上線時推送 通訊功能
發送文字 發送圖片 發送文件(doc,pdf,ppt,etc) 發送限動回覆 待修復(發現問題)
限動留言聊天室資訊錯誤(發送方) - 已修復 refresh 功能缺失 - 已修復 限動錯誤/提醒(限動不存在,已發送留言等)</content></entry><entry><title>🇹🇼倒數</title><url>https://ryantokmanmokmtm.github.io/memories/last-moment-in-taiwan/</url><categories><category>taiwan</category></categories><tags><tag>taiwan</tag></tags><content type="html"> 在2023年1月的時候，因為已經快3年沒有回家了，所以勢必要回去一趟。所以在1月10號的時候買了回去的票。其實這次回去只要還是想看看香港的環境如何。在這個月裡面跟高中同學吃飯也了解到了許多資訊,開始考慮是否可以回來找工作，畢竟台灣找工作還是有一點難度，工作環境好像也沒有很優。除此之外，去年也有在考慮到澳洲讀研究生，如果在台灣工作可能很難達到這個目標，所以決定回來找工作，回來就只是為了存錢，沒有別的。
哪為什麼是4月份才要離開呢？因為租房子那邊，如果要不繼續租的話，需要提前一個月告知。其實離開這個決定是在回來台灣的時候思考的，也就是2月10號。考慮了大概半個月，並下定決心。因此需要在多租一個月的時間，大概就是4月初的時候離開。在離開前，我想在最後的這段時間好好享受。嗚嗚嗚
2月份 寒假過後，2月10日回來，在這之前已經決定要去台南找莉淇姐姐，雖然只去1天一夜。那就回來當天就收拾好東西，另外一天早上8點鐘就出發！根據網絡上的數據，我本來以為搭客運到台南只要4個多小時，沒想到啊，最後花了快6個小時，嗚嗚嗚。到了台南後，莉淇姐姐就開機車來載我（第一次被女生載>&lt;, 沒想到載我的會是莉淇姐姐!）。而這天的行程就是去KTV唱歌，晚上就去喝牛肉湯，順便到附近走走。吃完飯過後，就先去青年旅社check in。但是過後不知道能幹嘛，哈哈哈。最後決定到附近的桌遊店玩！玩到了關店！開勳。
另外一天，中午就去吃了壽司，這也是我第一次在台灣吃壽司欸！不錯不錯！雖然等了一段時間吃吃得到，嗚嗚嗚。過後，因為的票是下午5點鐘的車，離5點還有一點時間，所以就跟莉淇姐姐找了個咖啡廳聊天～讚！到了差不多的時間，就載我去車站離開了！回程的時間也差不多快6個小時，幹！台南很棒，下次不去了，嗚嗚嗚。
3月份 而這個月開始也是我決定好要離開的最後一個月了，而這個月主要的行程就是約人見面和吃飯！這個月我約了很多人，我也去了好幾個地方。
跟朋友們吃飯,室友，同學，學長們 都是某人約我去的，我就順便去了，我壓根不知道會有這麽多人😏！ 跟Ellie吃飯聊天的一天 其實我們已經好久沒有講過話，上次認真講話已經是大一的時候的事了，當時我也只是問問他要不要一起出來吃飯(應該會被拒絕的吧？)，沒有想到她居然答應了，嗚嗚嗚🥹，好開心，居然還能約出來。我們就去了那個大稻埕吃晚餐，還被要求拍照了。在吃飯的時候，聊天聊了很多東西，還是很快樂的🥹，畢竟我已經很久沒跟她聊過天了。再晚飯後，我們就跑去了西門町，她說要玩玩看拍貼機。我那時候也很疑惑，拍貼機到底是個啥東西。到了以後才發現原來個照相的機器，而且還能自由拿各種道具，超好玩的。可惜的是拍貼機的機制計時太快了啦，下次得提前想好動作，嗚嗚嗚。這張照片真得很值得留念，非常感謝她願意跟我拍照和吃飯🥺。我們一定會再見的。 跟妹吃飯聊天的一天 嗚嗚嗚，事隔3年我們終於見面了。事情是這樣子的，妹原本是我的直屬，但是到後面就突然要轉學，就是要轉學了的前一刻才跟我說，她就這麽默默的離開了。而我們其實也相識不到半年，我記得第一次跟她見面是在新生座談會，當時害羞的樣子，好口愛，我還記得！然後一起在宿營玩(雖然我是宿營幹部)。在宿營的時候啊，我印象很深刻，那個時候正在進行一個活動，好像是夜教，她害怕不敢玩(好像有嚇到哭哭🥹？)，還怕到不敢一個上廁所，哈哈哈哈，超級可愛。然後，最後一個活動的時候，好像是丟水器，我第一個丟的就是她，哈哈哈哈，然後她反丟我一個，這應該是我們第一次互動！而我們第二次見面是我給她家書的那個晚上，我記得那個晚上我要回家把書拿回宿舍給她(有夠重)，還一起聊天，並沒有尬聊，這應該是我們熟悉的開始了吧！隨後，我們偶爾會互相買吃的，直到2020年的聖誕節，她居然送了我聖誕節禮物(第一次收到聖誕節禮物)。然而這是我直到這一次最後一次見她🥹。在2020年上半年，我因為疫情的關係被關在了香港沒有機會見到她，直到我大二暑假，升大三的那一年，本來以為隔離完的新學期可以再次見到她的時候，她突然發訊息跟我說要轉學了，嗚嗚嗚。就這樣我們只大概只相處了半年左右。
我以為沒有機會見面的了，就算見面了也沒有很多話題，就很尷尬的那種情況(雖然我們偶爾會再網路上聊天)。沒想到2023年3月25日這天，居然真有機會再次跟她見面！哪就在離開前見一下她。見到她的時候。她變了好多變得很漂亮欸(´∀`)，我差點沒認出來捏！讓我很意外的是我們居然還有話題可以聊，還聊了很久，從7:30聊到9:00，我飯都還沒吃超過一半，哈哈哈。沒有想到啊，事隔3年，我們的感情還在欸！！！！真的超級意外的！她還請我吃飯(欸？😳我也沒有想到，很貴捏)。吃完以後，我們還在邊走邊聊，有鏡子的地方就拍一下照(笑鼠)。最後我們就去找拍貼機繼續拍照！經過上次的經驗，這次學乖了，先想動作，最後發現還是不夠快，嗚嗚嗚。雖然沒有拍很好，但是沒有關係就留個紀念！在離開前，我把在迪士尼買的禮物送給她，沒想到她這麽開勳🥰！嘿嘿嘿，她開心就好！下次回來台灣我可能真的是為了跟她見面欸，跟她一起有種說不出來的感覺🥺🥺。 其他合影
跟清大直屬吃飯的一天 在離開之前想見見我的直屬，畢竟跟他已經快2年沒見了，為什麼是2年呢？因為我上次見到她是大三上，大三下又因為遠距，她就這樣默默的畢業了。而這次前往清大，也是第一次去新竹，完全不知道怎麼去，哈哈哈。就搭客運就對了吧！！果然客運直接到清大門口。到了清大門口怎麼說呢，就很偏僻，嗯。確實很偏僻，哈哈哈。因為離約定的時間還有很久，所以打算在清大走走。不走不知道，一走嚇一跳啊，大到這樣，不看地圖肯定會迷路！我害怕迷路只能繞著外圍走。在清大裡面有很多貓咪突然出沒，好可愛欸>&lt;!。我還偷偷跑去摸了一下！然後祂就跑走了，哭哭。如果有機會，我一定要去北京清華看看做個比較！
到了約定的時間，我們可算見面，我直屬事隔2年果然沒怎麼變，還是那個樣子😂。吃飯的時候還是聊著有的沒的，本來想說這頓要AA的，結果他說不要，又是請我吃飯的節奏。他還給了我一點零食，好久沒有收到過直屬給的禮物了，好感動🥹。對上一次收到好像是大二的時候！這次因為時間有限，不能待太久，要搭車回台北，大概在18:40分的時候離開了！希望一次還有機會再約！ 去張美啊嘛農場 這裡是我一直很想去的地方，但是她在宜蘭，但是宜蘭我也才去過一次，還是有人載我去的。這次我只能靠自己，就上網找資料，就按照查到的路線走。先到台北轉運站搭1917客運到羅東轉運站，然後在轉運站轉公車1794到富興站。然而那天天氣不好，我到了的時候突然下起了大雨，可惡。說實話，這裡真的很鄉下沒什麼車，也都是山和田。然後，我便進去農場跟動物們玩！一開始看到了羊駝和鹿，羊駝的毛真好摸，軟軟的～還有隻臉黑到看到長什麼樣子，好好笑！在這裡我們可以喂他們草吃，這裡有3個關卡，我在第二關就已經把草喂光光了。本來以為後面不能再拿，沒想到只要打卡就可以拿！我在第三關那邊待比較久，因為這裡很多袋鼠，鹿和水豚。有一隻鹿看到我手上有吃的就一隻跟著我走，超可愛>&lt;。那邊還可以拿假的橘子🍊放到水豚的腦袋上，好好玩！
本來打算要離開的時候，1794居然剛好在我旁邊路過！我就馬上跑去公車站看時間表，不看不知道一看嚇一跳，下一班要下午5點，現在3點多欸&hellip;哪沒有辦法了我只能沿著這條路往回走，順便享受這段幽靜的時段，就享受吧😎。大概走到了5點，就在那個站等(其實已經走了7-8個站了)，等了大概半個小時，終於有車來了！讚！差點以為回不了家，嗚嗚嗚。 4月份離開前 因為4月1日晚上就要離開，想自己一個默默回去，就好好享受的。所以呢，在3月31號當天，早上就先跟政大的同學吃了個午餐，然後跟某人跑去動物園走最後一次。晚上的時候本來就打算在信義商區，聽聽別人唱歌，吃個晚餐就回去洗澡睡覺了。結果咧，但我回去的途中，Ellie問我還在不在那邊，而他們剛好要去那邊，我就想反正都最後一天，就陪他們瘋一下，今天打算不睡覺了！那我就坐最後一班的捷運再去到市政府跟他們去夜店Ruff(這也是我第一次去夜店，畢竟我是社恐)。就體驗了一次夜店，也是第一次喝酒（還是很難喝🤮，哈哈哈）。大家在夜店都在那邊要搖(有夠擠)，而我咧，就在那邊聽說唱flow和數拍子，笑鼠😆。我們在夜店大概到凌晨3點半左右就離開了，離開的時候剛好在下雨，然後我們就去買吃的，吃飯後就回家了🥹🥹🥹，居然在最後一天體驗了一波。
而早上跟會長約了吃永和豆漿(在大二的時候本來就很想吃，結果到最後一天才要吃，哈哈哈)，所以只能睡一下下，基本上等於沒睡！吃早餐的時候，看到菜單上有一個鹹豆漿，就很好奇，所以點了一個，結果不太好吃，哈哈哈🙃。
因為今天要退房，所以不能吃太久，只能吃一小時左右，就要回去整理行李出發去機場😞。其實還是有點不捨得😞。但還是得要離開QQ。但是在離開前，我還是想要再喝一次五十嵐的一號 無糖去冰！超好喝。在去機場前買了一杯去機場邊吃飯邊喝，很讚欸！🥹
因為今天機場特別的多人，所以花了一點時間check in，最後一步就是等我妹來(他剛好在桃園)，我真的沒有想到第一次在🇹🇼送我機的會是她😍，也沒有想到還能再見他一次🥹🥹。但是人比較多，只能跟妹告別一下下就得離開了，分別真的有夠傷心🥺。
跟妹坐最後的告別🥹🥹，謝謝她來送我，已經哭了，嗚嗚嗚。
感言 雖然我最後決定要離開台灣，我也很感謝各位願意跟我出來玩,吃飯和聊天，沒有嫌棄我，嗚嗚嗚，也感謝當初的自己有選擇來台灣讀書，才能有機會認識到他們🥹🥹🥹。在這二個月裡，看似好像都在玩，但確實是在玩，哈哈哈。雖然我來台灣已經有快5年的時候，而這段時間內，我真的沒有怎麼去玩過，想趁著還有時間來段玩耍的時間🥹🥹🥹。還好我有跟各位約和到處玩，真沒有什麼遺憾了！感謝各位出現在了我的生命裡，如果沒有了你們，就不會有現在的我🥹🥹。我們有緣再會！</content></entry><entry><title>[筆記] Binary Search 演算法</title><url>https://ryantokmanmokmtm.github.io/post/note-binarysearch/</url><categories><category>note</category><category>algorithm</category></categories><tags><tag>note</tag><tag>algorithm</tag></tags><content type="html"> Binary Search 演算法是用於在一個有序array中搜尋一個值的演算法 - TC:O(log n)。相較於Linear Search(線性搜尋) - TC:O(n),其效率大大提高。
這篇文章就主要紀錄Binary Search 的不同的搜尋方式。
在有序數組中尋找特定的值 這種問題比較簡單，就只要直接比較值是否一樣，如果一樣直接返回index。但如果是比特地值小/大，因為給定的數組是有序的，我們就可以直接將搜尋區間縮小即可(取決於比搜尋的值較大還是較小，較小往較大值的範圍趨近，否則往較小值的範圍趨近) 。
尋找特定值之代碼
func binarySearch(vector&lt;int> arr,int value){ int i = 0; int j = arr.size() - 1; while(i &lt;= j){ int mid = i + (j - i) / 2; //middle index between i and j point if(arr[mid] == value) return mid; //the value is found. else if(arr[mid] &lt; value) i = mid + 1; //the arr[mid] is less than value,search in [mid + 1,j] else if(arr[mid] > value) j = mid - 1; // the arr[mid] is greater than value,search in [i,mid - 1]; } return -1; //NOT FOUND } 在有序數組中搜尋最接近特地值的最小/最大index 在某些情況下，在特定數值中可能會出現多個一樣的特定值，找到了特別的值後直接返回可能不一樣的最小index或者最大index。哪我們就要透過以下的2種區間搜尋方式來尋找。尋找最小(收縮右邊界)，搜尋最大(收縮左邊界)。
搜尋左邊界
int binarySearch(vector&lt;int> arr,int value){ int left = 0; int right = arr.size(); // while(left &lt; right){ //not equals ,coz right = n -> ended when left == right int mid = left + (right - left) / 2; if(arr[mid] >= value) right = mid; //shrink to left else if(arr[mid] &lt; value) left = mid + 1; } return left; } 例子: [1,2,3,4,4,4,4,4,5,7]，n = 10 尋找給定數組中的value為4最小index -> ans = index : 3 step 1 : [1(i),2,3,4,4,4(mid),4,4,5,7](j) step 2 : [1(i),2,3(mid),4,4,4(j),4,4,5,7] step 4 : [1,2,3,4(i),4(mid),4(j),4,4,5,7] step 5 : [1,2,3,4(i),4(j),4,4,4,5,7] step 5 : (i == j) ended -> ans : 3 [1,2,3,4(i)(j),4,4,4,4,5,7] 搜尋右邊界
int binarySearch(vector&lt;int> arr,int value){ int left = 0; int right = arr.size(); while(left &lt; right){ int mid = left + (right - left) / 2; if(arr[mid] &lt;= value) left = mid + 1; //shrink to right else if(arr[mid] > value) right = mid; } return left - 1; } 例子: [1,2,3,4,4,4,4,4,5,7] ,n = 10 尋找給定數組中的value為4最小index -> ans = index : 7 step 1 : [1(i),2,3,4,4,4(mid),4,4,5,7](j) step 2: [1,2,3,4,4,4,4(i),4,5(mid),7](j) step 2: [1,2,3,4,4,4,4(i),4(mid),5(j),7] step 2: ended - i = j -> return i(8) - 1 = 7 [1,2,3,4,4,4,4,4,5(i)(j),7] 實際例子 Leetcode - 2187. Minimum Time to Complete Trips
You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.
Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.
You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.
example 1 Input: time = [1,2,3], totalTrips = 5 Output: 3 Explanation: - At time t = 1, the number of trips completed by each bus are [1,0,0]. The total number of trips completed is 1 + 0 + 0 = 1. - At time t = 2, the number of trips completed by each bus are [2,1,0]. The total number of trips completed is 2 + 1 + 0 = 3. - At time t = 3, the number of trips completed by each bus are [3,1,1]. The total number of trips completed is 3 + 1 + 1 = 5. So the minimum time needed for all buses to complete at least 5 trips is 3. Input: time = [2], totalTrips = 1 Output: 2 Explanation: There is only one bus, and it will complete its first trip at t = 2. So the minimum time needed to complete 1 trip is 2. 這題給定的數組中每個數字代表的數字表示ith Bus完成一次trip所要的次數，題目要我們找出所有Bus總共能完成trip time的最少次數是多少.
我們看得出來這題就是要讓我們在一個區間裡面找出一個最小能達到特定值的值，所以我們可以通過Binary Search來找。
首先我們要先定義最小值值和最大值是多少，最小值就是time數組中最小能完成一次trip的值(小於這個值就代表沒有一輛Bus可以完成啊，哈哈哈哈)。哪最大值呢？因為我們要求的最少能夠完成total trip的次數，哪我們最多是不是就是最小的哪輛Bus跑了total trip那麼多次呢？(超過了這個值就一定不會是最少了～)。
所以區間為 [low，low * total trip]，然後我們就可以從這個裡面取值，取一個符合條件切最小的值即可。
題解(Solution)
long long minimumTime(vector&lt;int>&amp; time, int totalTrips) { long long min = *min_element(time.begin(),time.end()); long long low = min, heigh = min * totalTrips; while(low &lt; heigh){ //try to tarvel by mid speed long long mid = low + (heigh - low) / 2; long long total = 0; //TODO: calculate the total time in the array for(int i = 0; i &lt; time.size();i++) total += (mid / time[i]); if(total >= totalTrips) { heigh = mid; //may be the mininum time - lock it }else { low = mid + 1; // move forward } } return heigh; } }; 參考資料 二分搜索怎么用？我又总结了套路
我写了首诗，把二分搜索算法变成了默写题</content></entry><entry><title>[筆記] KMP - Knuth-Morris-Pratt 演算法</title><url>https://ryantokmanmokmtm.github.io/post/note-kmp/</url><categories><category>note</category><category>algorithm</category></categories><tags><tag>note</tag><tag>algorithm</tag></tags><content type="html"> KMP(Knuth-Morris-Pratt) 算法是一個用於字符串匹配的一個算法，但確實有點抽象和複雜，因此打算寫一篇筆記來紀錄一下這個算法！
給定一個text以及pattern字符串，透過KMP 算法可以在text中是否存在pattern這個字符串。
返回在text中匹配pattern的index的位置。如果沒有找到則返回-1. case 1: text : aaaaaabcccd pattern : aaabc aaaaaabcccd aaabc 我們可以看到text的index = 3的位置匹配到了pattern，因此返回3 --------------------------------------------------------------- case 2: text : aaaaaabcccd pattern : aabd 可以看到text中並不存在這個pattern，因此返回-1 如果我們透過暴力解也可以找到text中是否存在pattern，但TC為O(n * m),其中n為text的長度以及m為pattern的長度。代碼如下：
int strStr(string text,string pattern) { int n = text.size(); int m = pattern.size(); for(int i = 0;i &lt; n;i++){ int j; for(j = 0;j &lt;,;j++) { if(text[i+j] != pattern[j]) break; } if(j == m) return i; } return -1; //pattern isn't exist in text } 以上這個算法，pattern對會與text進行匹配，即便是不存在的字符也會進行比較，多做了無必要的操作。例如：
text : aaabaaac pattern aaac 使用暴力解的話，pattern中並不存在b這個字符串，但還會把text的i pointer給回退回去，從下一個index 開始比較。 Step: aaabaaac aaac (不匹配) aaabaaac aaac (不匹配) aaabaaac aaac (不匹配) aaabaaac aaac (不匹配) aaabaaac aaac (匹配) -> return result 從以上例子我們看的出來，暴力解重複比較的不存在的字符數次。如果我們知道不存在的字符，是不是可以直接跳過前面的比較呢？ 例如:
aaabaaac aaac (不匹配) aaabaaac aaac (匹配) -> return result example 2: aaaaaaac (j = 3) aaac (i = 3) (不匹配) aaaaaaac (j = 4) aaac (i = 3) (不匹配) aaaaaaac (j = 5) aaac (i = 3) (不匹配) aaaaaaac (j = 6) aaac (i = 3) (不匹配) aaaaaaac (j = 7) aaac (i = 3) (不匹配) 即便是沒有匹配，text的pointer 也不會退回去，一直往前走。這就是KMP算法，透過預計算的方式，知道在不匹配的情況下，把pattern 移動到正常匹配的位置。因此直接從TC:O(n*m) 降至 O(n),但是因為要保存紀錄，因此SC：O(m)。透過空間換取時間的作法。
算法說明與設計 我們現在知道了透過KMP算法可以有效率的找出pattern是否存在於text中。前面我們有提及到KMP是透過預先計算在不同情況下有不同的移動方式，問題是我們要如何計算呢？
根據不同的字符會轉移到不同的位置，這個有沒有很像FSM(Finite State Machine/ Finite State automaton) 有限狀態機/有限狀態自動機呢？
舉個例子：pattern : ABABC 的FSM如下：
我們可以看到以上的FSM會按照不同匹配到的字符會轉到不用的State！這個FSM便是KMP算法的重點部分！
實現 要實現KMP的FSM我們透過2D Array來幫組我們。定義如下：
n = pattern的長度 c = 字符 - 假設只包含小寫英文字母共26個 states[i][c], 0 &lt; i &lt; n, 0 &lt; c &lt; 26; j 為當前State, 0 &lt; j &lt; n 例如： states[3]['a'] = 4 當前狀態為3，如果遇到'a', pattern轉移都狀態4 KMP Search 算法
int search(string text,string pattern){ int n = text.size(): int m = pattern.size(); int j = 0; for(int i = 0;i&lt;n;i++){ j = states[j][text[i]]; //to which state if(j == m) return i - m + 1; } return -1; } 哪我們要怎樣建構這個FSM的圖的？
for(int i = 0;i &lt; n; i++){ for(int c = 0; c &lt; 26;c++) states[i][c] = j; } Q： 這個j要怎麼得到呢？ 這裡會分成2種情況：
匹配的情況 匹配的情況就很容易，就一直往前走就好了j = i + 1
不匹配的情況：
不匹配的情況就比較複雜，有可能會留在原地不動，也有可能回去以前的State。 這裡我們需要一個人來幫我們處理這個問題，我們使用variable 來幫組我們，而這個variable 和我們的j有相同的前綴prefix。
例如 A -> B -> A -> B -> C x j state[j][text[c]] = state[x][text[c]];
在這個情況下state j 只有在遇到c的情況下 才會往前走，然而我們的x跟j是有著相同的prefix，也就是AB。 假設現在的是A，在不匹配的情況下，我們可以把當前的字符交給x來處理。 在State x 中 遇到A會往前走，所以j便會往後退（畢竟不能往前只能往後退了）。因為j的前綴跟x的前綴是的一樣的，所以把字符交給x來處理，可以盡可能少的回退！ 所以j最後會去到state 3
不過也有可能當前x state 是無法匹配的情況，哪只要按照state x的路回退即可（x 永遠都會尾隨 j的，而x的狀態也是在以前計算過的，所以只要按照x的紀錄表走就可以）
KMP 建立FSM
void KMP(string pattern) { int n = pattern.size(); vector&lt;vector&lt;char>> states(n,vector&lt;char>(26,0)); states[0][pattern[0]] = 1; //在狀態0的時候，如何遇到pattern[0]，會到狀態1，而其他情況會原地不動。 int x = 0; //與j 有相同前綴的變數 for (int j = 1; j &lt; n ;j++){ for(int c = 0 ; c &lt; 26 ;c++){ state[j][pattern[c]] = state[x][pattern[c]]; } //Move to next state iff text[c] == pattern[c] state[j][pattern[c]] = j + 1; x = state[x][pattern[c]; //to next x state } } KMP 算法代碼 class KMP { private: string pattern; vector&lt;vector&lt;char>> states; public: KMP(string pattern){ this->pattern = pattern; int n = pattern.size(); states = vector&lt;vector&lt;char>> (n,vector&lt;char>(26,0)); states[0][pattern[0]] = 1; //在狀態0的時候，如何遇到pattern[0]，會到狀態1，而其他情況會原地不動。 int x = 0; //與j 有相同前綴的變數 for (int j = 1; j &lt; n ;j++){ for(int c = 0 ; c &lt; 26 ;c++) state[j][pattern[c]] = state[x][pattern[c]]; //Move to next state iff text[c] == pattern[c] state[j][pattern[c]] = j + 1; x = state[x][pattern[c]; //to next x state } } int search(string text) { int n = text.size(); int m = this->pattern.size(); int j = 0; for(int i = 0;i&lt;m;i++){ j = states[j][text[i]]; if(j == m) return i - m + 1; } return -1 } } 參考資料 动态规划之 KMP 算法详解</content></entry><entry><title>2022年度總結(2023 annual summary)</title><url>https://ryantokmanmokmtm.github.io/memories/summary-of-2022/</url><categories/><tags><tag>2022</tag></tags><content type="html"> 年初 今年是我踏入大學的第四年，也就是大學生活的最後一年的最後一個學期，這個學期也沒有什麼課程可以修，主要修的是《雲端系統》, 《編譯器原理》以及《網絡安全與管理》。因為當時看到課程安排的寬鬆，因此打算抽出部分時間去實習，因此開始了尋找實現之旅。可能經歷有點少，在找實習的過程中處處碰壁，申請了眾多公司都沒有回應，只有提交了作業跟申請的Dcard Backend Intern給我發了感謝信，而且也拿到了一間Block chain的公司的面試機會，但是因為是橋生的關係再加上申請的期限已截止，只能夠面試一次，因此實習之旅宣告失敗。因此只能收拾心情迎接畢業的到來。
在這段時間裡除了找實習以外，也準備了英文的考試。本來是準備要考IELTS的，但是讀了幾周後覺得考試費用有點貴，而且我也沒有把握，因此打算轉去考TOEIC,IELTS的話需要更多的練習。在我學習了TOEIC的一個多月後，便去了國立台灣大學的考場考試。最後出來的結果也出乎我的意料拿到了660/990。這應該是我在2022年上半年唯一順利的事情了吧！嗚嗚嗚
年中 到了大四下學期末，也就是我迎接畢業的時候到了。但是因為我要延期居留證的話就必須要先找到房子，因此我開始尋找房子之旅。這段時間大概維持了1個多月，在7月尾到8月頭的時候找到一間心儀的房子，我便一大早打電話去約房東看房子，也因為當天我是第一個看房子，也成功的找到了房子了！(^▽^)
不過在這段尋覓房子的日子裡，我也沒有閒著沒有做。在6月底，也就是暑假開始的時候，打算把我的Final Year Project(畢業專題) 砍掉重構。說幹就乾。首先從後端開始重構。因為我只年初的時候學習了一個蠻好用的Framework Go-Zero, 而且我以後打算往Golang方向發展，因此選擇了使用Go-Zero重構Vapor Swift的API。除此之外，前端的部分UI大改，並添加了一些新的功能例如：文章發佈，文章留言，文章點讚，文章留言回復，個人聊天，添加好友，刪除好友以及·個人資訊等。在這段時間大概重構了約30%-40%左右。
期間也跟同學約了出去玩。這次的活動是同學安排去一個龍洞的地方，我完全對這個地方沒有什麼概念，以為只是一個海灘或者樂園的地方。意想不到的是哪裡居然是在懸崖邊上，而且玩的地方是在居然是在海里！對我一個完全不會游泳的人來說有夠可怕，因此同學就把他的浮標借我用。我本以為可以單靠這個浮標遊到對岸，但是就在這個時候發生了意外，我離對岸越來越遠，我也發現了不對勁使勁的往回游，但為時已晚,我就這樣隨波飄揚。我本來以為我會這樣一直飄到茫茫的大海上的時候，看見同學正在我的前方，還好有他，不然這輩子應該就這樣結束了。之後我就靜靜的坐在礁石上，看著他們玩耍，幫他們錄跳水的視頻，我也順便去跳了，當時心情從緊張變成爽快。當玩的差不多了，我們就去挑戰大概有3層樓高的礁石並一躍而下，當時的感覺又刺激又害怕，但還是豁出去了，硬著頭皮跳了下去。雖然過程只有幾秒鐘，但在跳完那一刻感覺一身輕，哈哈哈。在這天結束後，我也意識到了自己的不足，希望之後能加強在游泳方面的能力！
到了8月底的時候，畢業典禮的舉辦日子到來，但是其實我沒有很想去參加這個活動，畢竟我跟班上的同學也不熟悉，認識的朋友也沒去。但是為了拿回我的幾千塊畢業服的錢，只能硬著頭皮去了。更好笑的是我到了學校才發現畢業服的披肩居然沒帶，哈哈哈哈。只能拿某人的借用一下，把我自己的給他了！
年底 到了9月份，也是我正式畢業脫離學校，自己生活的日子。但是我必須要開始找工作，於是我便拿著我在8月份完成的CV去104中尋找自己喜歡的工作。但是面試依然跟找實習的情況一樣，一開始是有幾個新創公司，規模大概是幾個人到十幾個人給我面試機會，面試之後也是不知道什麼原因沒有後續，也沒有感謝信之類的(真沒有禮貌,素質不優)。在我尋找了半個月後，也迎接到了我另外一個面試，而這次面試是實體面試，與前幾次遠端面試不太一樣，十分的緊張。這次的面試是硬體公司的雲端工程師。剛開始的時候跟HR和部門主管聊得還是很開心的，到了後面與公司老闆面試的時候，大大的受到挫折(是在哭啊)，問了一堆我不擅長的問題例如有沒有玩過文件系統，文件系統有哪些等等的問題(可能是太菜不會,嗚嗚嗚)。面試結束之後，我本覺得這次面試GG了，但是沒有想到的是另一天HR卻帶電話過來說主管覺得我ok，給我發了Offer。雖然無法達到我預期的月薪，但是年薪會達到70-80萬TWD。（但是我沒有很想去~於是便在2周後拒絕了）
然後接下來還有3個面試。 一個是外商的外包公司，雖然面試只有一次，而且面試還用了英文跟主管聊了一下，還是覺得很有趣的，但是最後給我發了感謝信，可能是因為的答的題目沒有符合面試官的要求或者不適合他們公司吧。
第二個就是南科的面試，這個面試有夠麻煩，還要寫什麼性格測試的題目。在面試時候也沒有問什麼很複雜的問題，只是單純問了過去做過什麼。但是最後不知道為什麼發來了感謝信(為什麼呢？黑人問號)。
最後一個面試是一個港商做通訊整合軟體的。在面試之前要寫一份作業是關於LineBot的，並透過影片的方式Demo。在交完作業的一周後，也收到了他們的面試邀請(他們的辦公室居然在101！！)。一開始是跟HR聊了一回天，也是關於簡歷上的經歷和一些BQ問題。HR之後就到了Backend Lead和主管的面試，讓我驚訝的是居然有4個面試官(包括了主管和Team Lead)，還有一個香港的面試官。嚇得我不要不要的。。然而面試的題目主要是圍繞著我跟他們分享的Project(Movie App)和作業來問(也有蠻多問題不太知道怎麼答如: 如何檢查Bug，與他人合作等等)。面試結束後，他們說很認可我，但是因為我職業規劃的部分無法達到他們的最低要求(2年去讀研)，叫我回去想想之後HR會再聯繫我。之後的一周HR確實有聯繫我問我想的如何，但是我回復他之後HR再也沒有再回復我，之後就不了了之了(為什麼？？？)。
在這正式的4次面試後，也到了11月份，而11月份也接近了年尾，沒有什麼公司在招人，我也嘗試投遞了4-5個職位，也沒有回應，因此我便專心完善我的App,學習和刷題。直到最近改完CV後，想再嘗試一下投遞看看，看能不能年尾撿漏。於是我邊投遞了Amazing Talker的junior backend Developer的職缺。本來想先好好想想看BQ的問題再去寫面試題，沒想到天意弄人，居然在1天後說招到人了o(╥﹏╥)o。沒有辦法了，只能明年再試試了(哭啊QQ)。
在接近年末的時候，同學帶我去參與一個2022 Taipei Blockchain Week的晚會。據我所知，這個門票要200USD,同學居然跟認識人說了幾句話就進去了?這就是人脈的力量嗎?來到一個我以前不會參與的活動,也是我第一次參與，同時也要喝酒(那個酒真的苦，哈哈哈)。對應一下長期待在家裡寫程式，很少機會接觸到其他人的情況下，在這樣場面下完全不知所措，同學叫我主動去認識其他人，但我也不知道如何下口去認識&hellip;更何況我對區塊鏈這方面的知識幾乎只有皮毛，完全達不上嘴&hellip;。所以同學就帶我去認識了一下，我也感受到了社牛的威力，是我這社恐無法到達的高度。經過了這次活動也深深的意識到了自己這社交能力的不足，希望2023能加強。
總結 投簡歷前CV要跟職缺相匹配 面試前要好好準備Behavior Question, 要大致了解公司的產品和文化，如何跟自己經歷結合 不會做的題必須總結並收藏，並之後再自己完成。 2023目標 找到合適的工作 競賽積分達到1700+ 嘗試拿下Knight 段位 英文聽說讀寫好好練 多參與活動 考好雅思</content></entry><entry><title>2022年LeetCode年度總結(Summary)</title><url>https://ryantokmanmokmtm.github.io/post/lc-sumarry-of-2022/</url><categories/><tags><tag>2022</tag><tag>leetcode</tag></tags><content type="html"> Leetcode 總結 雖然在2021年暑假的這段時間有刷過一整子大概有50道題左右，但是2021年9月到12月在忙畢業專題因此就停止了。直到我12月份去找投實習MataApp 的全棧實習生時，公司給我發來了一份OA或叫面試題並要求在2小時內完成。當時就很激動的便開始寫了(實習問的都有多難),結果都的是算法題(當時一臉懵逼)。最後我花了將近5個小時的時間才完成(超時),收到了深深的打擊(收到了感謝信)，也下定了決心2022年好好認真刷題。
從2022年1月27日開始達到100道題開始至2022年12月31日達到622道。
成功獲得了2022年Leetcode年度勛章 在2021年9月的時候第一次參與雙週賽，可能是第一次玩有點緊張加上是晚上因此只解出了一道。不過在第二天的週賽很難得的AK(All Kill)了4道題(很神奇吧~可能是因為這次比較簡單)！在這之後基本上是穩定2題，偶爾3題。有時候第二題沒想到怎麼解，就只有1題(又或者是我太菜QQ)。
2022年9月18日-Leetcode 第311場周賽 2022年獲得勛章 每日一題月勛章 * 8 (5月 - 12月) 學習計劃 * 5 2023年目標 掌握Dynamic Programming 掌握Graph 嘗試Hard 題 競賽1700+</content></entry><entry><title>簡歷模板 Resume Template</title><url>https://ryantokmanmokmtm.github.io/resources/resume-template/</url><categories><category>resume</category><category>resources</category></categories><tags/><content type="html"> 中英文簡歷模板 English CV Template(docx) 中文模板(docx) 資料來源 DBC</content></entry><entry><title>透過Kops工具在AWS中部署K8S集群</title><url>https://ryantokmanmokmtm.github.io/post/kuberneters-on-aws/</url><categories><category>cloud native</category></categories><tags><tag>tutorial</tag></tags><content type="html"> 這篇文章主要是講述如何在AWS雲服務中部署Kubernetes集群 首先，我們需要準備使用一下工具進行設置
KOps - 一個能讓我們輕鬆無痛部署Kubernetes到任何雲服務的工具，可以想象為集群的kubectl AWS IAM - 申請一個能讓Kops存取權限的賬號 AWS S3 Bucket - 用來作為存取Kubernets資料的資料庫 AWS Route53 - 用於使用自定義Domain Name 並連接到Master Node中 GoDady - 作為DNS 服務供應商 前置工作 在電腦中安裝KOps工具用於幫助我們部署集群 想要了解更多關於KOps的讀者，可以參閱kOps-Kubernetes Operations
安裝: Linux
curl -Lo kops https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)/kops-linux-amd64 chmod +x kops sudo mv kops /usr/local/bin/kops Macos
curl -Lo kops https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)/kops-darwin-amd64 chmod +x kops sudo mv kops /usr/local/bin/kops 或者使用 Homebrew 安裝
brew update &amp;&amp; brew install kops Window
到KOps的github中的Release中下載kops-windows-amd64 重新命名為kOps，並設置為環境變數 安裝AWS Cli 到AWS 的官方網站中直接下載安裝即可 AWS CLI
設置IAM 賬號用於kOps 存取 AWS資源 如果還沒有AWS 賬號，可以先去申請一個再完成下面的步驟
透過UI設置
搜尋IAM,在Access management中選擇Users。 如下圖所示 新增用戶Add users,輸入使用者賬號並選擇Access key - Programmatic access。如下圖所示 3.選擇Attact existing policies directly並選擇以下的Policies
AmazonEC2FullAccess AmazonRoute53FullAccess AmazonS3FullAccess IAMFullAccess AmazonVPCFullAccess AmazonSQSFullAccess AmazonEventBridgeFullAccess 新增使用者 記錄Access key ID和Secret access key 打開Terminal設置AWS Cli的Configure中的存取賬號(KOps 會使用這組Token操作AWS)
aws configure
輸入剛才申請賬號的Access key ID(因我已經設置過了，就不重複設置了) 輸入剛才申請賬號的Secret access key(因我已經設置過了，就不重複設置了) Default region name 可以不輸入，使用DEFAULT即可 Default output format 可以不輸入 ，使用DEFAULT即可 透過AWS Cli 設置
aws iam create-group --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonEC2FullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonRoute53FullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/IAMFullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonVPCFullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonSQSFullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonEventBridgeFullAccess --group-name kops aws iam create-user --user-name kops aws iam add-user-to-group --user-name kops --group-name kops aws iam create-access-key --user-name kops 記得要設置AWS
使用AWS Route53 設置DNS 故博主已在GoDady購買Domain Name - 所以以projectdomaindns.com
透過UI建立aws route53
搜尋Route53
新增Domain Name - 注意:Domain Name 必須要跟註冊的一樣！ 進入到建立好的Host,將裡面的Name Server(NS)到DNS 服務商中設定(以GoDady為例) Godady DNS設置跟Route53 NS一樣
透過Terminal建立 aws route53
注意:Domain Name 必須要跟註冊的一樣！
ID=$(uuidgen) &amp;&amp; aws route53 create-hosted-zone --name projectdomaindns.com --caller-reference $ID | jq .DelegationSet.NameServers 設置完畢後，會回傳一組NS,到DNS 供應商中設置為這組NS即可
使用AWS S3 用於保存Cluster資料 博主設置的地區是新加坡 - Asia Pacific (Singapore) ap-southeast-1 透過UI建立aws s3
搜尋aws S3 建立Bucket - Bucket名字必須是唯一的 要注意的是Region以及Block Public Access settings for this bucket
Region 要記得你設置的區域，建議跟部署集群地區一致~ Block Public Access 設置為public~ 透過Terminal建立 aws s3
aws s3api create-bucket --bucket k8s-example \ --region ap-southeast-1 \ --create-bucket-configuration LocationConstraint=ap-southeast-1 &ndash;create-bucket-configuration LocationConstraint=ap-southeast-1 這個設定對於us-east-1地區以外的都必須要加上，不然會出錯
以上都為準備階段，所要完成的工作，接下來就是重頭戲了！
透過kOps新增Cluster - 還沒正在開始建立(設定而已啦~) 先建立SSH-key - 之後登入到Cluster會用到這組key
ssh-keygen -f .ssh/id_rsa
kops create cluster \ --name=projectdomain.com \ --cloud=aws \ --zones= ap-southeast-1a\ --state=s3://k8s-example --master-size=t2.micro --node-size=t2.micro --node-count= --dns-zone=projectdomain.com name - K8S集群的名字 cloud - 雲服務商 zones - Nodes要部署的地區，而博主的設置的地區是ap-southeast-1,該對應的地區Code就是ap-southeast-1a master-size - master node的機器類型(可參考AWS) node-size - 一般node的機器的類型(可以參考AWS) node-count - 一般node的數量 state - 存放S3的Bucket 以上指令運行完後的結果如下:
如果設置完，需要修改可以使用 kops edit
建立Cluster 如果設定都沒有問題，就可以開始建立咯~ (有點久就是了 哈哈哈哈哈) 複製Finally configure your cluster with:後面的指令，加上--state=${s3 bucket url}
kops update cluster --name projectdomaindns.com --yes --admin --state=s3://k8s-bucket-demo 然後就是漫長的等待&hellip;&hellip; 5 - 20分鐘左右. 可以透過一下指令檢查是否完成部署，使用--wait 10m 10分鐘內會不斷的檢測~
kops validate cluster --wait 10m --state=${S3} 完成部署後，會顯示ready的狀態
透過kubectl get nodes也可以看到3個nodes,他們的Name就會是AWS EC2主機的名字咯~ 如果我們會看一下AWS上面的狀態，會發現EC2多了3台運行中的機器 Route53以及S3中也會有新的資料哦~ 如果讀書讀者的話,會發現api.projectdomaindns.com所導向的IP正是Master Node的public IP! 也就是說我們可以透過這個url直接存取Master Node！
AWS S3中也多出了Cluster的資料呢~ 使用Cluster 現在我們嘗試一下部署簡單的應用到這集群上看看能不能成功運行！
如果讀者還沒有學過K8S基礎，建議去K8S官網玩玩看教學！
這是我準備的簡單WebServer 應用,裡面只包含了一個API，透過/ping,server會回傳pong
// deploy.ymlapiVersion:apps/v1kind:Deploymentmetadata:name:demo-deployspec:selector:matchLabels:app:web-serverreplicas:3template:metadata:name:web-server-podlabels:app:web-serverspec:containers:- name:api-serverimage:jacksontmm/demo-server:v1ports:- containerPort:8080~ 上面這份config簡單來說就是會有3個一模一樣的pod,但是IP不同
建立Deployment物件
kubectl create -f deploy.yaml 透過kubectl get pods指令會發現有3個pod正在運行 透過kubectl get deploy指令會發現有一個deployment，也就是我們剛才所建立的deployment 物件 我們是沒有辦法直接存取Cluster內部的Pod的，所以必須先透過Service 物件來幫助我們，將他們expose出來，才能存取
以下指令會將我們Deployment物件的8080,透過與service expose出去
kubectl expose deploy demo-deploy --name=deploy-svc --type=NodePort --port=8080 執行kubectl get service會發現多了一個service的Name為deploy-svc，也就是我們剛才所建立的！ 現在我們只需要透過expose 的port,port:31176,就可以存取了！
注意：要先去將Master node(EC2)的31176 port 對外開放哦~ 不然會進不去 哈哈哈 - 設置secret group 的inbound 即可
打開瀏覽器輸入http://13.212.80.234:31176/ping,就會看到pong回傳回來!
13.212.80.234為Master node 的public ip
太棒了！恭喜我們成功上雲٩(˃̶͈̀௰˂̶͈́)و
如果想要刪除cluster的話,使用以下指令就可以把所有東西移除掉了唷(EC2,S3)！
kops delete cluster --name=${cluster name}--state=s3://${s3 name} --yes 參考資料 Kubernetes 30天學習筆記 kOps - Kubernetes Operations Manage Kubernetes Clusters on AWS Using Kops</content></entry><entry><title>[Side-Project] Movie App</title><url>https://ryantokmanmokmtm.github.io/project/movie-app/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> Movie App - Frontend
Movie App - Backend
簡介 開發這個App的目的主要是為了解決在搜尋電影OTT資源以及電影內容討論分散在多個不同平台等問題，如:搜尋到的資源是無效/不合法的，花費大量時間在搜尋上等等&hellip;。因此這個App主要分成2個組成部分，分別是電影資訊搜尋獲取OTT資源，並整合不同OTT平台的電影資源，供用戶選擇合法資源，並過濾無效資源以及電影分享社群，供用戶在觀看完電影後，直接在App中發佈相關文章以分享給其他用戶，而無需在不同平台發佈。
主要功能 用戶基本功能(登入/登出/修改資料等) 提供海量電影資源供用戶查閱(約100w+) 提供用戶點讚電影以及收藏電影 提供有效電影的OTT資源(如:Netfilx,Disney+,YoutubeTV等) 提供社群平台讓用戶發佈電影文章，對其他用戶的文章點讚,留言,回復留言等社群功能 提供用戶瀏覽其他用戶個人資訊(如:發佈之文章,點讚的電影,以及個人收藏的專輯) 用戶可與相互為朋友的用戶進行簡單文字交流,分享更多資訊 分享App文章到社交媒體(如: Instagram) 技術棧/工具 SwiftUI UIKit Comebine Go-Zero MySQL Gorm Docker Websocket CI/CD Pipeline (Github Action + AWS CodeDeploy) TMDB - 電影數據來源處 K8S AWS App 測試影片 階段性測試
最新版本</content></entry><entry><title>[總結]Leetcode 週賽第319場復盤總結</title><url>https://ryantokmanmokmtm.github.io/post/leetcode-contest319/</url><categories><category>summary</category></categories><tags/><content type="html"> 今日為2022年11月13日(週日) - Leetcode 週賽第319場 目前參加週賽主要的目的是學習跟訓練，所有當前主要focus在解Easy 跟 Medium的題目，Hard的題目暫且先跳過了
週賽題目如下: Convert the Temperature - Easy Number of Subarrays With LCM Equal to K - Medium Minimum Number of Operations to Sort a Binary Tree by Level - Medium Convert the Temperature - Easy You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.
You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].
Return the array ans. Answers within 105 of the actual answer will be accepted.
Example
Input: celsius = 36.50 Output: [309.65000,97.70000] Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70. Input: celsius = 122.11 Output: [395.26000,251.79800] Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798. 解題思路 這題沒有什麼難度呢，就直接代題目給的公式就可以AC了
class Solution { public: vector&lt;double> convertTemperature(double celsius) { double kelvin = celsius + 273.15; double Fahrenheit = celsius * 1.80 + 32; return {kelvin,Fahrenheit}; } }; Number of Subarrays With LCM Equal to K - Medium Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray&rsquo;s elements is k.
A subarray is a contiguous non-empty sequence of elements within an array.
The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.
Example
Input: nums = [3,6,2,7,1], k = 6 Output: 4 Explanation: The subarrays of nums where 6 is the least common multiple of all the subarray's elements are: - [3,6,2,7,1] - [3,6,2,7,1] - [3,6,2,7,1] - [3,6,2,7,1] Input: nums = [3], k = 2 Output: 0 Explanation: There are no subarrays of nums where 2 is the least common multiple of all the subarray's elements. 解題思路 這一題要注意的是LCM的計算以及subarry的定義
Subarray 是 在array中連續的一組array，跟subsequence不一樣呢~
這題的重點是要關注subarray的部分，也就是我們要知道[i : n-1] where i = 0 to n - 1的LCM是否與K相等。 所以我們要一個一個subarray的去找從size為1 擴展至n - i - 1, 檢查擴展的過程中是否存在LCM與K相等。
注：因為LCM的算計過程中會進行multipy,所以不能使用sign int, 需使用unsign int。否者會overflow.
class Solution { public: int subarrayLCM(vector&lt;int>&amp; nums, int k) { int ans = 0; for(int i = 0;i&lt;nums.size();i++){ unsigned int curLCM = 1; for(int j = i;j&lt;nums.size();j++){ curLCM = lcm(curLCM,nums[j]); //[for i to n] if(curLCM == k) ans++; } } return ans; } }; Minimum Number of Operations to Sort a Binary Tree by Level - Medium You are given the root of a binary tree with unique values.
In one operation, you can choose any two nodes at the same level and swap their values.
Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.
The level of a node is the number of edges along the path between it and the root node.
Example
1 / \ 4 3 / \ / \ 7 6 8 5 / / 9 10 Input: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10] Output: 3 Explanation: - Swap 4 and 3. The 2nd level becomes [3,4]. - Swap 7 and 5. The 3rd level becomes [5,6,8,7]. - Swap 8 and 7. The 3rd level becomes [5,6,7,8]. We used 3 operations so return 3. It can be proven that 3 is the minimum number of operations needed. 1 / \ 3 2 / \ / \ 7 6 5 4 Input: root = [1,3,2,7,6,5,4] Output: 3 Explanation: - Swap 3 and 2. The 2nd level becomes [2,3]. - Swap 7 and 4. The 3rd level becomes [4,6,5,7]. - Swap 6 and 5. The 3rd level becomes [4,5,6,7]. We used 3 operations so return 3. It can be proven that 3 is the minimum number of operations needed. 1 / \ 2 3 / \ / 4 5 6 Input: root = [1,2,3,4,5,6] Output: 0 Explanation: Each level is already sorted in increasing order so return 0. 解題思路(這題查的資料) 這題主要的難點是當我們拿到了每個level的Node的數時候，我們要怎麼得知最少的swap到正確的位置是多少呢？？
假設我們現在有下面的這個情況
2 - 4 - 1 - 5 我們要透過最少的swap的次數，使之變為有序的。 哪應該要怎麼解呢？
我們是不是只需要將他們移動到他們各自對應的正確的index就可以了呢?
比如: 2 - 4 - 1 - 5 這裡的1應該在index 0的位置,2應該在index 1 的位置,如此類推。最後就會得出 1 - 2 - 4 -5
由此可見，我們只需要將錯誤的index 與 正確的index連接在一起(也就是Swap) ，哪我們只要知道一共有多少條node連接到同一條edge上 , 哪我們就知道swap了多少回了。
例如： 7 6 4 5 => 7(移動到5的位置) -> 5(移動到6的位置) -> 6(移動到4的位置) -> 4代表了 swap(7,5) + swap(5,6) + swap(6,4) swap(7,5) => 5 6 4 7 swap(5,6) => 6 5 4 7 swap(6,4) => 4 5 6 7
只要對每層level建立一個directed graph就可以知道最少swap了多少次。
輔助函數 -> 因為我們計算的是edge的數目,而我們遍歷了node的數目，node = edge + 1,所以需要-1
int helper(vector&lt;int>&amp; res){ if(res.size() &lt;= 1) return 0; //no need int swapTime = 0; vector&lt;pair&lt;int,int>> g; for(int i = 0;i&lt;res.size();i++){ //building the graph //O(res.size()) g.push_back({res[i],i}); } sort(g.begin(),g.end());//sort it by value not index vector&lt;int> nodeVisited(res.size()); for(int i = 0;i&lt;res.size();i++){ //if current value need to keep in current index -> continue or is already swapped if(nodeVisited[i] || g[i].second == i) continue; int count = 0; int start = i; while(!nodeVisited[start]){ nodeVisited[start] = true; start = g[start].second; count++; } if(count > 1) swapTime += count - 1; } return swapTime; } 遍歷每一個Level，透過BFS即可
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minimumOperations(TreeNode* root) { if(root == nullptr) return 0; queue&lt;TreeNode*> q; q.push(root); int minTime = 0; while(!q.empty()){ int size = q.size(); vector&lt;int> res; for(int i = 0;i&lt;size;i++){ auto front = q.front();q.pop(); res.push_back(front->val); if(front->left != nullptr) q.push(front->left); if(front->right != nullptr) q.push(front->right); } minTime += helper(res); } return minTime; } int helper(vector&lt;int>&amp; res){ if(res.size() &lt;= 1) return 0; //no need int swapTime = 0; vector&lt;pair&lt;int,int>> g; for(int i = 0;i&lt;res.size();i++){ //building the graph //O(res.size()) g.push_back({res[i],i}); } sort(g.begin(),g.end());//sort it by value not index vector&lt;int> nodeVisited(res.size()); for(int i = 0;i&lt;res.size();i++){ //if current value need to keep in current index -> continue or is already swapped if(nodeVisited[i] || g[i].second == i) continue; int count = 0; int start = i; while(!nodeVisited[start]){ nodeVisited[start] = true; start = g[start].second; count++; } if(count > 1) swapTime += count - 1; } return swapTime; } }; 總結 對於Graph的處理以及思路需要加強改善, 特別是需要自己建立Graph的題目。</content></entry><entry><title>[Leetcode] Maximum Length of Repeated Subarray(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode718/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag></tags><content type="html"> LeetCode 718 - Maximum Length of Repeated Subarray Given two integer arrays ``nums1andnums2`, return the maximum length of a subarray that appears in both arrays.
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3,2,1]. Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0] Output: 5 How can we solve this problem? 這題要我們找出2個array中最長的相同subarray。這題有點類似於最長公共子序列,但是不同的是子序列不一樣的連續的,而subarray是必須要連續的。哪我們只需要改寫一下最長公共子序列,我們只需要更新相等的元素即可。其餘的都不需要關心。
Solution: class Solution { vector&lt;vector&lt;int>> dp; public: int findLength(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) { /* [0,1,1,1,1] [1,0,1,0,1] we need to know where the max length between num 1 and num 2 suppose i = 0,j = 0 dp[0][0] = the longest length of subarray in num2[i:n-1]num2[j:m-1] */ int n = nums1.size(); int m = nums2.size(); int res = 0; dp = vector&lt;vector&lt;int>>(n+1,vector&lt;int>(m+1,0)); for(int i = 1;i&lt;n+1;i++){ for(int j = 1; j &lt;m+1;j++){ if(nums1[i-1] == nums2[j-1]){ dp[i][j] = 1 + dp[i-1][j-1]; } res = max(dp[i][j],res); } } return res; } };</content></entry><entry><title>[Leetcode] Find Duplicate File in System(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode609/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>map</tag></tags><content type="html"> LeetCode 42 - Trapping Rain Water Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.
A group of duplicate files consists of at least two files that have the same content.
A single directory info string in the input list has the following format:
"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory "root/d1/d2/.../dm". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.
The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:
&ldquo;directory_path/file_name.txt&rdquo; Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"] Output: [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]] Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)"] Output: [["root/a/2.txt","root/c/d/4.txt"],["root/a/1.txt","root/c/3.txt"]] How can we solve this problem? 這題是也什麼難度，只要透過字串分隔和透過Map保存相同內容(Content)的路徑即可。
Solution: class Solution { public: vector&lt;vector&lt;string>> findDuplicate(vector&lt;string>&amp; paths) { //format : directory fileName(content) fileName2(contnet) //abcd : "root/a/1.txt","root/c 3.txt(abcd)" unordered_map&lt;string,vector&lt;string>> m; vector&lt;vector&lt;string>> res; for(auto &amp;str : paths){ //find root path int i = 0; int n = str.length(); while(i &lt; n){ if(str[i] == ' ')break; i++; } string root = str.substr(0,i); i++; //after sapce vector&lt;string> files; while(i &lt; n){ //find file name //find file content string fileName,fileContent; while(str[i] != '('){ fileName += str[i++]; } // cout &lt;&lt; fileName &lt;&lt; " "; i++; //skip ( while(str[i] != ')') fileContent += str[i++]; // cout &lt;&lt; fileContent &lt;&lt; endl; i+=2; //skip and move to next file m[fileContent].push_back(root + "/" + fileName); } } for(auto &amp;ele : m){ if(ele.second.size() > 1) res.push_back(ele.second); } return res; } };</content></entry><entry><title>Leetcode Weekly Contest 331(第一次參加競賽)</title><url>https://ryantokmanmokmtm.github.io/post/leetcodeweeklycontest331/</url><categories><category>leetcode contest</category></categories><tags/><content type="html"> 今天是我第一次參加Leetcode 雙週賽，所以想記錄一下今天的競賽題目。希望能透過博客來記錄自己的競賽狀況。
本週AC題數為:4/4
題目 2413. Smallest Even Multiple(EASY) - AC Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.
Example Input: n = 5 Output: 10 Explanation: The smallest multiple of both 5 and 2 is 10. Input: n = 6 Output: 6 Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself. Solution 這題主要是讓我們返回一個最小的整數是可以同時被n和2整除。哪解這題的思路也很簡單，就是如果n可以被2整除，就直接放回n否者就返回2 * n即可。
class Solution { public: int smallestEvenMultiple(int n) { return n % 2 == 0 ? n : 2 * n; } }; 2414. Length of the Longest Alphabetical Continuous Substring(Medium) - AC An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string "abcdefghijklmnopqrstuvwxyz".
For example, "abc" is an alphabetical continuous string, while "acb" and "za" are not. Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring. Example Input: s = "abacaba" Output: 2 Explanation: There are 4 distinct continuous substrings: "a", "b", "c" and "ab". "ab" is the longest continuous substring. Input: s = "abcde" Output: 5 Explanation: "abcde" is the longest continuous substring. Solution 這題主要是要讓我們在給定字串找到最長的按字母順序的長度(a之後一定是b,ac並不成立按字母順序)。我們可以透過Sliding Window的方式來幫助我們找到最長的。
如果當前window 長度為 0,向右滑動(往右增長) 如果當前字符為前面字符的ASCII CODE + 1，則符合按字母順序， 向右滑動(往右增長)。並更新最大值。 如果當前字符不為前面字符的ASCII CODE + 1，重置Window長度,並將window最左邊設置為當前位置。 class Solution { public: int longestContinuousSubstring(string s) { //longest continuous substring. //consecutive letters int res = 1; //at least one //continuous int left = 0; int right = 0; int i = 0; int n = s.length(); while(right &lt; n){ if(left == right) right++; else if((s[right] - 'a') == (s[right - 1] - 'a') + 1 ){ //check current right and previous right ++; res = max(res,right - left); }else left = right; //reset window } return res; } }; 2415. Reverse Odd Levels of Binary Tree(Medium) - AC Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.
For example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2]. Return the root of the reversed tree. A binary tree is perfect if all parent nodes have two children and all leaves are on the same level.
The level of a node is the number of edges along the path between it and the root node.
Example Input: root = [2,3,5,8,13,21,34] Output: [2,5,3,8,13,21,34] Explanation: The tree has only one odd level. The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3. Input: root = [7,13,11] Output: [7,11,13] Explanation: The nodes at level 1 are 13, 11, which are reversed and become 11, 13. Solution 這道題就是要讓我們翻轉Complete Binary Tree中，奇數層的Node。我們可以透過BFS來解題，會比較簡單，因為BFS可以很清楚的知道當前遍歷的是那一層。只要層數為奇數我們就做*數值交換(Swap)*即可。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* reverseOddLevels(TreeNode* root) { if(!root) return nullptr; queue&lt;TreeNode*> q; q.push(root); int depth = -1; while(!q.empty()){ int size = q.size(); depth++; vector&lt;TreeNode*> temp; for(int i = 0;i&lt;size;i++){ auto front = q.front();q.pop(); if(front->left) q.push(front->left); if(front->right) q.push(front->right); if((depth + 1) % 2 == 0) temp.push_back(front); } if((depth + 1) % 2 == 0){ int left = 0; int right = temp.size() - 1; while(left &lt; right){ swap(temp[left++]->val,temp[right--]->val); } } } // for(int i = 0;i&lt;node.size();i++){ // int left = 0; // int right = node[i].size() - 1; // while(left &lt; right){ // swap(node[i][left++]->val,node[i][right--]->val); // } // } return root; } }; 2416. Sum of Prefix Scores of Strings(Hard) - AC You are given an array words of size n consisting of non-empty strings.
We define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].
For example, if words = ["a", "ab", "abc", "cab"], then the score of &ldquo;ab&rdquo; is 2, since &ldquo;ab&rdquo; is a prefix of both "ab" and "abc". Return an array answer of size n where answer[i]s is the sum of scores of every non-empty prefix of words[i]. Note that a string is considered as a prefix of itself.
Example Input: words = ["abc","ab","bc","b"] Output: [5,4,3,2] Explanation: The answer for each string is the following: - "abc" has 3 prefixes: "a", "ab", and "abc". - There are 2 strings with the prefix "a", 2 strings with the prefix "ab", and 1 string with the prefix "abc". The total is answer[0] = 2 + 2 + 1 = 5. - "ab" has 2 prefixes: "a" and "ab". - There are 2 strings with the prefix "a", and 2 strings with the prefix "ab". The total is answer[1] = 2 + 2 = 4. - "bc" has 2 prefixes: "b" and "bc". - There are 2 strings with the prefix "b", and 1 string with the prefix "bc". The total is answer[2] = 2 + 1 = 3. - "b" has 1 prefix: "b". - There are 2 strings with the prefix "b". The total is answer[3] = 2. Input: words = ["abcd"] Output: [4] Explanation: "abcd" has 4 prefixes: "a", "ab", "abc", and "abcd". Each prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4. Solution 這題有一點難理解，就是要我們計算以words[i] 為prefix(以words[i][0...j]為前綴)的字符串有多少個。例如abc,他的prefix會有3個[a,ab,abc]。我們只要知道words中有哪些字符串以a、ab和abc為prefix，他們的個數加總起來便是words[i]的答案。
哪我們要怎麼知道有哪些字符串包含這些前綴呢？我們可以透過字典樹/前綴樹(Tire Tree)。
按著Words List 建立Tire Tree，並為每個Node設置一個Counter，用於計數有多少個字符有相同的prefix。 按著Words 遍歷Tire Tree並將經過的Tree Node的Counter的數值累加起來，便會得到words[i]的分數。 class TrieTree { public: TrieTree(){ children = vector&lt;TrieTree*>(26,nullptr); } int samePrefixCount = 0;//how many string have the same prefix vector&lt;TrieTree*> children; }; class Solution { public: vector&lt;int> sumPrefixScores(vector&lt;string>&amp; words) { TrieTree *root = new TrieTree(); for(int i = 0;i&lt;words.size();i++){ BuildTree(words[i],root); } vector&lt;int> res(words.size(),0); for(int i = 0;i&lt;words.size();i++){ res[i] = countPrefixSum(words[i],root); } return res; } void BuildTree(string&amp; str, TrieTree *root){ TrieTree *head = root; for(int i = 0;i&lt;str.length();i++){ if(head->children[str[i] - 'a'] == nullptr) head->children[str[i] - 'a'] = new TrieTree(); head = head->children[str[i] - 'a']; head->samePrefixCount++; } } int countPrefixSum(string&amp; str, TrieTree *root){ int count = 0; TrieTree *head = root; for(int i = 0;i&lt;str.length();i++){ head = head->children[str[i] - 'a']; count += head-> samePrefixCount; } return count; } }; 總結 今天這4道題可能是比較簡單，所以才能順利的做完。接下來每週都會去參加LeetCode競賽，不論有沒有做出來都會寫一篇文章做總結。希望自己能透過競賽知道自己的不足之處！</content></entry><entry><title>[Leetcode] Trapping Rain Water(Hard)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode42/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag></tags><content type="html"> LeetCode 42 - Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. example
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Input: height = [4,2,0,3,2,5] Output: 9 How can we solve this problem? 這題是給定一個array代表著高度，問我們一共可以裝多少水。這題的解題思路，假設當前是i,那我當前這個i是否可以裝水呢？我們是是不是要知道i的左手邊的最高的柱子(x)和最右手邊的最高的柱子(y)，那跟柱子比較矮而且是不是大於現在這個i。假設IFF x &lt; y &amp;&amp; x > i,哪i可以裝的水就會是x - i那麼多。所以說，我們必須要知道當前i的左邊最高和i的右邊最高是多少。哪要怎麼做呢？我們可以透過預處理的方式，預先計算左手邊(i之前)最大值以及右手邊(i之後)的最大值，然後在根據以上的方法即可解出答案。
Solution: class Solution { public: int trap(vector&lt;int>&amp; height) { int n = height.size(); /* how can we solve this problem? [i] can trap water ?? it determin the min(maxinum number [0..i] ,maxinum number [i...n-1]) but the problem is how can we know what is the maxinum height before i?[0...i] //maybe itself is the local maxinum height and how can we know what is the maxinum height after i ?// /maybe itself is the local maxinum height pre-calculating the left and the right?? */ vector&lt;int> leftHeight(n,0); vector&lt;int> rightHeight(n,0); //init case ->the first height is the maxinum heigh of left height //init case ->the last height is the maxinum heigh of right height leftHeight[0] = height[0]; rightHeight[n-1] = height[n-1]; //precalculating step for(int i = 1;i&lt;n;i++) leftHeight[i] = max(leftHeight[i-1],height[i]); //current i is the heigher one ? for(int i = n-2;i >= 0;i--) rightHeight[i] = max(rightHeight[i+1],height[i]); int res = 0; //calculating trapping water for(int i = 1;i&lt;n-1;i++){ //the first height and the last height can't trap any water res += min(leftHeight[i],rightHeight[i]) - height[i]; } return res; } };</content></entry><entry><title>[Leetcode] Palindrome Pairs(Hard)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode336/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>tire Tree</tag><tag>string</tag></tags><content type="html"> LeetCode 336 - Palindrome Pairs Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.
example
Input: words = ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"] Input: words = ["bat","tab","cat"] Output: [[0,1],[1,0]] Explanation: The palindromes are ["battab","tabbat"] How can we solve this problem? 在解這題之前我們先要知道有哪些情況是成立Palindrome。
Case 1 ：2個字符串為反向字符串 - "abcd""dcba" => "abcd|dcba" Case 2 ：2個字符前中一個與另一個字符串的前面部分為Palindrome,剩餘未能匹配的部分也是一個 Palindrome - "abb""hcch|bba" => abbhc|chbba Case 3 : 2個字符的其中一個為空字符，而另外一個自己就是一個Palindrome - """aba" => "aba" 哪我們怎麼才能知道哪些字符串是某字符串的Palindrome呢？
我們可以透過Trie Tree(前綴樹)來幫助進行我們匹配。
注:建立樹時必須是反向的方式插入(abcd => dbca),這樣當我們進行搜尋或者匹配的時候，才知道哪些與當前字符串匹配
為了能匹配出Case 2，每遍歷一個Node,都需要檢查[0..j]是否為Palindrome，如果是插入當前字符串的index到當前的Node中，以便之後的匹配步驟。另外對於空字符串而已，需要插入至root的Node。(任何本來就是一個Palindrome的字符串也會出現在root的list(保存的是index)中："","aba","a","bbbabbb")
建立完成以後，便可以進行匹配。當遍歷到的Node是一個完整的字符串而且Index不等於自己以及剩餘的部分是一個Palindrome，也就是匹配到了我們的Case2，並加入至result。重複這個過程直到，遍歷完當前字符串。但是遍歷完當前字符串，並不代表沒有其他字符串可以組成Palindrome。之前建立Tree的時候，在這個Node中插入[0...j(當前的node)]字符串為Palindrome的index list,就可以直接使用了。只要index不等於當前的字符串的index直接加入到result即可。(匹配Case 2或者Case 3(如果是root的話)`)。
透過以上這些步驟就可以解決這一題(有點難度&hellip;哈哈哈)
Solution: class TrieNode { public: TrieNode(){ children = vector&lt;TrieNode*>(26,nullptr); } int index = -1; //if this variable is not -1 ,it means a word vector&lt;TrieNode*> children; //coz we are matched the prevous character a(xxx)|(rest of string is palindrome too)|(xxx) vector&lt;int> restPalindromeIndex; }; class Solution { public: vector&lt;vector&lt;int>> palindromePairs(vector&lt;string>&amp; words) { //distinct indices (i, j) TrieNode* root = new TrieNode(); for(int i = 0;i&lt;words.size();i++) BuildTrieTree(root,words[i],i); vector&lt;vector&lt;int>> res; //seach the palindrome for(int i = 0;i&lt;words.size();i++) search(res,i,words,root); return res; } void BuildTrieTree(TrieNode* root,string&amp; str,int wordIndex){ //insert the string in reverse order TrieNode* head = root; for(int i = str.length()-1;i>=0;i--){ if(isPalindrome(str,0,i)) head->restPalindromeIndex.push_back(wordIndex); //[0..j] is a Palindrome? record the index if(head->children[str[i] - 'a'] == nullptr) head->children[str[i] - 'a'] = new TrieNode(); head = head->children[str[i] - 'a']; } head->index = wordIndex; //after the string is inserted to the tree ,set the index head->restPalindromeIndex.push_back(wordIndex);//if empty string } void search(vector&lt;vector&lt;int>>&amp; res,int wordIdx,vector&lt;string>&amp; words,TrieNode* root){ if(!root) return; TrieNode* head = root; for(int i = 0;i&lt;words[wordIdx].length() &amp;&amp; head;i++){ //find the word if(head->index != -1 &amp;&amp; head->index != wordIdx &amp;&amp; isPalindrome(words[wordIdx],i,words[wordIdx].length() - 1)) res.push_back({wordIdx,head->index}); head = head->children[words[wordIdx][i] - 'a']; } //if there is no any character ,return it if(!head) return; //we need to add all string that is palindrome from [head(character to 0] //for example : str is aab and any string has same baa at the back //aab|(if sub string is palindrome with postfix (baa)) //if can make as a Palindrome Pairs //aab|(aba)baa => aaba b abaa => YES //aab|(cbc)baa => aabc b cbaa => YES //aab|(abba)baa => aabab babaa => YES for(auto index : head->restPalindromeIndex) if(index != wordIdx) res.push_back({wordIdx,index}); //distinct i and j } bool isPalindrome(string&amp; str,int l, int r){ while(l &lt; r &amp;&amp; str[l] == str[r]){ l++; r--; } return l >= r; } };</content></entry><entry><title>[Leetcode] Maximum Score from Performing Multiplication Operations(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1770/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag><tag>dynamic programming</tag><tag>recursion</tag></tags><content type="html"> LeetCode 1770 - Maximum Score from Performing Multiplication Operations You are given two integer arrays nums and multipliers of size n and m respectively, where n >= m. The arrays are 1-indexed.
You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will:
Choose one integer x from either the start or the end of the array nums. Add multipliers[i] * x` to your score. Remove x from the array nums. Return the maximum score after performing m operations. example Input: nums = [1,2,3], multipliers = [3,2,1] Output: 14 Explanation: An optimal solution is as follows: - Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score. - Choose from the end, [1,2], adding 2 * 2 = 4 to the score. - Choose from the end, [1], adding 1 * 1 = 1 to the score. The total score is 9 + 4 + 1 = 14. Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] Output: 102 Explanation: An optimal solution is as follows: - Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score. - Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score. - Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score. - Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score. - Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. The total score is 50 + 15 - 9 + 4 + 42 = 102. How can we solve this problem? 這題最主要的重點是對於每個multipliers[i],它只能挑選最左邊或者最右邊的值。所有，我們需要知道multipliers[i]拿最左邊的值最後的結果比較大，還是拿最右邊後的結果比較大。為了避免重複計算而超時，所以我們需要使用dp來幫助我們記錄當前最優解。注:因multipliers最多為m個，所有最多只能從nums拿m個數字
dp 定義： dp[i][j], 從前面取了i個,以及後面取了j個，但是因為j很大(n-1),所以我們透過計算當前計算的multipliers的第k個來表示(n - j - i + 1)。當前的multipliers是k。 dp 初始條件 : init 為 INT_MIN Solution: class Solution { vector&lt;vector&lt;int>> dp; public: int maximumScore(vector&lt;int>&amp; nums, vector&lt;int>&amp; multipliers) { //n >= m //socre : 0 //m operations //[3,2,1] int m = multipliers.size(); int n = nums.size(); dp = vector&lt;vector&lt;int>>(m+1,vector&lt;int>(m+1,INT_MIN)); return solution(nums,multipliers,0,n-1,n,m); } int solution(vector&lt;int>&amp; nums, vector&lt;int>&amp; multipliers,int i,int j,int n,int m){ int currentMul = n - (j - i + 1); //the rest of size of the sub-array is the index of current multipliers if(currentMul == m) return 0; //current maxvalue = choose first or choose end? if(dp[i][currentMul] != INT_MIN) return dp[i][currentMul]; //choose the front val return dp[i][currentMul] = max( (nums[i] * multipliers[currentMul]) + solution(nums,multipliers,i+1,j,n,m),// take left (nums[j] * multipliers[currentMul]) + solution(nums,multipliers,i,j-1,n,m) //take right ); } };</content></entry><entry><title>[Leetcode] Pancake Sorting(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode969/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>reverse</tag><tag>recursive</tag></tags><content type="html"> LeetCode 969 - Pancake Sorting Given an array of integers arr, sort the array by performing a series of pancake flips.
In one pancake flip we do the following steps:
Choose an integer k where 1 &lt;= k &lt;= arr.length. Reverse the sub-array arr[0...k-1] (0-indexed). For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3. Return an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct. example
Input: arr = [3,2,4,1] Output: [4,2,4,3] Explanation: We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: arr = [3, 2, 4, 1] After 1st flip (k = 4): arr = [1, 4, 2, 3] After 2nd flip (k = 2): arr = [4, 1, 2, 3] After 3rd flip (k = 4): arr = [3, 2, 1, 4] After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted. Input: arr = [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted. How can we solve this problem? 這題我我們要關注的點是如何將當前數字範圍([0,n))中最大的元素移動到array的最後。從上述例子中，我們可以觀察到:
翻轉[0,最大值的Index] -> 最大值就會被移動到最前面 翻轉[0,n) -> 最大值就會被移動的最後面 我們只需要重複以上步驟，每次做完就代表著[n-i,n-1]的這段範圍是已經被排序了。所以，每次做完只關注n-i-i即可(就是當前位置的前面的所有未排序元素[x,x,x,|y(n-i),y,y(n-1)])。 Solution: class Solution { public: vector&lt;int> pancakeSort(vector&lt;int>&amp; arr) { vector&lt;int> res; /* [3,2,4,1] -> we need to move the large value to the end //move the large element to the front then flip n-1 [4,2,3,1] 4(3) [1,3,2,4] n 4 [3,1,2,4] 3(2) [2,1,3,4] n-1 3 [1,2,3,4] 1 ,3 2 ,4 */ // we need to push the large number to the back // so we need to find out the maxinum number in [0,n] // then reverse [0,maxinum index] and then reverse whole list to make the large number at the end of the list(n) for(auto it = arr.end(); it != arr.begin(); it--){ auto maxVal = max_element(arr.begin(),it); //where is this element in the list if(distance(maxVal,it) > 1){ //if current val is not the maxinum if(maxVal != arr.begin()){ //if current value is not the first one -> no need to put it at the front of the array reverse(arr.begin(),maxVal + 1); res.push_back(distance(arr.begin(),maxVal) + 1); } //move the maxinum value to the back reverse(arr.begin(),it); res.push_back(distance(arr.begin(),it)); //don't filp sorted element at the end of the array } } // filp(arr,arr.size()); return res; } // void filp(vector&lt;int>&amp; arr,int n){ // if(n == 0) return; // //find the maximun // int max = 0; // int idx = 0; // for(int i = 0;i&lt;n;i++){ // if(arr[i] > max){ // max = arr[i]; // idx = i; // } // } // // move the max value to the front -> flip idx + 1 // res.push_back(idx + 1); // //swap the value // swapVal(arr,0,idx); // //move the large element to the end // swapVal(arr,0,n-1); // res.push_back(n); // //need doing this approach til sorted // filp(arr,n-1); // } // void swapVal(vector&lt;int>&amp; arr,int i,int j){ // while(i &lt; j){ // int temp = arr[i]; // arr[i] = arr[j]; // arr[j] = temp; // i++; // j--; // } // } };</content></entry><entry><title>[Leetcode] Find Original Array From Doubled Array(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2007/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>hash map</tag></tags><content type="html"> LeetCode 2007 - Find Original Array From Doubled Array An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.
Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order. example
Input: changed = [1,3,4,2,6,8] Output: [1,3,4] Explanation: One possible original array could be [1,3,4]: - Twice the value of 1 is 1 * 2 = 2. - Twice the value of 3 is 3 * 2 = 6. - Twice the value of 4 is 4 * 2 = 8. Other original arrays could be [4,3,1] or [3,1,4]. Input: changed = [6,3,0,1] Output: [] Explanation: changed is not a doubled array. Input: changed = [1] Output: [] Explanation: changed is not a doubled array. How can we solve this problem? 這是其實需要我們計算每個數出現的頻率，如果要找出某個數x的雙倍數是否存在於array中，如果存在，我們只需要將x與雙倍數移除(因為每個x只會匹配到一個順便數)。如果不存在，也就代表了這個array並不是一個有效的Double list，直接return false即可。
Solution: class Solution { public: vector&lt;int> findOriginalArray(vector&lt;int>&amp; changed) { if(changed.size() % 2 != 0) return {}; //must be an even size vector&lt;int> res; int n = changed.size(); sort(changed.begin(),changed.end()); unordered_map&lt;int,int> m; for(auto num : changed) m[num]++; //number frequency for(auto num : changed){ if(m.count(num) &amp;&amp; m[num] > 0){ //num is exist? m[num]--; if(!m.count(num * 2) || m[num*2] == 0){ //num * 2 is not exist or num*2 is empty return {}; }else { m[num * 2]--; res.push_back(num); } } } return res; } };</content></entry><entry><title>[Leetcode] Pseudo-Palindromic Paths in a Binary Tree(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1457/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>recursive</tag><tag>XOR</tag></tags><content type="html"> LeetCode 1457 - Pseudo-Palindromic Paths in a Binary Tree Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.
Return the number of pseudo-palindromic paths going from the root node to leaf nodes. example
Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). Input: root = [2,1,1,1,3,null,null,null,null,null,1] Output: 1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). Input: root = [9] Output: 1 How can we solve this problem? 這一題簡單的來說就是讓我們從Binary Tree中找到有幾條path是一個Palindromic(Pseudo-Palindromic)偽迴文串。 也就是說從root到leaft的path是一個Palindromic。 (我們只需要知道path是否能組成Palindromic即可)
哪我們要怎麼知道path是不是Palindromic的呢?
解決這個問題之前,我們先來看一下Palindromic分成了以下2個case。
Odd(Path長度為基數): aabbdbbaa => a:2,b:2, d:1 從這裡我們可以看得出來,只會有1個值/字符是基數,其餘的都會是偶數。
Even(Path長度為偶數): aabb => a:2,b:2 從這裡我們可以看得出來,所有值/字符都是偶數。
所以,我們可以直接通過一個array幫助我們計數有多少個值為基數。如果基數數目小於或者等於1的話,就符合了以上這2個條件，否則不能組成一個Palindromic。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int res = 0; int counter = 0; public: int pseudoPalindromicPaths (TreeNode* root) { vector&lt;int> counter(10,0); // from 1 - 9 solution(root,counter); return res; } void solution(TreeNode* root,vector&lt;int> &amp;counter){ //m uses to count how many number in the path //for odd case there will only remind 1 number such that xyzUyxz l //for even case there will not remind any number such that any number in the path occurs twice //example : xxyyzz -> rerange as xyzzyx if(root == nullptr) return; counter[root->val]++; if(!root->left &amp;&amp; !root->right){ //vector sum num be 0 or 1 int oddOccur = 0; for(auto n : counter){ if(n % 2 == 1) oddOccur ++; } //odd element at most appears once if(oddOccur &lt;= 1) res++; counter[root->val]--; return; } solution(root->left,counter); solution(root->right,counter); //check counter[root->val]--; } };</content></entry><entry><title>[Leetcode] UTF-8 Validation(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode393/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>binary</tag><tag>bit operation</tag></tags><content type="html"> LeetCode 393 - UTF-8 Validation Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
For a 1-byte character, the first bit is a 0, followed by its Unicode code. For an n-bytes character, the first n bits are all one&rsquo;s, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10. This is how the UTF-8 encoding would work:
Number of Bytes | UTF-8 Octet Sequence | (binary) --------------------+----------------------------------------- 1 | 0xxxxxxx 2 | 110xxxxx 10xxxxxx 3 | 1110xxxx 10xxxxxx 10xxxxxx 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx example
Input: data = [197,130,1] Output: true Explanation: data represents the octet sequence: 11000101 10000010 00000001. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. Input: data = [235,140,4] Output: false Explanation: data represented the octet sequence: 11101011 10001100 00000100. The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that's correct. But the second continuation byte does not start with 10, so it is invalid. How can we solve this problem? 這一題其實也不太算是算法題, 只是單純的驗證是不是一個合法的UTF-8。只要根據題目給你條件，就可以判斷出是不是合法的了。
要解這題我們需要判斷UTF-8的長度是多少，然後根據這個長度檢測是否包含了這裡多個BYTE(n-1)即可。
UTF-8 長度為1 => 沒有其他組成部分，所有ByteCount會是0 UTF-8 長度為2 => 組成部分包含了2個(包含自己),所以ByteCount會是1 UTF-8 長度為3 => 組成部分包含了3個(包含自己),所以ByteCount會是2 UTF-8 長度為4 => 組成部分包含了4個(包含自己),所以ByteCount會是3 因此讀取到(110xx xxx)/(1110 xxxx)/(1111 0xxx) 為UTF-8開頭,接下來就會包含n-1個為10xx xxxx的BYTE(1-byte的除外(0xxx xxxx))。如果不符號這個條件直接返回false即可。
小提示：
0(b00000000) - 127(b01111111) : 0xxx xxxx的最小值與最大值的範圍
128(b10000000) - 191(b10111111) : 10xx xxxx的最小值與最大值的範圍
192(b11000000) - 223(b11011111) : 110x xxxx的最小值與最大值的範圍
224(b11100000) - 239(b11101111) : 1110 xxxx的最小值與最大值的範圍
240(b11000000) - 247(b11011111) : 1111 0xxx的最小值與最大值的範圍
Solution: class Solution { public: bool validUtf8(vector&lt;int>&amp; data) { ios_base::sync_with_stdio(false); cin.tie(nullptr); //UTF 8 1 to 4 bytes //1 byte character -> 8bit -> the first bit is 0 -> unicode //n byte ->first n bytes -> 1 then n+1 -> 0(at most 4) //starting at 2th byte to n-1 byte -> the most significant 2 bits should be 10 /* suppose n = 4 //first number only 11110xxx = 2^3(xxx) (128,64,32,16,8,4,2,1) 1 1 1 1 0 x x x 128+64+32+16 */ /* 0xxxxx data[i] */ int n = data.size(); int byteCount = 0; for(int i = 0;i&lt;n;i++){ //there may be not only one nbyte code?? if(byteCount == 0){ if(data[i] >= 0 &amp;&amp; data[i] &lt; 128 ) byteCount = 0; // for unicode else if(data[i] >= 192 &amp;&amp; data[i] &lt; 224) byteCount = 1; else if(data[i] >= 224 &amp;&amp; data[i] &lt; 240) byteCount = 2; else if(data[i] >= 240 &amp;&amp; data[i] &lt; 248) byteCount = 3; else return false; }else { if(data[i] &lt; 128 || data[i] > 191) return false; //less/greater than 10xxxxx byteCount--; } } // return byteCount == 0; } };</content></entry><entry><title>[Leetcode] Bag of Tokens(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode948/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>greedy</tag><tag>sort</tag><tag>two pointer</tag></tags><content type="html"> LeetCode 948 - Bag of Tokens You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed).
Your goal is to maximize your total score by potentially playing each token in one of two ways:
If your current power is at least tokens[i], you may play the ith token face up, losing tokens[i]power and gaining 1a score. If your current score is at least 1, you may play the ith token face down, gaining tokens[i] power and losing 1 score. Each token may be played at most once and in any order. You do not have to play all the tokens. Return the largest possible score you can achieve after playing any number of tokens.
example
Input: tokens = [100,200], power = 150 Output: 1 Explanation: Play the 0th token (100) face up, your power becomes 50 and score becomes 1. There is no need to play the 1st token since you cannot play it face up to add to your score. Input: tokens = [100,200,300,400], power = 200 Output: 2 Explanation: Play the tokens in this order to get a score of 2: 1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1. 2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0. 3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1. 4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2. How can we solve this problem? 這題的解題思路是這樣透過貪心(gready),也就是說我能用多少power換分就用多少，如果不夠了我就用分換power。換句話說，就是先從最低的token開始換,直到足夠的power後，就以分來換取最高的power,直到不符合條件未知或者沒有任何token可以買為止。
因為要知道當前最大和最小，所以要先排序
Solution: class Solution { public: int bagOfTokensScore(vector&lt;int>&amp; tokens, int power) { //maxinum if(tokens.empty())return 0; int score = 0; sort(tokens.begin(),tokens.end()); /* strategy: get the mininum token if not enough -> get maxinum token if it has enough power -> get this token */ int i = 0; int j = tokens.size() - 1; int res = 0; while(i &lt;= j){ if(power >= tokens[i]){ score += 1; power -= tokens[i++]; res = max(res,score); }else if(score > 0){ score -= 1; power += tokens[j--]; } else break; } return res; } };</content></entry><entry><title>[Leetcode] The Number of Weak Characters in the Game(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1996/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 1996 - The Number of Weak Characters in the Game You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.
A character is said to be weak if any other character has both attack and defense levels strictly greater than this character&rsquo;s attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj attacki and defensej > defensei.
Return the number of weak characters.
example
Input: properties = [[5,5],[6,3],[3,6]] Output: 0 Explanation: No character has strictly greater attack and defense than the other. Input: properties = [[2,2],[3,3]] Output: 1 Explanation: The first character is weak because the second character has a strictly greater attack and defense. How can we solve this problem? 這題就是要我們找出多少個弱角色(會被攻擊的人)。對於這種包含了2個維度資訊的題目(attack,defense)，直接藉並不好解，所以，通常我們都會固定一個維度去解另外一個維度，這樣就會相對容易許多。
這題我們可以透過固定attack這個維度。因為我們知道高attack的可以攻擊低attackd的人。所以我們根據attack做排序。這樣attack就會是單調遞增排序。我們自然就可以不讓管這個維度(因為已經符合 attacki &lt; attackj 這個條件)。之後我們只需要處理defense這個維度就可以了。
defense這個維度必須以單調遞減的方式處理! 為什麼呢?
假設 Attack : [[1,1],[1,2],[2,4]] -> 這裡會有2個attack為1的角色。如果不以遞減的方式除了,這樣就會不符合條件(相同attack不能互打)。所以一遞減方式會變成這樣[[1,2],[1,1]...]，這樣一來就能避免互打的情況
解決完維度問題後，就很簡單了，只需要透過stack就可以知道有多少個人被攻擊了。只要進來的人defense的比stack top的人defense 大就+1即可。
Solution: class Solution { public: int numberOfWeakCharacters(vector&lt;vector&lt;int>>&amp; pro) { //[attacki, defensei] sort(pro.begin(),pro.end(),[&amp;](auto &amp;a1,auto &amp;a2){ if(a1[0]==a2[0]){ return a1[1]>a2[1]; } return a1[0]&lt;a2[0]; }); /* 3: 6 5: 5 6: 3 */ /* get the maxinum defense value from previous group if previous group defense value is greater the current group characteri -> this guy is the weak one in this case: [9,1] is a weak character [10,5] ->[9,1] [10,4] ->[9,1] [10,3] ->[9,1] [10,2] ->[9,1] [9,2] is a weak character [10,5] ->[9,3] [10,4] ->[9,3] */ int res = 0; stack&lt;int> s; for(int i = 0;i&lt;pro.size();i++){ while(!s.empty() &amp;&amp; s.top() &lt; pro[i][1]){ s.pop(); res++; } s.push(pro[i][1]); } return res; } };</content></entry><entry><title>[Leetcode] Binary Tree Inorder Traversal(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode94/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>traversal</tag></tags><content type="html"> LeetCode 94 - Binary Tree Inorder Traversal Given the root of a binary tree, return the inorder traversal of its nodes&rsquo; values.
example
Input: root = [1,null,2,3] Output: [1,3,2] Input: root = [] Output: [] Input: root = [1] Output: [1] How can we solve this problem? 這題很簡單,只要使用中序遍歷即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int> inorderTraversal(TreeNode* root) { vector&lt;int> res; inorder(root,res); return res; } void inorder(TreeNode* root,vector&lt;int>&amp; res){ if(!root) return; inorder(root->left,res); res.emplace_back(root->val); inorder(root->right,res); } };</content></entry><entry><title>[Leetcode] Construct String from Binary Tree(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode606/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>array</tag><tag>recursive</tag><tag>dsf</tag></tags><content type="html"> LeetCode 606 - Construct String from Binary Tree Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.
Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. example
Input: root = [1,2,3,4] Output: "1(2(4))(3)" Explanation: Originally, it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)" Input: root = [1,2,3,null,4] Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output How can we solve this problem? 這題就是要讓我們講以string的方式輸出Binary Tree。只要注意他的規則就可以解決這題。
node的children都會被()包裹住 node如果有left-child沒有right-child可以無視right-child的() node如果有right-child沒有left-child,left-child的位置必須包含一個()
根據以上這幾條輸出規則，透過postorder traversal就可以解決。 postorder traversal : traverse Left-child -> Right-child -> self node
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { string res; solution(root,res); return res; } //Solution A string constructStr(TreeNode* root){ if(!root) return ""; string cur = to_string(root->val); if(root->left) cur += '(' + tree2str(root->left) +')'; else if(root->right) cur += "()"; //for no left child but right child case if(root->right) cur += '(' + tree2str(root->right) +')'; return cur; } //Solution B void solution(TreeNode* root,string &amp;res){ if(!root) return; res += to_string(root->val); if(root->left || root->right){ res+= "("; solution(root->left,res); res+= ")"; if(root->right){ res+= "("; solution(root->right,res); res+= ")"; } } } };</content></entry><entry><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode442/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>hash map</tag></tags><content type="html"> LeetCode 442 - Find All Duplicates in an Array Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
You must write an algorithm that runs in O(n) time and uses only constant extra space. example
Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Input: nums = [1] Output: [] How can we solve this problem? 這題要我們找出所有在Array裡重複出現2次的數字。解法也很簡單, 因為題目也說了數字會出現1次或者2次,哪我們可以透過Map來計數,但當前數字已經出現過1次,也就代表當前數字是重複了2次,加入到結果即可。
Solution: class Solution { public: vector&lt;int> findDuplicates(vector&lt;int>&amp; nums) { vector&lt;int> res; // unordered_map&lt;int,int> m; int n = nums.size(); vector&lt;int> m(nums.size() + 1); // 1 - n for(int i = 0;i&lt;n;i++){ if (m[nums[i]] == 0) { m[nums[i]] ++; }else{ res.emplace_back(nums[i]); } } return res; } };</content></entry><entry><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2196/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>array</tag><tag>hash map</tag></tags><content type="html"> LeetCode 2196 - Create Binary Tree From Descriptions You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,
If isLefti == 1, then childi is the left child of parenti. If isLefti == 0, then childi is the right child of parenti. Construct the binary tree described by descriptions and return its root. The test cases will be generated such that the binary tree is valid. example
Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] Output: [50,20,80,15,17,19] Explanation: The root node is the node with value 50 since it has no parent. The resulting binary tree is shown in the diagram. Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]] Output: [1,2,null,null,3,4] Explanation: The root node is the node with value 1 since it has no parent. The resulting binary tree is shown in the diagram. How can we solve this problem? 這是給定一個2維的Array,根據Array[i]建構一棵Binary tree。主要得問題是哪一個是成為Tree root呢?要怎麼知道有哪些Child Node呢?
我們透過Map來幫助我們記錄所有Child Node,以便之後的建構 因每個Child Node都必須有一個Parent Node,也就是說在Map中能找到的Node必定是有Parent的，當找到1個Node沒有在Map中，也就代表著該Node必定是整棵Binary Tree的Head。
根據1跟2的邏輯,並使用一個Loop來建構Binary Tree即可。 Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* createBinaryTree(vector&lt;vector&lt;int>>&amp; des) { unordered_map&lt;int,TreeNode*> m; TreeNode* head = nullptr; //creating all node ->child node for(int i = 0;i&lt;des.size();i++) m[des[i][1]] = new TreeNode(des[i][1]); // all child node,except head node for(int i = 0;i&lt;des.size();i++){ //getting root node from map if(m.find(des[i][0]) == m.end()){ //getting head node TreeNode* root = new TreeNode(des[i][0]); head = root; m[des[i][0]] = root; } if(des[i][2]){ m[des[i][0]]->left = m.find(des[i][1]) == m.end() ? new TreeNode(des[i][1]) : m[des[i][1]]; }else { m[des[i][0]]->right = m.find(des[i][1]) == m.end() ? new TreeNode(des[i][1]) : m[des[i][1]];; } } return head; } };</content></entry><entry><title>[Leetcode] Binary Tree Pruning(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode814/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>recursive</tag></tags><content type="html"> LeetCode 814 - Binary Tree Pruning Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.
A subtree of a node node is node plus every node that is a descendant of node.
example
Input: root = [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer. Input: root = [1,0,1,0,0,0,1] Output: [1,null,1,null,1] How can we solve this problem? 這題是要讓我們移除所有不包含1的sub-tree。所以，我們只要透過DFS判斷一下node的left-sub tree 以及 right-sub tree 是否都不包含1: 1. 如果左右子樹都不包含1且當前node為0, 直接返回nullptr 2. 若當前節點為1就返回自身 2. 左子樹不包含1, 當前node的左子樹設成nullptr;同理右子樹不包含1,當前node 的右子數設為nullptr
Solution: class Solution { public: TreeNode* pruneTree(TreeNode* root) { if(!root) return nullptr; root->left = solution(root->left); //contain 1? root->right = solution(root->right); //contain 1? if (root->val == 0 &amp;&amp; !root->left &amp;&amp; !root->right) return nullptr; //remove itself return root; } // TreeNode* solution(TreeNode* root){ // if(!root) return nullptr; // root->left = solution(root->left); //contain 1? // root->right = solution(root->right); //contain 1? // if(root->val == 0 &amp;&amp; !root->left &amp;&amp; !root->right) return nullptr; //remove itself // return root; // } // bool solutionA(TreeNode* root){ // if(!root) return false; // if(!root->left &amp;&amp; !root->right) return root->val == 1; // bool left = solution(root->left); //contain 1? // bool right = solution(root->right); //contain 1? // if(!left) root->left = nullptr; // if(!right) root->right = nullptr; // return left || right || root->val == 1; // } };</content></entry><entry><title>[開發日記]OTT電影社群APP(一)</title><url>https://ryantokmanmokmtm.github.io/post/dev-ottapp-1/</url><categories><category>side-project</category><category>ios</category><category>dev-diary</category></categories><tags><tag>ios</tag><tag>dev</tag></tags><content type="html"> 最近這2個月都沒有更新發文章，主要是因為這2個月都在專注重構畢業專題的項目，也是只OTT電影平台。
今天這篇文章主要是跟大家分享這2個月所開發的進度和目前開發到的階段，以此作為這個項目的開發日記。
目前的成果 廢話少說，先上圖！
前端UI: 主界面 包含APP4個主要得核心功能
電影預覽與電影搜尋 - 提供了以電影類別預覽以及根據電影情況的預覽。如熱門電影,最受歡迎等&hellip; 用戶電影評論與影評分享 - 可允許用戶在觀看完電影後，寫下觀後感與他人分享 聊天與通知 - 可與朋友進行即時討論 用戶個人頁 - 包含了用戶基本訊息,發佈的文章,喜歡的電影以及收藏的電影 電影搜尋/預覽界面 功能如下：
讓用戶以文字的方式進行電影的查詢
讓用戶按著電影類別來預覽不同的電影
未實現功能如下：
刷新以及獲取更多資料 電影資訊界面 功能如下：
提供電影基本以及詳細資訊(包含電影說明,演員,成員,宣傳影片等) 為用戶提供OTT資源(如有串流平台提供資源)，並直連至該平台進行觀看 為用戶提供相似的電影 用戶可以點讚或者收藏電影 未實現功能如下：
刷新以及獲取更多資料 用戶社群與文章發佈界面 功能如下：
為用戶推送最新的電影評論文章 為用戶推送關注用戶的最新評論文章 用戶可以對文章直接評論以及點讚 用戶可以自行建立文章，發表電影感想 文章都會提供電影導向連接，可直接跳轉至電影詳細 未實現功能如下：
留言點讚 刷新以及獲取更多資料 聊天與通知界面 這部分的界面目前只使用了假數據進行UI設計，還沒設計對應的API
這部分會使用到Websocket 技術的幫助(還在研究當中QQ)
未實現功能如下：
用戶與用戶之間的對話 為用戶推送點讚,關注,留言的通知 直接搜尋好友進行通訊 刷新以及獲取更多資料 個人與他人資訊界面 功能如下：
用戶可以編輯更新個人資訊 用戶可以觀看用戶發表文章 用戶可以觀看用戶點讚電影 用戶可以觀看用戶收藏列表 用戶可以建立自定義的片單 未實現功能如下：
移除片單 移除片單中的電影 刷新以及獲取更多資料 後端API 已完成 SERVER HEALTH USER API USER GENRE API MOVIE API USER GENRE API POST LIKES API LIKED MOVIE API COMMENT LIKES API FRIEND API COMMENT API 待完成 Websocket 消息推送 Unit Test 部署至K8S以及AWS 總結 以上內容就是我7-8月之間所完成的開發事項。但APP還有很多地方沒有完成和完善！讓我們期待下一次的開發日記(*❦ω❦)
謝謝各位的耐心觀看！</content></entry><entry><title>[Leetcode] Reverse Linked List II(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode92/</url><categories><category>leetcode</category></categories><tags><tag>list</tag><tag>recursive</tag></tags><content type="html"> LeetCode 92 - Reverse Linked List II Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
example
Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Input: head = [5], left = 1, right = 1 Output: [5] How can we solve this problem? 這一題的問題非常的簡單,就是要讓我們在給定的一個list中翻轉(Reverse)[left,right]之間的Node,並返回結果。這題跟Reverse Linked List I解法類似,不同的是多了個翻轉範圍。
首先，我們要做的是在的翻轉的開始的位置。然後再透過recursive來翻轉List,最後返回的node/head再由left位置的Node的前一個Node接起來(如有)就可以了~
Solution: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { ListNode* theNodeAfter = nullptr; // ListNode* pre = nullptr; // ListNode* starting = nullptr; // ListNode* last = nullptr; // ListNode* first = nullptr; public: ListNode* reverseBetween(ListNode* head, int left, int right) { // if(head->next == nullptr) return head; // if(left == right) return head; // //getting the starting point // int n = right - left; // starting = head; // while(--left > 0){ // pre = starting; // starting = starting->next; // } // // cout &lt;&lt; starting->val &lt;&lt; endl; // reverseList(0,n,starting); //reverse list between left and right // if(pre != nullptr) pre->next = first; // else head = first; // last->next = afterBreak; if(left == 1){ //found //reverse the list return reverseList(right,head); //reverse the list and return the new head which node is the right node } head->next = reverseBetween(head->next,left - 1,right - 1); //keep finding the starting point return head; } ListNode* reverseList(int right,ListNode* head){ if(right == 1){ theNodeAfter = head->next; return head; } ListNode* last = reverseList(right-1,head->next); head->next->next=head; head->next=theNodeAfter; // return last; } // void reverseList(int i ,int n,ListNode* head){ // if(i == n){ // afterBreak = head->next; // head->next = nullptr; // first = head; // last = head; // return; // } // reverseList(i+1,n,head->next); // head->next =nullptr; // last->next = head; // last = last->next; // } };</content></entry><entry><title>[Leetcode DP] K Inverse Pairs Array(Hard)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode629/</url><categories/><tags/><content type="html"> 這題主要是學習DP思想，做個小記錄
LeetCode 629 - K Inverse Pairs Array For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &lt;= i &lt; j &lt; nums.length and nums[i] > nums[j].
Given two integersn and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7.
example:
Input: n = 3, k = 0 Output: 1 Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. Input: n = 3, k = 1 Output: 2 Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. How can we solve this problem? 題解 這題就是說給定一個數字n,從[1,n]中所能組成inverse pair為k組的有多少種組合方法。
INVERSE PAIR 的定義：
i &lt; j 且 num[i] > nums[j]
如 [2,1] 的INVERSE PAIR為1; 相反[1,2]的INVERSE PAIR 為 0
解法 這題我們需要使用到DP(動態規劃)
DP規劃:
題目很明確的問了我們在n array 中所能組成K個inverse pair有多少個，所以DP[i][j]表示的是i個數字在array中,組成j。 定義DP[n+1][k+1] 計算DP的值
假設已知dp[4][j], j:0....k 加入4呢? [x,x,x](1-3的任意組合) + 4 dp[4][j] => 加入4到array 中為j個 inverse pair</content></entry><entry><title>[Leetcode DP] Counting Bits(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes338/</url><categories><category>leetcode</category></categories><tags><tag>bit operation</tag><tag>dynamic programming</tag></tags><content type="html"> LeetCode 338 - Counting Bits Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1&rsquo;s in the binary representation of i.
example:
Input: n = 2 Output: [0,1,1] Explanation: 0 --> 0 1 --> 1 2 --> 10 Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 --> 0 1 --> 1 2 --> 10 3 --> 11 4 --> 100 5 --> 101 How can we solve this problem? 這題要我們解決的問題是給定一個數字n,回傳0 - n中每個數字包含了多少個為1的bits。例如: n=2 => 00,01,10,回傳的結果便會是[0,1,1]。
Bit Operation approach 這裡我們可以透過bit operation AND 來解決這個問題。從Truth Table中: A B Y(AND) 0 0 0 0 1 0 1 0 0 1 1 1 我們可以到只有1AND1才會是True,所有我們只需要對每一個bit與當前counter的值做AND,如果為1就bitCounter++就可以計算出每一個值的bits的數目。
因為一個Int類型為4BYTE,包含了32個bits,所以對於[0,n]中每一個數字都必須做32次的LOOP,因此Time Complexity是O(32N)。
Solution: class Solution { public: vector&lt;int> countBits(int n) { for(int i = 0;i&lt;n+1;i++){ int temp = 0; for(int j = 0;j&lt;=31;j++){ if( (1 &lt;&lt; j) &amp; i) temp++; } res[i]=temp; } return res; } }; Dynamic Programming approach 我們可以先觀察一下每個數字的Binary,以n=8為例: 從圖中我們可以看得到只有1個bit為1的數字都是2i,而我們所需要計算的[2i , 2i+1-1]之間的數字的數目即可。 但是,我們要怎麼計算呢?
首先,我們需要知道怎麼計算[2i , 2i+1-1]裡面的bits的數目,然後我們在觀察一下Binary: 如下圖: 我們可以發現[2i , 2i+1-1]都會想相隔2i-1個，也就是說我們只需要定義一個變數j作為offset 就可以移動到需要計算數字的位置( 0 &lt;= j &lt;= 2i-1 )。例如: i=2(22 = 4),2+0(2),2+1(3)。
接下來,我們可以透過DP來幫助我們計算。
定義BASE CASE:
DP[0] = 0 //number 0 不包含任何1&rsquo;s
根據目前2i,求出DP[2i+j] = DP[j],直到計算到(n)
注意: i 會根據i是否到達2i,最後進行Left-Shift(Double自己)
注意: j 作為[0,2i)的指標
例如:
DP[1] = DP[0] + 1 //比DP[0] 多一Bits
DP[2] = DP[0] + 1 //比DP[0] 多一Bits => 也可以視為在2的區間的1, DP[1] = DP[2] = 1
DP[3] = DP[1] + 1 //比DP[1] 多一Bits DP[4] = DP[0] + 1 //比DP[1] 多一Bits
Solution: class Solution { public: vector&lt;int> countBits(int n) { //Trying to use DP vector&lt;int> dp(n + 1); //from 0 to n dp[0] = 0; //base case int bits = 1; //2^0 = 1 int i = 0; while(bits &lt;= n){ //bits will be pow of 2 ->1,2,4,8,16,24 while(i&lt;bits &amp;&amp; i + bits &lt;= n){ dp[i + bits] = dp[i] + 1; i++; } i = 0; bits = bits &lt;&lt; 1; //double bits value // cout &lt;&lt; bits; } return dp; } };</content></entry><entry><title>[Leetcode] Kth Largest Element in an Array(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes215/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>array</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 1268 - Search Suggestions System Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
example:
Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 How can we solve this problem? 這題要我們解決的問題是回傳在sorted array(Input Array沒有排序)中第kth大的元素。最簡單的解法是直接排序,然後回傳kth元素即可。但是, 這裡我們也可以使用Priority Queue(Heap)來幫我們解決這個問題。因為Priority Queue的特性,越大的值(MaxHeap)/越小的值(MinHeap)會越接近root,也就是說最大值(MaxHeap)/最小值(MinHeap)會在root。所以我們可以運用MinHeap來幫助的我們解決這個問題,只要Priority Queue裡面的元素多於K個我們就會把top的值移除，因更小的值會在前面,每次pop的值都會是當前最小的值,直到最後，省下來的值的root/top就會是我們的第K個最大的值，而priority queue中最後一個值便會是Input中最大的值。
Solution: class Solution { public: int findKthLargest(vector&lt;int>&amp; nums, int k) { priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; for(int i = 0;i&lt;nums.size();i++){ q.push(nums[i]); if(q.size() > k) q.pop(); } return q.top(); } };</content></entry><entry><title>[Leetcode] Furthest Building You Can Reach(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes1642/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>heap</tag><tag>priority queue</tag><tag>greedy</tag></tags><content type="html"> LeetCode 1642 - Furthest Building You Can Reach You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.
You start your journey from building 0 and move to the next building by possibly using bricks or ladders.
While moving from building i to building i+1 (0-indexed),
If the current building&rsquo;s height is greater than or equal to the next building&rsquo;s height, you do not need a ladder or bricks. If the current building&rsquo;s height is less than the next building&rsquo;s height, you can either use one ladder or (h[i+1] - h[i]) bricks. Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally. example:
Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 Output: 4 Explanation: Starting at building 0, you can follow these steps: - Go to building 1 without using ladders nor bricks since 4 >= 2. - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7. - Go to building 3 without using ladders nor bricks since 7 >= 6. - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9. It is impossible to go beyond building 4 because you do not have any more bricks or ladders. Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 Output: 7 Input: heights = [14,3,19,3], bricks = 17, ladders = 0 Output: 3 How can we solve this problem? 這個要我們解決的問題是給定一定數量的磚塊brick和梯子ladder,問我們最遠能到達哪一棟建築(array index)。 我們主要注意的是題目給定的幾個限制條件。
如果i+1的建築比i建築矮,我們可以不用任何磚塊(bricks)或者梯子ladders 如果i+1的建築比i建築搞，我們必須使用一個梯子ladders或者(h[i+1] - h[i])個磚塊(bricks) 從這裡我們可以看到梯子ladders無論建築有多高，我們都可以到達。相反磚塊(bricks)則需要數量。所以，我們要解決這個問題會優先考慮使用梯子ladders。如果梯子ladders 使用完畢，我們可以將前面2個建築之間高度最小的梯子ladders回收,使用磚塊(bricks)取代。如果磚塊(bricks)也不夠或者超出提供的數量，就代表我們最遠可以到達的建築為i-1(因為i建築,我們沒有足夠的磚塊brick和梯子ladder)。如果梯子的數量跟建築的數量一樣多,直接回傳最後一棟(n-1)即可。
Solution: class Solution { public: int furthestBuilding(vector&lt;int>&amp; h, int bricks, int ladders) { //Using all ladders first //if there is no other ladders,we try to use bricks(mininum one) instead of a ladder //if there have enough ladders //just return n-1(index) priority_queue&lt;int, vector&lt;int>, greater&lt;int>> laddersUsed; //min heap //O(n*log l(min Head insert)) for(int i = 1;i&lt;h.size();i++){ //use all ladders int climbingHeigh = h[i] - h[i-1]; if(climbingHeigh &lt;= 0) continue; //we can climb it laddersUsed.push(climbingHeigh); //our ladder is enough? if(laddersUsed.size() &lt;= ladders) continue; //our ladder is not enough //try to use bricks to instead if our bricks is not enough too,return previous index(neither bricks nor ladders can reach ith building) bricks -= laddersUsed.top(); laddersUsed.pop(); if(bricks &lt; 0) return i-1; } return h.size() - 1; } //Time Exceed // int dfs(vector&lt;int>&amp; h,int i,int bricks, int ladders){ // if(bricks &lt; 0 || ladders &lt; 0) return i-1; // // if(bricks == 0 &amp;&amp; ladders == 0) return i; // if(i == h.size()-1) return i; // int res = 0; // if(h[i] > h[i+1]) { // res = solution(h,i+1,bricks,ladders); // }else{ // //either bricks ladders // int bricksCase = solution(h,i+1,bricks - (h[i+1]-h[i]),ladders); // int laddersCase = solution(h,i+1,bricks,ladders-1); // res = max(bricksCase,laddersCase); // } // return res; // } };</content></entry><entry><title>[筆記]TrieTree(前綴樹/字典樹)</title><url>https://ryantokmanmokmtm.github.io/post/trietree/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>data structure</tag></tags><content type="html"> Introduction 什麼是TrieTree? Trie稱為前綴樹或字典樹,是有序樹的一種,Node的key通常為String類型。Trie Tree與Binary-Searching Tree不同的點是,Trie Tree的Key並不會直接保存在Node中,而是它在Tree中的位置所決定的。一個Node中的所有的childrens都有相同的Prefix(前綴)。假設有個Node的key 為T,它的children將會是Time, Tim, Test等,因為他們都會相同的Prefix(前綴)T。
Trie Tree 的應用 字符前綴匹配 - 網頁URL,搜尋等 搜索關鍵字時,返回前綴最相似的可能結果 Trie Tree 結構圖 Trie Tree Template class TrieNode{ public: TrieNode(){ //suppose we are considering a string consist with a-z //at most 26 childrens for a node child = vector&lt;TrieNode*>(26); } vector&lt;TrieNode*> child; // bool isWord = false; //indicate current word is a word void AddNode(string&amp; str){ TrieNode*root = this; for(int i = 0;i&lt;str.length();i++){ //adding a node that key is str[i] if(!root->child[str[i] - 'a']) root->child[str[i] - 'a'] = new TrieNode(); root = root->child[str[i] - 'a']; } } //Other function define here... //Find a word etc... }; 參考資料 https://zh.wikipedia.org/wiki/Trie</content></entry><entry><title>[Leetcode] Short Encoding of Words(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode802/</url><categories/><tags><tag>string</tag><tag>array</tag><tag>TrieTree</tag></tags><content type="html"> 820 - Short Encoding of Words A valid encoding of an array of words is any reference string s and array of indices indices such that:
words.length == indices.length The reference string s ends with the '#' character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i]. Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.
example:
Input: words = ["time", "me", "bell"] Output: 10 Explanation: A valid encoding would be s = "time#bell#" and indices = [0, 2, 5]. words[0] = "time", the substring of s starting from indices[0] = 0 to the next '#' is underlined in "time#bell#" words[1] = "me", the substring of s starting from indices[1] = 2 to the next '#' is underlined in "time#bell#" words[2] = "bell", the substring of s starting from indices[2] = 5 to the next '#' is underlined in "time#bell#" Input: words = ["t"] Output: 2 Explanation: A valid encoding would be s = "t#" and indices = [0]. How can we solve this problem? 這題看上去好像很難理解它要我們解決什麼問題。但是我們可以從例子中可以觀察到他就只是單純用#來分隔每個子串。例如:time,me,bell會以這樣的方式進行Encoding,time#me#bell。但是問題要找出我們最短的是Encoding 長度為多少，也就是有重疊的Word我們無需額外加入到子串中，就剛才的例子我們可以看得出來time和me都包含了me。所以,我們Encoding會從time#me#bell縮短為time#bell#
哪我們要怎麼知道是否不用額外加入到字串中呢? 題目中有給出幾個條件(不符合條件需插入至String結尾):
對於任何words[j],從string中的indices[i] 到#前,與words[j]相同,也就是與words[j]是string的後綴(suffix)。例如：time和me, me是time的後綴。 words[i]的長度等於indices的長度。也就是words[i]-indices會等於words[j]。例如words[i]為4,indices為1,words[j]為2。4-1 != 2，也就是代表words[j]不是words[i]的後綴。 Solution: 我們可以透過Tire Tree來解決這個問題。因為我們要知道words有沒有相同後綴(suffix),所以建構Tree的時候,需要放過來插入。直到 leaf(葉子) 就會知道當前有相同後綴(suffix)的長度為多少，最後加總加一起，就是我們要的結果。
class TrieNode{ public: TrieNode(){ node = vector&lt;TrieNode*>(26); } vector&lt;TrieNode*> node; }; int AddWord(TrieNode* root,string&amp; w){ int res = -1; //if some words have the same suffix,it will return 0 ,-1+'#' = 0 for(auto i = w.rbegin();i&lt;w.rend();i++){ if(!root->node[*i - 'a']){ root->node[*i - 'a'] = new TrieNode(); res = w.length(); } root = root->node[*i - 'a']; } return res + 1; //extra } class Solution { public: int minimumLengthEncoding(vector&lt;string>&amp; words) { int res = 0; sort(words.begin(),words.end(),[&amp;](string&amp; a, string&amp; b){ return a.length() > b.length(); }); TrieNode* root = new TrieNode(); for(int i = 0;i&lt;words.size();i++) res += AddWord(root,words[i]); // findShortWords(0,root,res); return res; } }; 另外一種解法是我們只需要知道哪些words[j]跟words[i]有共同的suffix且符合條件。
過濾掉重複的words,並生成unique的list 大到小排序(根據字串的長度),因為我們要知道words[i]是否包含了words[j]。如果words[i].length() &lt; words[j].length()就一定不會包含。 計算長度: 看看words[j]有沒有符合條件 words[j]可能在words[i]不只出現過一次。所以我們需要找出所有可能。直到找出符合條件的或者沒有找到符合條件的。例如:timt(i),t(j), j在i出現了2次,而且有一個是符號條件的,也就是indices為3的t。 class Solution { public: int minimumLengthEncoding(vector&lt;string>&amp; words){ set&lt;string> unique(words.begin(),words.end()); //O(n) vector&lt;string> list; for(auto word : unique) list.push_back(word); //O(n) //sorting by word size //O n log n sort(list.begin(),list.end(),[&amp;](string&amp; a,string&amp; b){ return a.length() > b.length(); }); vector&lt;int> v(list.size(),0); int res = 0; //O n*n-1 = n^2 for(int i = 0;i&lt;list.size();i++){ if(v[i]) continue; for(int j = i+1;j&lt;list.size();j++){ int index = list[i].find(list[j]); if(index == -1) continue; //not found,go to next one if(index != -1 &amp;&amp; list[i].length() == index + list[j].length()){ v[j] = 1; }else{ while((index = list[i].find(list[j],index)) != -1){ if(list[i].length() == index + list[j].length()) { v[j] = 1; break; } index ++; } } } res += list[i].length() + 1; //adding extra # } } };</content></entry><entry><title>[Leetcode] Longest Palindromic Substring(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode5/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>dynamic programming</tag></tags><content type="html"> LeetCode 5 - Longest Palindromic Substring Given a string s, return the longest palindromic substring in s.
example
Input: s = "babad" Output: "bab" Explanation: "aba" is also a valid answer. Input: s = "cbbd" Output: "bb" How can we solve this problem? 要解決這題，我們必須要先知道什麼是Palindrome。可以參考這篇文章Palindromic string迴文。而這題要我們找出在給定string中,找到最長的Palindrome。我們可以透過以每個單一字元(index i)以及倆個字元(index i,index i+1)為中心點，並擴展left,right找出他們的局部的最長Palindrome為多少，然後根據這個長度計算starting point i以及記錄長度len,最後以starting point和len得出字串中str[startingPoint,len]為解。
Solution: class Solution { public: string longestPalindrome(string s) { /* Using an easy solution "babad" finding all posible palindrome string starting at index i(mid point) odd case: i-1 i i+1 ? Palindrome i-2 i-1 i i+1 i+2 ?Palindrome what about even case.We're simply starting at index i and i+1 i-1 [i,i+1] i+2 ?Palindrome */ int n = s.length(); int len = 0; int startPoint = 0; //O(n * n(finding Palindrome)) for(int i = 0;i&lt;n;i++){ int cur = max(getLen(s,i,i,n),getLen(s,i,i+1,n)); // which one is longest? odd or even if(cur > len){ //update our len and starting point len = cur; startPoint = i - (len-1)/2; //(len-1) for even case //suppose the len is 3 and the index is 1 ,then the starting point will be 1 - (3-1)/2 => 0-> len str[0...2] //suppose the len is 4 and the index is 1 ,then the starting point will be 1 - (4-1)/2 => 0-> len str[0...2] } } return s.substr(startPoint,len); } //str[i..j] is our middle point of Palindrome int getLen(string&amp;str,int i,int j,int n){ //left(i) right(j) while(i>=0 &amp;&amp; j&lt;n &amp;&amp; str[i] == str[j]){ i--; j++; } //string at i+1 and getting //|y|x2|x1|x|x1|x2|y| => the length of this string is l - r + 1 -(out of bounds of both i and j => 2) => l-r-1 return j-i-1; //string at i+1(is decreased from the loop),total } };</content></entry><entry><title>[筆記]Palindromic String(迴文字串)</title><url>https://ryantokmanmokmtm.github.io/post/palindromicstring/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>string</tag><tag>dynamic programming</tag></tags><content type="html"> Introduction 什麼是Palindromic String 迴文字串 所謂的Palindromic String(迴文字串) 就是以一個字元為中間，而它的左邊以及右邊的組成字元相同。
例子:
abcdcba 以d為中心的左跟右的字元一樣。
cdc左跟右都為c
bcdcb 左跟右都為b
abcdcba 左跟右都為a
要怎麼知道String是否為什麼是palindrome(迴文) 要知道String是否palindrome，我們先得知道Palindromic的規則:
單一的字元都是Palindromic，例如: a,b,g&hellip; 某字元的左右字元相同,例如: xax,xbx,xgx&hellip; 某字元自己跟右邊或者左邊相同也是一個也使一個palindrome。例如aa,bb 如果某子串為palindrome,而左跟右字元相同，它也會是一個palindrome。例如palindromeaba,它的左右2邊都為字元x,xabax也使一個palindrome; 相反，左跟右字元不相同,則只有子字串為palindrome。 判斷是否palindrome string 我可以從子串的中心點(middle point)開始往外擴展i,j,如果i跟j位置的為相同字元,則繼續往外擴。如果過程中有i,j位置的字元不相同,我們就可以知道它不是一個palindrome。
在尋找Palindrome的時候，我們必要要考慮到odd和evencase。
odd case : 會以odd基數的方式擴展。 例如: a -> bab -> cbabc&hellip; even case: 會以even偶數的方式擴展 例如: aa -> baab -> cbaabc&hellip; 什麼時候會出現這種情況呢? 例如這個例子:baab。如果只使考慮到odd case,他會被認為不是一個Palindrome。baa,aab&hellip;都不是合法的Palindrom。所以,我們必須考慮到even case。aa,baab是合法的Palindrom。
Palindrome Template //O(n) bool isPalindrome(string str,int i,int j){ while(i>=0 &amp;&amp; j &lt; str.length()){ if(str[i] != str[j]) return false; i--; j++; } return true; } //中心點為Odd(i) isPalindrome(str,i,i); //中心點為even(i,i+1) isPalindrome(str,i,i+1);</content></entry><entry><title>[筆記]Longest Common SubString(最長公共子序列)</title><url>https://ryantokmanmokmtm.github.io/post/lcm/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>dynamic programming</tag></tags><content type="html"> Introduction 什麼是最長公共子序列? 給定2個字串string A和string B,2個字串中所共同擁有的最長的子字串。
例如:
StringA:leetcodeStringB:ecbod他們的最長公共子序列便是`ecod`解釋:StringA包含了__e_cod_=>ecodStringB包含了ec_od=>ecod要怎麼找到最長公共子序列LCM呢? 我們需要定義一個數組用於保存當前情況下的最優解,也就是使用DP的方式。我們需要以每個字符最為考量,並一一匹配，最後得出整體最優解。 LCM Code Template int longestCommonSubStr(string &amp;s1, string &amp;s2){ int n = s1.length(); int m = s2.length(); vector&lt;vector&lt;int>> dp(n+1,vector&lt;int>(m+1,0)); for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=m;j++){ if(s1[i-1] == s2[j-1]) dp[i][j] = 1 + dp[i-1][j-1]; //the LCM of previous size + current matched else dp[i][j] = max(dp[i-1][j],dp[i][j-1]); //strA[0..i-2] str[0...j-1] or strA[0..i-1] str[0...j-2] check which one have the longest LCM } } return dp[n][m]; } 參考資料 经典动态规划：最长公共子序列</content></entry><entry><title>MetaHuman虛擬數字人初探</title><url>https://ryantokmanmokmtm.github.io/post/Mataverse-MataHuman/</url><categories><category>mateverse</category><category>modeling</category></categories><tags><tag>matehuman</tag></tags><content type="html"> 因為元宇宙(Metaverse)這個概念火熱,所有我就趁著這個機會了解一下在元宇宙領域中本人覺得比較有趣的東西。也就是這篇文章所要分享給各位的MetaHuman(虛擬數字人/虛擬數位人)
什麼是MetaHuman(虛擬數字人/虛擬數位人)呢? 所謂的MetaHuman(虛擬數字人)是具有數字化形象的虛擬人物，並且具備特定的相貌、性格和性別等人物特征、具備語音，面部表情和肢體動作表達的能力以及擁有人類的思想會具有外界環境與人交流的互動能力。 這裡只是簡略的介紹一下。如果各位對虛擬數字人技術或者發展剛興趣的,可以參考這份虛擬數字人白皮書
簡單數字人實作 注:本實作之數字人透過輸入自定義音頻生成，並無溝通等能力
使用工具:
Reallusion Character Creator Reallusion IClone 實作步驟也十分的簡單:
我們將透過Reallusion Character Creator製作我們數字人的外觀,然後再將數字人傳入Reallusion IClone做動畫,也就是透過IClone的音頻生成數字人動畫的功能製作動畫。
Step 1:
進入Reallusion Character Creator製作角色(以博主自定義的角色為例)，如下圖: Step 2:
將剛才在CC(Character Creator) 製作的角色匯入到IClone中,如下圖:
Character Creator中: File->Export->Send to IClone 匯入音頻文件
Modify->Facial->Create Script->Audio File 預覽動畫結果，並渲染動畫 Demo展示 燈光一展示:
燈光二展示
結論 有沒有發現很簡單又很好玩呢!我們透過Reallusion工具讓我們能在很短的時間內就可以完成一個屬於自己的MetaHuman。除此之外Reallusion還提供很多很強大的功能，例如:圖片生成3D角色模型,手機臉部動作捕捉,與Unreal Engine 5的MetaHuman工具連動等等，有機會的話再跟大家分享。
參考資料:
Reallusion</content></entry><entry><title>[Leetcode] Combination Sum III(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode216/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag><tag>recursion</tag><tag>back-tracking</tag></tags><content type="html"> LeetCode 216 - Combination Sum III Find all valid combinations of k numbers that sum up to n such that the following conditions are true:
Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. example
Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination. How can we solve this problem? 這題主要關注的點是數字範圍為[1,9]，每個結果中，數字只能使用一次，而且數字必須是順序排列。例如:2,3,4,1,2,5。解決這題我們可以用back-traking大法。只要我們當前的Sum大於n我們就直接退回back track回上一步,因為數值只會越來越大，並不是我們想要的。如果Ans我們所需的k個就直接判斷是否等於n，如果是就直接加入到我們的result即可。
Solution: class Solution { vector&lt;vector&lt;int>> res; vector&lt;int> tmp; public: vector&lt;vector&lt;int>> combinationSum3(int k, int n) { solution(n,k,0,1); return res; } void solution(int n,int k,int sum,int start){ if(k==0){ if(sum == n) res.push_back(tmp); return; } if(sum > n) return; for(int i = start;i&lt;=9;i++){ tmp.push_back(i); solution(n,k-1,sum + i,i+1); tmp.pop_back(); } } };</content></entry><entry><title>[Leetcode] Letter Combinations of a Phone Number(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode17/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>recursion</tag><tag>back-tracking</tag></tags><content type="html"> LeetCode 17 - Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
example
Input: digits = "23" Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"] Input: digits = "" Output: [] Input: digits = "2" Output: ["a","b","c"] How can we solve this problem? 這題是要我們拿到Input的數字所能組合出所有字串。解法也很簡單，我們可以透過Map記錄每個數字代表來那些字符，然後再透過Back-tracking技巧來幫助我們組合字串。你有可能會問什麼是Back-tracking。簡單來說就是一個Recursive Function,但他會迴避一些不正常的數值。比如:&ldquo;abc&rdquo;,而"abc"可能不是我們要的。因此退回上一步的"ab",並嘗試其他數值/結果。
Solution: class Solution { unordered_map&lt;char,string> temp = { {'2',"abc"}, {'3',"def"}, {'4',"ghi"}, {'5',"jkl"}, {'6',"mno"}, {'7',"pqrs"}, {'8',"tuv"}, {'9',"wxyz"} }; public: vector&lt;string> letterCombinations(string digits) { vector&lt;string> res; if(digits.length() == 0) return res; solution(res,0,digits,""); return res; } void solution(vector&lt;string>&amp; res,int index,string &amp;digits,string phone){ if(index == digits.length()){ res.push_back(phone); return; } auto numList = temp[digits[index]]; for(int i = 0;i&lt;numList.length();i++){ phone += numList[i]; solution(res,index+1,digits,phone); phone.pop_back(); } } };</content></entry><entry><title>[Leetcode] Flatten Nested List Iterator(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode341/</url><categories><category>leetcode</category></categories><tags><tag>design</tag><tag>recursion</tag><tag>iteration</tag></tags><content type="html"> LeetCode 341 - Flatten Nested List Iterator You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.
Implement the NestedIterator class:
NestedIterator(List&lt;NestedInteger> nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. Your code will be tested with the following pseudocode:
initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res If res matches the expected flattened list, then your code will be judged as correct.
example
Input: nestedList = [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Input: nestedList = [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. How can we solve this problem? 這一題就是一題設計的題目,可以想象成是一個FileSystem，裡面可能存的是文件(Integer)或者是文件夾(List)。因此，我們可以發現他就是一顆Tree。所以，我們只要從左到右拿到Integer,並順序輸出即可。
如圖:
Solution(Recursion): 我們可以在initial透過Recursive Function來遍歷Input,並把所有Integer先Push到Array/List裡面。然後在定義一個pointer用於存取Next的值即可。
/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger> &amp;getList() const; * }; */ //calling hasNext -> next class NestedIterator { vector&lt;int> ans; // vector&lt;NestedInteger> list; int cur = 0; void getValue(vector&lt;NestedInteger>&amp; data){ for(int i = 0;i&lt;data.size();i++){ if(data[i].isInteger()) ans.push_back(data[i].getInteger()); else getValue(data[i].getList()); } } public: NestedIterator(vector&lt;NestedInteger> &amp;nestedList) { getValue(nestedList); } int next() { return ans[cur++]; } bool hasNext() { return cur &lt; ans.size() ? true:false; } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Solution(Iteration): 這個解法是透過在Calling hasNext()的時候將當前container的最前面的那個element展開來(如果是一個list)，並把展開來的element放到container最前面，從而確保來container的最前面的element是Integer,呼叫next()時，都會return Int。
/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger> &amp;getList() const; * }; */ //calling hasNext -> next class NestedIterator { // vector&lt;int> ans; vector&lt;NestedInteger> list; public: NestedIterator(vector&lt;NestedInteger> &amp;nestedList) { list = nestedList; } int next() { //here we always return the first one // cout &lt;&lt; storage.size() &lt;&lt; endl; int res = storage.begin()->getInteger(); // cout &lt;&lt; res &lt;&lt;endl; storage.erase(storage.begin()); return res; } bool hasNext() { //we check our storage here //if the first elements is not a integer ,we try to get the interget from the list and append to our storage while(!storage.empty() &amp;&amp; !storage.front().isInteger()){ //get the first one from the storage vector&lt;NestedInteger> data = storage.front().getList(); storage.erase(storage.begin()); //append to the front of the storage that retrieved from the list for(int i = data.size()-1;i>=0;i--) storage.insert(storage.begin(),data[i]); } // if(storage.front().isInteger()) cout &lt;&lt; storage.front().getInteger(); return !storage.empty(); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */</content></entry><entry><title>[Leetcode] 132 Pattern(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode456/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 456 - 132 Pattern Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].
Return true if there is a 132 pattern in nums, otherwise, return false. example
Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Input: nums = [3,1,4,2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2]. Input: nums = [-1,3,2,0] Output: true Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. How can we solve this problem? 這題就是要我們找出List有沒有符合132 Pattern。那怎麼才算是132 Pattern呢。從題目定義可以看出在List中任意的nums[i] &lt; nums[k] &lt; nums[j]，也就是說nums[k]為最大,nums[j]為第二大,nums[i]`為第三大。
那要怎麼找到是不是符合呢?
假設我們現在的位置是nums[j],我們是否能在找到[0 - j)這個範圍內找到nums[k]以及nums[i]且符合nums[i] &lt; nums[k] &lt; nums[j]就好了呢?
哪我們應該要怎麼做呢?
因為nums[i]都是會是132 pattern當中最小的的值。因此每當iterate時，記錄當前值的左邊的最小的值(當前這個值可能會是k，最小值可能會是i)。當我要判斷一個值是不是j時，我們只需要拿到比他大的值，然後再透過記錄在此值得最小值，跟j做比較是不是符合nums[i] &lt; nums[j]這個條件，我們就可知道當前的j是不是我們要找的。
解題步驟如下:
我們要記錄每個值的左手邊的最小值，用於判斷是不是nums[i] 我們要用定義一個pointer暫存目前的最小值 當我們要判斷當前的值是否會構成132 Pattern,就從先前的記錄中獲取比較當前值還要大的記錄，並且透過記錄中的最小值判斷是不是也小於j,從而得出結論。 Solution: class Solution { public: bool find132pattern(vector&lt;int>&amp; nums) { //i &lt; k &lt; j //if there exist one return true return solution(nums); } // bool burstForce(vector&lt;int>&amp; nums){ // int n = nums.size(); // for(int i = 0;i&lt;n;i++){ // for(int j = i+1;j&lt;n;j++){ // for(int k = j + 1;k&lt;n;k++) // if(nums[i] &lt; nums[j] &amp;&amp; nums[j] > nums[k] &amp;&amp; nums[i] &lt; nums[k]) return true; // } // } // return false; // } bool solution(vector&lt;int>&amp; nums){ //current k int curMin = nums[0]; stack&lt;pair&lt;int,int>> s; //&lt;num,minBeforeNum> for(int i = 1;i&lt;nums.size();i++){ //nums[i] repersent the j //and top will be our k and check min before k while(!s.empty() &amp;&amp; nums[i] >= s.top().first){ //finding the k before j s.pop(); } //checking the top elements of the stack if(!s.empty() &amp;&amp; s.top().second &lt; nums[i]) return true; //checking //push to stack s.push({nums[i],curMin}); curMin = min(nums[i],curMin); } return false; } };</content></entry><entry><title>[LeetCode] Remove All Adjacent Duplicates in String II(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1209/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>stack</tag></tags><content type="html"> LeetCode 1209 - Remove All Adjacent Duplicates in String II You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.
example
Input: s = "abcd", k = 2 Output: "abcd" Explanation: There's nothing to delete. Input: s = "deeedbbcccbdaa", k = 3 Output: "aa" Explanation: First delete "eee" and "ccc", get "ddbbbdaa" Then delete "bbb", get "dddaa" Finally delete "ddd", get "aa" Input: s = "pbbcggttciiippooaais", k = 2 Output: "ps" How can we solve this problem? 這題就是要我們刪除掉在String裡面某些相鄰且相同並重複了k次的Characters。例如: aeee,k=3，輸出a。如果我們要解決這個問題就要知道目前string裡面有哪些subString符合條件，但是這裡要注意一個問題就是有些Substring被移除後，會使前(刪除Str)後2個substring符合條件。例如:aeeeaa,但我們刪除eee後,aaa也會符合條件，因此會被移除。
哪我們要怎麼知道哪些characters符合條件呢?
這裡我們可以使用Stack/Array來幫組我們解題。為什麼是用Stack? 因為我們只需要關注當前str[i]是否與前一個str[i-1]一致,如果是一致的我們會加入到Stack.top的Counter裡面。只要Counter的值為k我們就知道是符合條件的String，移除即可。最後，把Stack/Array裡面剩餘的元素串接就可以得出最後答案(注:Stack元素串接需要Reverse結果)。
Solution: class Solution { public: string removeDuplicates(string s, int k) { if(s.length() &lt; k) return s; string res; vector&lt;pair&lt;char,int>> counter; //O(n) for(auto str : s){ //how many same character if(counter.empty() || counter.back().first != str) counter.push_back({str,1}); else{ counter.back().second++; } if(counter.back().second == k) counter.pop_back(); } // for(auto e:vc) cout &lt;&lt; e; //O(i*k &lt;= n ) => O(n); for(int i = 0;i&lt;counter.size();i++){ for(int j = 0;j&lt;counter[i].second;j++) res+=counter[i].first; } cout &lt;&lt; res &lt;&lt;endl; return res; } };</content></entry><entry><title>[Leetcode] Implement Stack using Queues(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode225/</url><categories><category>leetcode</category></categories><tags><tag>stack</tag><tag>queue</tag><tag>design</tag></tags><content type="html"> LeetCode 225 - Implement Stack using Queues Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes:
You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&rsquo;s standard operations. example
Input ["MyStack", "push", "push", "top", "pop", "empty"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False How can we solve this problem? 這題就是要我們用Queue來模擬Stack。做這題之前我們要先知道Queue和Stack的差異。
Queue是First In First Out, 也就是先進去的element會先被拿出來 Stack是First In Last Out, 也就是先進去的element最後才會被拿出來 push(int x):
如果要用Queue來模擬Stack就要注意在Queue中的最後一個元素會是Stack的第一個元素。所以，這題我們可以用比較簡單粗暴的方式來解決。因為我們已經知道後進(Last In)Stack的值會是第一個元素。因此,我們可以直接用一個variable保存最後插入進Queue的element即可。
pop()
如果我們要移除element，就必須要將Queue的最後一個元素搬到最前面，同時因為最前面的元素會被移除，所以我們用於保存最後插入進Queue的variable所記錄的值也必須被改變，變成Queue的倒數第二個element。因此我們要先將Queue中最後的2個element搬到最前面，第一個便是我們stack的top,而第二個是我們要pop的element。最後，我們記錄完top的值後，插入到Queue的尾巴，並返回要Queue的front即可。
clear(): 只需將空的Queue取代成當前不是空的Queue即可。
empty():
只需檢查Queue是否為empty()即可。
Solution: class MyStack { public: queue&lt;int> q; int t; // queue&lt;int> q2; MyStack() { } //O(N) void push(int x) { // q2.push(x); // while(!q.empty()){ // q2.push(q.front());q.pop(); // } // q = q2; // clear(q2); q.push(x); t = x; } //O(1) int pop() { // if(empty()) return -1; // int value = q.front();q.pop(); //get the last 2 elements int size = q.size(); while(size-- > 2) { q.push(q.front()); q.pop(); } //getting the 2th top value in stack t = q.front(); q.push(q.front()); //push it at the back of the queue q.pop(); //getting the 1th top value in stack int popVal = q.front(); q.pop(); return popVal; } void clear(queue&lt;int>&amp; q){ queue&lt;int> empty; swap(empty, q); } int top() { // if(empty()) return -1; // return q.front(); return t; } bool empty() { return q.empty() ? true : false; } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */</content></entry><entry><title>[Leetcode] Max Number of K-Sum Pairs(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1679/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>map</tag><tag>two-pointer</tag></tags><content type="html"> LeetCode 1679 - Max Number of K-Sum Pairs You are given an integer array nums and an integer k.
In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.
Return the maximum number of operations you can perform on the array.
example
Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. Input: nums = [3,1,3,4,3], k = 6 Output: 1 Explanation: Starting with nums = [3,1,3,4,3]: - Remove the first two 3's, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation. How can we solve this problem? 這題就是要移除Array中2個elements加起來等於k的操作有幾次。
第一個解法，我們可以使用sorting以及two-pointer approach來解決。先將array排序，然後設置i為0,j為n-1,直接使用iteration找出nums[i]+nums[j] = k的數，然後answer+1即可。
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { //sort sort(nums.begin(),nums.end()); //O n log n int ans = 0; int i = 0,j = nums.size()-1; while(i &lt; j){ if(nums[i] + nums[j] == k) { ans++; i++; j--; }else if(nums[i] + nums[j] > k)j--; else i++; } return ans; } }; 第二種解法是透過map來記錄。首先，會透過x = k - nums[i]得出一個數，如果這個數不存在map裡面或者map[x] &lt;= 0就代表沒有，就把目前的nums[i]加入到map。如果存在，就將answer+1並且從map中移除map[x]的數量(map[x]--)。
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { unordered_map&lt;int,int> temp; int ans = 0; for(int i = 0;i&lt;nums.size();i++){ int sum = k - nums[i]; if(temp[sum] > 0){ //exist this value; //for example:[3,1,3,4,3] //3,1,3(we are here) 6-3=3 and 3:1 and we found a pair(3,3)=6 ,and remove the existing value ans++; temp[sum]--; }else temp[nums[i]]++; } return ans; } };</content></entry><entry><title>[Leetcode] Shortest Unsorted Continuous Subarray(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode581/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 581 - Shortest Unsorted Continuous Subarray Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.
Return the shortest such subarray and output its length.
example:
Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Input: nums = [1,2,3,4] Output: 0 Input: nums = [1] Output: 0 How can we solve this problem? 這題比較難懂一點點，這裡先做一下題目的解釋。這題主要先問的是在輸入的Array裡面找到一個最小需要排序的Sub-array。
從例子[2,6,4,8,10,9,15]中，我們可以很明顯的看到[6,4,8,10,9]並不是ascending order(順序),而這個sub-array要進行排序的話，所有elements都需要進行排序，所以，他的length是5。
再舉另外一個例子[1,3,2,3,3]，這個Array我們可以看到[3,2,3,3]並不是順序的，但是在這個sub-array裡面,只有[3,2]需要排序,所以，他的結果會是2。
那我們應該要怎麼解呢? 一個最簡單的解法是定義一個額外的array，而這個array的element跟原來的一樣，但是已經被排序過的。因此，只要比較原本的array和排序過的array有幾個element的位置不一樣就知道結果了。但Time Complexity是是O(n log n) - 排序的時間，而Space Complexity則是O(n)
Solution: vector&lt;int> temp = nums; sort(temp.begin(),temp.end()); //n log n int start = nums.size() - 1; int end = 0; //finding the starting point which is not as same as the sorted array //finding the ending print which is not as same as the sorted array for(int i =0;i&lt;nums.size();i++){ if(nums[i] != temp[i]){ start = min(i,start); // end = max(end,i); } } return end - start >= 0 ? end - start + 1 : 0; 另外一種解法是通過Two-pointer approach來解。我們先要找到左手邊有問題的地方的最小值(1,4,7,5,3,6 最小值為3)以及右手邊有問題的地方的最大值(1,4,7,5,3,6 最大值為7)。然後,要找出左手邊第一個被影響的index(nums[index] > 最小值)。同理也要找出右手邊第一個被影響的最index(nums[index] &lt; 最大值)。這樣我們就能找出有問題的區間[left,right]，在根據left,right得出最終結果。 Solution: 解法二:
int start = INT_MAX; int end = INT_MIN; for(int i = 1;i&lt;nums.size();i++){ if(nums[i] &lt; nums[i-1]) start = min(nums[i],start); } for(int i = nums.size() - 2;i>=0;i--){ if(nums[i] > nums[i + 1]) end = max(nums[i],end); } int left,right; //scanning the value from the left to the right that is less than maximum value for(left = 0;left&lt;nums.size();left++){ //finding the descending point if(start &lt; nums[left]) break; } //scanning the value from the right to the left that is less than minimum value for(right = nums.size() - 1;right >= 0;right--){ if(end > nums[right]) break; } //we need to find out the right-most point return right - left >= 0 ? right - left + 1 : 0;</content></entry><entry><title>[Leetcode] Sort Array By Parity(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode905/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 905 - Sort Array By Parity Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
Return any array that satisfies this condition.
example:
Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Input: nums = [0] Output: [0] How can we solve this problem? 這個問題很簡單，就是把偶數移動到Array的前面，基數移動到後面。我們這裡可以使用Two-pointer approach, i為尋找前面的基數，而j 為尋找後面的偶數，只要nums[i]為基數,nums[j]為偶數就進行交換。
=j`就結束 -- Solution: class Solution { public: vector&lt;int> sortArrayByParity(vector&lt;int>&amp; nums) { int i = 0; int j = nums.size() - 1; //O(n) while(i &lt; j){ //i is even skip //j is odd skip //i is odd and j is even swap if(nums[i] % 2 == 0) i++; else if(nums[j] % 2 == 1) j--; else swap(nums[i++],nums[j--]); } return nums; } };</content></entry><entry><title>[Leetcode] Backspace String Compare(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode844/</url><categories><category>leetcode</category></categories><tags><tag>string</tag></tags><content type="html"> LeetCode 844 - Backspace String Compare Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
example:
Input: s = "ab#c", t = "ad#c" Output: true Explanation: Both s and t become "ac". Input: s = "ab##", t = "c#d#" Output: true Explanation: Both s and t become "". Input: s = "a#c", t = "b" Output: false Explanation: s becomes "c" while t becomes "b". How can we solve this problem? 這題主要要什麼比較2個String移除於#前的字符後是否為相同的String，就相當於Backspace(#) 字符。 這題有2種解法:
要使用到額外的空間，保存2個移除字符後的String再進行比較。 透過pointerr的方式來決定哪個位置是要被移除的，然後將之後的字符將其進行取代，最後在比較倆者在r長度內的字符是否相同，即可。可見下圖為例: Solution: class Solution { public: bool backspaceCompare(string s, string t) { int slen = s.length(); int tlen = t.length(); int i = 0; int rpSStrIndex = 0; while(i &lt; slen ){ if(s[i] == '#') { if(rpSStrIndex > 0) rpSStrIndex--; } else s[rpSStrIndex++] = s[i]; i++; } i = 0; int rpTStrIndex = 0; while(i &lt; tlen){ if(t[i] == '#' ){ if(rpTStrIndex > 0) rpTStrIndex--; } else t[rpTStrIndex++] = t[i]; i++; } cout &lt;&lt; rpSStrIndex &lt;&lt; rpTStrIndex; //there length is not same if(rpSStrIndex != rpTStrIndex) return false; //compare each string between replaced Index for(i = 0;i&lt;rpSStrIndex;i++){ if(s[i] != t[i]) return false; } return true; } };</content></entry><entry><title>[Leetcode] Trim a Binary Search Tree(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode669/</url><categories><category>leetcode</category></categories><tags><tag>binary Search Tree</tag><tag>binary Tree</tag><tag>recursion</tag></tags><content type="html"> LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.
Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.
example
Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] How can we solve this problem? 這題就是要我們將一顆BST的少於low的部分以及大於heigh的部分移除。這題打算使用遞歸來解決。我們只要將比low小的Node的右子樹接到他的父節點，並取代比low還小的Node，而比heigh大的Node的左子樹接到他的父節點，並取代比heigh還大的Node即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { //space : O(tree node size for all nodes value are between low and height) //time : O(tree node size for all nodes) return TrimBST(root,low,high); } TreeNode* TrimBST(TreeNode* root,int low,int height){ if(!root) return nullptr; //if the root value is less than height ,go right sub-tree //if the root value is greater than low ,go left sub-tree if(root->val &lt; low){ // root->left = nullptr; return TrimBST(root->right,low,height); }else if(root->val > height){ // root->right = nullptr; return TrimBST(root->left,low,height); } //left root->left = TrimBST(root->left,low,height); //right root->right = TrimBST(root->right,low,height); // cout &lt;&lt; root->val &lt;&lt; "\n"; return root; } };</content></entry><entry><title>[Leetcode] Search in a Binary Search Tree(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode700/</url><categories><category>leetcode</category></categories><tags><tag>binary search tree</tag><tag>recursion</tag><tag>binary Tree</tag></tags><content type="html"> LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
example
Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5 Output: [] How can we solve this problem? 在解決問題之前，我們需要知道什麼是Binary Search Tree。根據BST的定義:
Binary Search Tree 基於Binary Tree left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value Binary Search Tree的key/value都是unique的 現在我們知道什麼是BST了。這個問題是要在BST中找val，我們通過以下幾個條件以及遞歸幫我們求解:
left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value 如果val是小於root,就移動到左子樹(left sub-tree)，否者移動到右子樹(right sub-tree),直到找到val並返回root的pointer或者沒有找到返回null
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(root == nullptr) return root; //check val if(root->val > val){ //go to left return searchBST(root->left,val); // }else if(root->val &lt; val){ return searchBST(root->right,val); }else{ return root; } } };</content></entry><entry><title>[Leetcode] Shift 2D Grid(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1260/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag></tags><content type="html"> LeetCode 1260 - Shift 2D Grid Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times.
example
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] How can we solve this problem? 其實這個問題很簡單，我們只需要關心grid的最後得column，因為最後一個Column被right-shift到第一個Column的時候，最後一個element會被移動到0th。其餘的column只要right-shift by 1 step即可。 我們可以參考以下數學公式:
n是row size 以及 m 是 column size
left-shifting : currentColum + k % n, moving by k step shifting row : (j + k) / n), if it is in the last column, (j + k) / m will be 1. Otherwise will be 0 total row shifting step : (i + (j + k) / n)) % m. For example, suppose n = 3 , j = 2 , m = 3 and i = 2: (2 + ((2+1)/3)) % 3 = 0 so that it will move to [0][0] Solution: class Solution { public: vector&lt;vector&lt;int>> shiftGrid(vector&lt;vector&lt;int>>&amp; grid, int k) { //just be careful the last element on [m-1][n-1] //n - k int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); for(int i = 0 ;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ //here we need to know how many time does the colums j pass the col 0,then we need to movie the i of that time // (j + k) % m => total time walk passed int moveJ = (j + k) % m; //if current moving j is the last one int walkPassedZeorTimes = (j + k)/m; int moveI = (i + walkPassedZeorTimes) % n; res[moveI][moveJ] = grid[i][j]; } } return res; } };</content></entry><entry><title>[Leetcode] Spiral Matrix II(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode59/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 59 - Spiral Matrix II Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
example
Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Input: n = 1 Output: [[1]] How can we solve this problem? 這題跟Spiral Matrix做法差不多，我們不難發現他的移動模式就是(右→下↓左←上)，我們只需要通過幾個變數來限制移動的步數。另外，這題需要我們返回一個n2的array，所以，需要額外定義一個counter來記錄每次插入的數值為多少，因此，只要counter 到達n2的大小就知道是否完成插入所需的值。
YES! You Can! Let me explain how it works. According to the example, we can find out its moving pattern(`top-left to top-right`,`top-right to bottom-right`,`bottom-right to bottom-left` and `bottom-left to top left`), it always follows these 4 moving patterns, so that we can define a boundary of row and column to limit pointer moving to has inserted a number. Until reaching n2, it will break the loop and return the answer. -- Solution: 2, then return the answer -- class Solution { public: vector&lt;vector&lt;int>> generateMatrix(int n) { //total step n^2 vector&lt;vector&lt;int>> res(n,vector&lt;int>(n,0)); int c = 1; int upperRow = 0,lowerRow = n - 1; int upperCol = 0,lowerCol = n - 1; while(c &lt;= n*n){ //moving left if(upperCol &lt;= lowerCol){ //n step for(int i = upperCol;i&lt;=lowerCol;i++){ res[upperRow][i] = c++; } } upperRow ++; //moving down //moving down if(upperRow &lt;= lowerRow){ for(int i = upperRow;i&lt;=lowerRow;i++){ res[i][lowerCol] = c++; } } lowerCol--; //moving right if(lowerCol >= upperCol){ for(int i = lowerCol;i>=upperCol;i--){ res[lowerRow][i] = c++; } } lowerRow --; //moving up if(lowerRow >= upperRow){ for(int i = lowerRow;i>=upperRow;i--){ res[i][upperCol] = c++; } } upperCol ++; } return res; } };</content></entry><entry><title>[Leetcode] Game of Life(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode289/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 289 - Game of Life According to Wikipedia&rsquo;s article: &ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&rdquo;
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.
example
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] How can we solve this problem? 要解決這個，我們需要知道目前的cell的狀態(活/死)。要知道目前cell的狀態，我們可以用過條件判斷他身邊的cells(最多9個細胞)即可。
Solution: class Solution { public: void gameOfLife(vector&lt;vector&lt;int>>&amp; board) { int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); //O(N^2 for checking each cells) : time //O(N^2 for storing new cells states) : space for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ int total = checkState(board,i,j,n,m); if(board[i][j] == 1) res[i][j] = (total &lt; 2 || total > 3 ) ? 0 : 1; else res[i][j] = total == 3 ? 1 : 0; } } board = res; } int checkState(vector&lt;vector&lt;int>>&amp; board,int i,int j,int n,int m){ // //neighbors bounds // int rowStart = (i - i) &lt; 0 ? 0 : i - 1; // int rowEnd = (i + 1) > n - 1 ? n - 1 : i + 1; // int colStart = (j - 1) &lt; 0 ? 0 : j - 1; // int colEnd = (j + 1) > m - 1 ? m - 1 : j + 1; int livesCells = 0; //top left if(i - 1 >= 0 &amp;&amp; j -1 >= 0){ livesCells += board[i-1][j-1]; } //top if(i - 1 >= 0){ livesCells += board[i-1][j]; } //top right if(i - 1 >= 0 &amp;&amp; j + 1 &lt; m){ livesCells += board[i-1][j + 1]; } //left if(j - 1 >= 0){ livesCells += board[i][j - 1]; } //right if(j + 1 &lt; m){ livesCells += board[i][j + 1]; } //bottom left if(i + 1 &lt; n &amp;&amp; j - 1 >= 0){ livesCells += board[i+1][j-1]; } //bottom if(i + 1 &lt; n ){ livesCells += board[i+1][j]; } //bottom right if(i + 1 &lt; n &amp;&amp; j + 1 &lt; m){ livesCells += board[i+1][j+1]; } return livesCells; } };</content></entry><entry><title>[Leetcode] Baseball Game(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode682/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 682 - Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&rsquo; scores.
At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:
An integer x - Record a new score of x. &ldquo;+&rdquo; - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. &ldquo;D&rdquo; - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. &ldquo;C&rdquo; - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. example
Input: ops = ["5","2","C","D","+"] Output: 30 Explanation: "5" - Add 5 to the record, record is now [5]. "2" - Add 2 to the record, record is now [5, 2]. "C" - Invalidate and remove the previous score, record is now [5]. "D" - Add 2 * 5 = 10 to the record, record is now [5, 10]. "+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Input: ops = ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation: "5" - Add 5 to the record, record is now [5]. "-2" - Add -2 to the record, record is now [5, -2]. "4" - Add 4 to the record, record is now [5, -2, 4]. "C" - Invalidate and remove the previous score, record is now [5, -2]. "D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. "9" - Add 9 to the record, record is now [5, -2, -4, 9]. "+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. "+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. How can we solve this problem? 這題就是一個簡單的籃球比賽模擬。我們只要關心遊戲rule，並透過額外的container(array/stack)進行分數保存即可。
Solution: class Solution { public: int calPoints(vector&lt;string>&amp; ops) { //ops : + D C x // vector&lt;int> s; //or using a stack stack&lt;int> sk; //O(n) //O(n) for(auto i : ops) { if(i == "+"){ int a = sk.top(); sk.pop(); int b = sk.top(); sk.push(a); sk.push(a+b); }else if(i == "D"){ sk.push(sk.top() * 2); }else if(i == "C"){ sk.pop(); }else{ sk.push(stoi(i)); } } int res = 0; //O(n) while(!sk.empty()){ res += sk.top();sk.pop(); } return res; } };</content></entry><entry><title>[Note]Creational Singleton Pattern</title><url>https://ryantokmanmokmtm.github.io/post/creational-singleton-pattern/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Singleton Pattern(單例模式)呢? 定義:一個Class在系統中只會存在一個實例(instance),整個系統中只提供1個可使用的instance,以確保唯一性,並節省系統資源。
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
class的建構子(constructor)對外隱藏,外部無法通過constructor進行實例化，但會提供一個靜態(static)方法，以獲取這個class的唯一實例。 TaskManager
//Constructor 對外隱藏，並提供一個靜態Static 讓外部只透過這個存取 class TaskManager{ private: TaskManager(); void displayProcess(); void displayServices(); static TaskManager* taskManager = nullptr; //保存唯一Instance public: //外部只能透過靜態Static 方法存取 並new一個TaskManger的Instance 如果是null的 //此方法為工廠 static TaskManager* getInstance(){ if(taskManager == nullptr){ taskManager = new TaskManager(); } return TaskManager; } } LoadBalance
//LoadBalance 🌰 //用於計算服務器負載，所以必須使用單例 class LoadBalance{ public: static LoadBalance* getInstance(){ if(loadBalance == nullptr){ loadBalance = new LoadBalance(); } return LoadBalance; } private: static LoadBalance* loadBalance; LinkedList* serverList = nullptr; LoadBalance(); void addServer(std::string server){ serverList->add(server);//add a server } std::string getServer(){ int i = random()% serverList->length(); //random get server return serverList->get(i); } } int main(){ LoadBalance *balancer1,*balancer2,*balancer3,*balancer4; balancer1 = LoadBalance::getInstance(); //獲取LoadBalance，這裡會先new 再return balancer2 = LoadBalance::getInstance(); //獲取LoadBalance balancer3 = LoadBalance::getInstance(); //獲取LoadBalance balancer4 = LoadBalance::getInstance(); //獲取LoadBalance //以上4個balancer 都應該為同一記憶體 if(balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) printf("Balancer is nnique"); //add server balancer1->addServer("server1"); balancer1->addServer("server2"); balancer1->addServer("server3"); balancer1->addServer("server4"); for(int i = 0;i&lt;10;i++){ printf("server %d",balancer1->getServer()); } return; } Singleton的問題 因為外部不能實例化，哪應該什麼時候實例化它呢?
從上面例子可以觀察到，第一次使用到getInstance()的時候,會先判斷是否為空,是的話會先實例化並保存pointer,然後再返回Instance。
如果在多線程(Multi-threading)下，同時call getInstance() 會這樣呢?
沒錯!就會導致違反了Sington的目的，導致系統錯誤的嚴重後果。
假如TA和TB 2個Thead 同時call getInstance(),此時這個instance是為null，所以他們都會同時滿足if(instance == null),並進行new instance,導致系統記憶體中會有2個Instance.
哪要如何解決呢?
以下提供了2個方法來解決
餓漢式 在定義class的時候就先把static variable先給實例化，因此，在加載時候就已經被實例化了。 可以想象成不管要不要用(吃)，先實例化了再說(把食物買了再說) (就怕自己會餓死 xD 問題: 可能會浪費資源，因為有可能會出現不使用的情況出現。 懶漢式 要使用的時候，先檢測是否存在，再實例化(就是上面例子一樣) 問題 1: 在多線程的情況下，會變得不安全。為了確保線程安全，就必須要用到Mutex進行保護(會增加開銷) 問題 2: 雖然有加上鎖，但是有可能線程會一起進入if 判斷，等一個thread解鎖了，另外一個還是會重新new 新的一個。因此，要在裡面加多一個if來判斷是否為null。這個稱為double-Check Locking 能克服餓漢式 以及 懶漢式的方法:
在Class內部定義static class來進行實現
因為static Singleton* instance 並不是Class Singleton的成員(Member)，所以在加載時候，不會被實例化，只有呼叫了getInstance 的時候才會被實例化。
class Singleton { private: Singleton() {} static class HolderClass { private: static Singleton* instance = new Singleton(); } public: static Singleton getInstance() { return HolderClass::instance } } } 優點 為系統提供了唯一的Instance 因只有一個Instance,能節省系統資源 在Singleton 模式中，除了唯一的，也可以提供指定數量的Instance，以解決分享過多造成的性能問題 缺點 難以擴展，因為Singleton 不是由 Abstract Class實現 違背原則 有點違反單一職責原則(Single-responsibility Principe) 因又是工廠的角色(new instance),又是Product的角色(返回Static 獲取實例) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Leetcode] Top K Frequent Elements(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode347/</url><categories><category>leetcode</category></categories><tags><tag>map</tag><tag>priority queue</tag><tag>array</tag></tags><content type="html"> LeetCode 347 - Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
example
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] How can we solve this problem? 這一題需要我們返回K個數量最多的element。所以，我們可以使用map記錄我們array中element的個數，然後在把他們以&lt;frequency,element>存到priority queue/max queue，最後只要返回priority queue中的k個element即可。
Solution: class Solution { public: vector&lt;int> topKFrequent(vector&lt;int>&amp; nums, int k) { vector&lt;int> res; unordered_map&lt;int,int> map; priority_queue&lt;pair&lt;int,int>> q; for(auto i : nums) map[i]++; //counter numbers for(auto it : map) q.push({it.second,it.first}); //according to the second for priority while(k-- > 0) { res.push_back(q.top().second); q.pop(); } return res; } };</content></entry><entry><title>[Leetcode] Kth Largest Element in a Stream(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode703/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 703 - Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. example:
Input ["KthLargest", "add", "add", "add", "add", "add"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 How can we solve this problem? 首先，我們要知道這個問題在問什麼。很簡單，這個問題問的是array中k個大元素。舉例 [1,2,3,4,5 ] k=3，需要我們求出三個最大的element，所以會是[3,4,5]。因此。我們只需要關心最大的K的element即可，其他都可以拋棄掉。
th largest element in the array, so we just need to know what the largest kth elements are. For example `[1,2,3,4,5 ] k=3`, the largest 3 elements are `[3,4,5]` right?. Therefore, we just need to consider the top k elements in the array and the other elements will be discarded. -- Solution: class KthLargest { private: priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; int k; public: KthLargest(int k, vector&lt;int>&amp; nums) { for(auto e : nums) { q.push(e); if(q.size() > k) q.pop(); } this->k = k; } int add(int val) { q.push(val); if(q.size() > k) q.pop(); return q.top(); } };</content></entry><entry><title>長庚大學-畢業專題獎項</title><url>https://ryantokmanmokmtm.github.io/achievement/my-first-reward/</url><categories><category>CGU</category><category>Reward</category></categories><tags/><content type="html"> Reward 這是我跟組員們一起討論、辛苦了多個日夜，能一起做寫程式，分享知識的感覺真的很棒>&lt;。雖然不知道以後還沒有機會一起合作，但還是非常感謝他們願意陪我躲在實驗室裡面一整天(╥╯^╰╥)。希望他們能好好生活，好好學習！
My Teammates</content></entry><entry><title>[Note]Creational Abstract Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-abstract-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Abstract Factory(抽象工廠)呢? 定義: 又稱為Kit模式。提供一個創建系列相關或者互相依賴的Interface，而無需指定其具體的class
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過定義不同組件的Abstraction類,並把Abstraction類組合在一起。通過繼承抽象工廠的方式，定義不同的工廠類，生成不同的Product。 由以下例子可見，有2組不同的UI分別是Summary以及Spring，他們都分包實現了Abstraction 類，然後在透過實現各自的工廠類，生成Summary以及Spring的Product //🌰UI //Button TextField ComboBox //Abstract Class UI class Button{ public: virtual void display() = 0; } class TextField{ public: virtual void display() = 0; } class ComboBox{ public: virtual void display() = 0; } //Abstract Class Factory //用於把不同類型的UI/主題Group 在一起 class UIFactory { public: virtual Button* createButton() = 0; virtual TextField* createTextField() = 0; virtual ComboBox* createComboBox() = 0; } //Spring class SpringButton : public Button{ public: void Draw(){ //Draw Spring style Button } } class SpringTextField : public TextField{ public: void Draw(){ //Draw Spring stype TextField } } class SpringComboBox : public ComboBox{ public: void Draw(){ //Draw Spring stype ComboBox } } //Summer class SummerButton : public Button{ public: void Draw(){ //Draw Summer style Button } } class SummerTextField : public TextField{ public: void Draw(){ //Draw Summer style TextField } } class SummerComboBox : public ComboBox{ public: void Draw(){ //Draw Summer style ComboBox } } //Factory class SpringFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SpringButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SpringTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SpringComboBox(); return ComboBox; }; } //SummerFactory class SummerFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SummerButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SummerTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SummerComboBox(); return ComboBox; }; } int main(){ //就是透過工廠生成接口生成不同的工廠 //再透過不同的工廠調用其生產的product //Summer 工廠 UIFactory* factory = new SummerFactory(); Button* button = factory->createButton(); TextField* textField = factory->createTextField(); ComboBox* comboBox = factory->createComboBox(); button->draw(); //畫出Summer Style的Button textField->draw(); //畫出Summer Style的textField comboBox->draw(); //畫出Summer Style的comboBox return; } 優點 解決工廠模式中每個產品都使用一個工廠的生產的問題 新增產品很方便，擴展產品以及工廠即可(增加統一產品族) 擁有工廠模式的優點 缺點 如果要新增產品等級結構必須修過工廠抽象類，違反Open-Close 原則(增加產品等級結構) 唯一缺點就是開閉原則的傾斜性 何謂開閉原則的傾斜性呢? 就是在新增產品族(不同類型，相同產品)的時候可以符合開閉原則,但是在新增產品等級結構(同一類型，新增產品/不同的產品類型/等級)時候,必須修改抽象類。這個問題無法解決，只能透過設計避免。 例子 新增A的產品族，只需實現工程類以及實現產品類型，即可新增一個新的工廠用於生成新產品(符合Open-Close) 新增A的類型(如一個新的UI原件:IMG),這樣就必須要修改abstract class以及concrete class的內部(違反Open-Close) 抽象工廠模式跟工廠模式的區別 模式 區別 工廠模式(Factory Pattern) 每一組相關的Product都由同一個具體工廠生產 抽象工廠模式(Factory Pattern) 每個產品族(product)都由同一個具體工廠生產 例如:
電器(同牌子/同一產品族)/電器(同電器(如都是冰箱)/同一產品等級結構)
產品等級結構: 產品的繼承結構,例如:同一種類的產品(如:同一電器但不同牌子)產品族:同一工廠生產的，位於不用產品等級結構的一組產品,例如:同一族群的產品(如:同一牌子的不同電器) 抽象工廠模式(abstract factory pattern)使用場合 當一個工廠的可以創立出屬於不同產品的等級結構的一個產品族中的所有對象時,此時使用抽象工廠模式更有效率和簡單
系統不應該依賴具體的細節(如何創建,表達細節等&hellip;)，依賴於抽象(所有工廠模式都一樣) 系統中多於一個產品族時，而每次只會使用到某一個產品族。可通過配置文件動態修改產品族 約束:屬於同一產品族的產品將在一起使用(同一類)，而這些產品可以沒有任何關係，但有相同約束(同一工廠) 產品等級結構穩定，在設計完成後不會在系統更改/刪除產品等級結構(開閉原則的傾斜性) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Simple RateLimiter Example Based on IP</title><url>https://ryantokmanmokmtm.github.io/post/simple-rateLimiter-example-based-on-IP/</url><categories><category>golang</category><category>backend</category><category>note</category><category>system design</category></categories><tags><tag>gin</tag><tag>rate limiter</tag></tags><content type="html"> 基於Gin實作Rate Limiter 假設我們有2個APIs,而每個API都需要消耗1個Tokens
uri method desc /api/posts/{id} GET return a simple demo message /ping GET return pong 我們先設置一下rate limiter桶子的容量只能放下一個tokens,而tokens則會每秒生產5個。存取API時,若沒有Token可以用，就需要等待token下一次生產並放到桶子裡，才能繼續進行下去。
var ( Rate = rate.Every(time.Millisecond * 200) //1s x 10 token ReqLimiter = rate.NewLimiter(RateLimiterRate, 1) ) Post API Controller exapmle type PostCase struct { } func (p *PostUseCase) GetPost(ctx *gin.Context) { //get params id id := ctx.Param("id") //from the path //use a token if err := limiter.ReqLimiter.Wait(ctx); err != nil { ctx.JSON(http.StatusRequestTimeout, gin.H{}) return } //wait for a token is available or return ctx.JSON(http.StatusOK, gin.H{ "msg": "succeed:" + id, }) } Ping API Controller exapmle type HealthCheck struct { } func (hc *HealthCheck) Pong(ctx *gin.Context) { limiter.ReqLimiter.Wait(ctx) ctx.JSON(http.StatusOK, gin.H{ "msg": "Pong", }) } 基於ClientIP 的Rate limiter 由於上面的的例子都是所有人公用一個Rate Limiter，因此，我們這裡簡單實作一個基於IP的Rate Limiter,相同IP下會公用一個Rate Limiter。
實作思路如下:
定義Map用於保存不同IP下的Rate Limiter 定義Rate Limiter的結構 定義一個移除Rate Limiter的function 用於移除不在線的用戶(只會跑一次) 保存Limiter的結構 包含了2個成員(Member):
Limters: 主要是用於保存不同IP下的Limiter(storage) Lock : 因為有可能會有很多人同時存取這個Map,為了防止Race condition,因此需要使用Mutex進行保護 type Limiters struct { Limiters map[string]*Limiter Lock sync.Mutex } 定義Rate Limiter的結構 包含了3個成員(Member):
Limter : 一個rate limiter的實例 LastAccess : 上次存取這個limiter的時間 type Limiter struct { limiter *rate.Limiter lastAccess time.Time } 定義獲取Rate Limiter的Function 這個function主要做的事情是獲取Client IP的Rate limiter(如果存在)。如果不存在,會新建一個新的Rate Limiter，並保存到Map(storage)中。
func (ls *Limiters) GetLimiter(r rate.Limit, b int, key string) *Limiter { ls.Lock.Lock() defer ls.Lock.Unlock() if limiter, ok := ls.Limiters[key]; ok { return limiter } newLimiter := &amp;Limiter{ limiter: rate.NewLimiter(r, b), lastAccess: time.Now(), //key: key, } ls.Limiters[key] = newLimiter return newLimiter } 定義一個定期檢查Rate Limiter的function 這個function的主要作用的是在設定的時候到達時，會檢查是否有用戶的沒有存取/訪問的時間已超過設定的時間。如果已超過便會從Limiters的Map中移除，以免資源的浪費
func (ls *Limiters) ClearNotUseLimiter(sec time.Duration) { for { time.Sleep(sec) //for now just set 1-minutes for testing //for all limiter for key, l := range ls.Limiters { if time.Now().Sub(l.lastAccess) > sec { ls.Lock.Lock() delete(ls.Limiters, key) log.Printf("limiter for ip:%v is removed", key) ls.Lock.Unlock() } } } } 實作例子 因為每個Request被處理前，必須先確保此用戶(Client IP)沒有超過限制的Request的數目。所以,每個進來的Request都會先經過Middleware做預處理，獲得token後，才能進到處理的程序。
Limiter Middleware 這個Middleware中會透過Request Header(context)裡附帶的Client IP 獲得一個Limiter,並透過此Limiter檢查是否可以獲取Token，如果存取為False會直接response 一個錯誤訊息TooManyRequest
func RateLimiter() gin.HandlerFunc { return func(ctx *gin.Context) { clientIP := ctx.ClientIP() res := app.NewResponse(ctx) if clientIP == "" { res.ErrorResponse(errCode.ClientError.WithDetail("Client agent info not found or error")) ctx.Abort() } //log.Println(clientIP) //limiter : 10 request for each user and a token will generate after 1s l := newLimiters( //1s to generate a token rate.Every(global.AppSetting.LimiterTokenTime), global.AppSetting.LimiterBucketSize, //there are total 10 buckets clientIP) if !l.Allow() { res.ErrorResponse(errCode.TooManyRequest) ctx.Abort() } ctx.Next() } } 獲取Rate Limiter的function如下圖所示。細心的朋友可以發現這個包含了1個onceTask.Do的東西，其實他就是一個go語言內置允許function只跑一次的情況。透過onceTask.Do就可以實現一個Function只跑一次，無論呼叫了幾次同一個function,這個function也會只跑一次，直到程序結束。
這個onceTask.Do所做的事只有1件，也就是檢測是否有用戶不活躍，不活躍的用戶會被移除。它另外一條goroutine中進行，並不會堵塞主goroutin
func newLimiters(r rate.Limit, b int, key string) *limiter.Limiter { onceTask.Do(func() { log.Println("run once") go global.Limiters.ClearNotUseLimiter(global.AppSetting.LimterClearTime) }) return global.Limiters.GetLimiter(r, b, key) } 以上便是基於IP實作Rate Limiter的簡單方法
參考資料:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><url>https://ryantokmanmokmtm.github.io/post/token-bucket-intro/</url><categories><category>golang</category><category>backend</category><category>note</category><category>algorithm</category><category>system design</category></categories><tags><tag>golang package</tag><tag>rate limiter</tag></tags><content type="html"> Token Bucket(令牌桶算法) 什麼是Token Bucket 呢? 簡單來說就是運用Token Bucket的系統會以一個設定的速率往桶子(Bucket)裡面丟令牌(Token)。如果請求(Request)需要被處理時，就必需得Bucket裡的Token。當桶子裡面的沒有Token可以分配/獲取時，也就是說Bucket現在是空的(Token已經被其他令牌拿完了)，系統則會拒絕這個請求的服務。
根據算法(Algorithm)的定義:
A token is added to the bucket every 1/r seconds. 一個Token會以每1/r秒加入到Bucket裡面。 The bucket can hold at the most b tokens. If a token arrives when the bucket is full, it is discarded. Bucket可以保存最多b個tokens。如果在bucket以及滿了的情況下，有一個token被加入到bucket，這個token會被丟棄 例子: 假設一個n bytes的packet(封包)送達 假設目前最少有n個token在桶子裡面，這n個token就會被拿出來，然後packet就會被送到網絡上(剛好n bytes 封包有n個tokens) 假設目前桶子裡面可存取的tokens少於n個，就不會有tokens被拿出來(因為需要n個tokens 才能傳送n bytes的封包)，這個封包會被考慮為不符合的封包/不合規的封包 Go 實現/使用Token Bucket Go 的time/rate package 提供了Limiter的實作，而這個Limiter便是實作了Token Bucket的方式來達到限流的目的。
今天我們就來學習一下這麼使用go 提供Limiter來實作Rate Limiter
要如何新增一個Limiter呢? func NewLimiter(r Limit, b int) *Limiter
他有2個參數:
r: rate的type是Limit(一個float64的值)，表示著每秒會產生多少個Token,也就是每1/r秒生產1個token到bucket裡 b: Token Bucket 的桶子的Capacity(容量) //r 設置100表示每秒會產生100個tokens到桶子裡面 1/100 s(1個) //b 設置為1表示桶子最多有1個token limiter := rate.NewLimiter(100,1) Limiter的使用方式 Limiter提供了多個Function: Allow,Reserve,Wait,AllowN,ReserveN,WaitN
最主要使用為以下的3個種Function(都會消耗一個Tokens):
Allow func (lim *Limiter) Allow() bool 是 AllowN(time.Now(), 1)的縮寫 它會消耗掉一個Tokens 如果有token的話會return true 否者會token不足 return false Reserve func (lim *Limiter) Reserve() *Reservation 是 ReserveN(time.Now(), 1)的縮寫 每次會消耗掉一個token 他主要的作用是保存event的資訊預約下一次的服務 Wait(用最多的function) func (lim *Limiter) Wait(ctx context.Context) (err error) 是 WaitN(ctx, 1)的縮寫 每次會消耗掉一個token 主要的作用就是等待直到被取消或者有足夠的Tokens Wait 會堵塞(block)直到有足夠的tokens才會往下執行 Allow func (lim *Limiter) Allow() bool func (lim *Limiter) AllowN(now time.Time, n int) bool Allow() 等價於(equivalent to) AllowN(time.Now(),1)
AllowN主要的作用
AllowN 表示的是在目前的時間點，是否能消耗n個token,如bucket存在n個token則 return true 否則 return false
是想要Drop或者Skip超過rate limit的events時使用 否則使用 Reserve 或者Wait取代 Use this method if you intend to drop / skip events that exceed the rate limit. Otherwise use Reserve or Wait.
//AllowN的例子: func AllowDemo() { //each token generated every 100ms with 5 bucket limiter := rate.NewLimiter(rate.Every(time.Microsecond * 100), 5) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ //each time we need 2 tokens if isAllowed := limiter.AllowN(time.Now(), 2); isAllowed { //bucket have enough tokens fmt.Println("Welcome!!!") fmt.Printf("user:%v is allowed in %v\n", counter, time.Now().Format(time.RFC3339)) } else { fmt.Printf("user:%v is not allowed.Please wait for 100ms and try again later\n", counter) //wait for 100ms time.Sleep(100 * time.Microsecond) } } } Reserve func (lim *Limiter) Reserve() *Reservation func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation Reserve() 等價於(equivalent to) ReserveN(time.Now(),1)
ReserveN的主要作用
ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
回傳一個Reservation 表面在event執行前需要等待多久，這個Reservation被limiter納入考量內
如果Reservation 的所需的token n超過bucket 的size時,Reservation 的OK()會return false
//Reserve例子: func ReserveDemo() { //each token generated every 200ms and each second will put at most 5 tokens to bucket limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 3) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ tokensNeeds := 2 reserve := limiter.ReserveN(time.Now(), tokensNeeds) if !reserve.OK() { //this event won't be completed due to the tokens its needs fmt.Printf("needed tokens %v is greater than the bucket size %v\n", tokensNeeds, limiter.Burst()) return } //wait for the reversing time fmt.Printf("Wait for %v ms...\n", reserve.Delay()) //if dely is 0 that means no need to wait~ time.Sleep(reserve.Delay()) //at least to wait for 200ms fmt.Printf("waiting is done and now is allowed to deal with some tasks...\n") fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC3339)) } } Wait func (lim *Limiter) Wait(ctx context.Context) (err error) func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) Wait(ctx) 等價於(equivalent to) wait(time.Now(),1)
waitN的主要作用
WaitN 每次需要消耗N個Tokens，如果Bucket沒有足夠的Bucket會堵塞，直到有足夠的Tokens(n)才會繼續往下只需。除非以下條件成立才會回傳錯誤:
所需消耗tokens n大於bucket的size Context 被取消 Context 已經超過設定的Deal line(等待時間超過了Deal line) //例子 func WaitDemo() { //at most 5 tokens will generate in a sec 200/1000=5 ctx := context.Background() limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 2) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ if err := limiter.WaitN(ctx, 2); err != nil { fmt.Println("error", err) return } //wait for 2 tokens. At most wait for 400ms fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC1123)) } } 設定Bucket 和 Rate 可透過func (lim *Limiter) SetBurst(newBurst int)設定 Bucket size
可透過func (lim *Limiter) SetLimit(newLimit Limit)設定 Limit/Rate
參考資料:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Creational-Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Factory(工廠)呢? 定義:建立一個接口,讓子類自己決定實現哪一個Factory,其重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
可透過子類繼承Factory的抽象類自主決定生產什麼樣的Product。 生產的Product在透過里氏替換原則(Lisko Subsititution princeple)替換成繼承與Logger的子類，即可換成的需要的Logger。 class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc... Logger* logger = new DatabaseLogger(); //init this logger etc... return logger } } //Client to use int main(){ Factory *factory = new FileLoggerFactory(); Logger *logger = factory->createLogger(); //return the Product that it is initialized Logger->wirteLog(); return; //如果想讓系統有更多靈活性和課擴展性，可以透過xml來進行配置，不需透過修過client的代碼 //只需更新xml中的設置，在代碼中新增新的Product 以及新增的Factory 並重新編譯便可 //除了默認的設置方法外，還想透過傳入String的方法來自定義設計，例如連接要DB，文件的路徑等等 //可以透過Override Abstruct class 的func來進行設置 /* class Factory{ public: virtual Logger* createLogger() = 0; virtual Logger* createLogger(string config) = 0; virtual Logger* createLogger(Object obj) = 0;//通過Obj裡面的成員進行設置等 } */ } 優點 Client無需知道Object的設置的細節，也無需知道實質Object的名稱，只需通過工廠即可 工廠(Factory)以及產品(Product)都是透過Polymorphism(多態)來實現，也是工廠模式的關鍵，工廠可以自主的決定要生產什麼產品，在內部進行設置產品(封裝在內部) 加入新的Product時無需修改Abstract class 以及 具體的工廠和產品的類，只要擴展新增即可，符合Open-Close principle 透過繼承抽象類使系統更容易擴展 缺點 新增產品時，要加入新的產品類以及工廠類，增加了系統的複雜度，而且需要從新編譯，增加了開銷 為了擴展性,加入了抽象類，Client都使用Abstract class 進行編程，增加了系統的抽象性和理解難度 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Creational-Simple Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-simple-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Simple Factory(簡單工廠)呢? 簡單而言就是: 由一個工廠來生產全部產品 定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過Factory 類的Static 方法調用方法，傳入參數生成相關的Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == "A"){ return new ProductA(); } else if(type == "B"){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct("A"); //get ProductA instance Product* B = Factory::getProduct("B"); //get ProductB instance } 優點 Client可以自行決定生產哪個Product Client免除直接建立Product的責任，只僅僅消費產品 Client無需關心具體的類名與相關設置參數 缺點 Factory 的職責太重。所有的Product 都由一個Object 生產，一旦不能正常工作，便會影響整個系統的運作 如有不同的Product會增加系統中的class的數目，增加了系統複雜度以及理解難度 擴展十分困難，添加需要修改Factory的邏輯。如果生存的Product較多時，可能會使其邏輯過於複雜，不利於系統的擴展與維護 違背原則 違背了Open-Close Principe 如果有新的Product 需要生成，就必修要修改Factory類 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Design Pattern Princeple</title><url>https://ryantokmanmokmtm.github.io/post/design-pattern-princeple/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>learning</tag><tag>note</tag></tags><content type="html"> 什麼是Design Pattern(設計模式)呢? 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，如何解決問題的一種方案
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。 設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
Design Pattern 有什麼原則呢? 原則(Princeple) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) Design Pattern 分成哪幾種呢? 主要分成3大類，一共23個
創建型模式(6個) 結構型模式(7個) 行為型模式(11個) 創建型模式(6個) 簡單工廠模式(Simple Factory Pattern) 工廠模式(Factory Pattern) 抽象工廠模式(Abstract Factory Pattern) 單例模式(Singleton Pattern) 原形模式(Prototype Pattern) 建立者模式(Builder Pattern) 結構型模式(7個) 適配器模式(Adapter Pattern) 橋接模式(Bridge Pattern) 組合模式(Composite Pattern) 裝飾模式(Decorator Pattern) 外觀模式(Facade Pattern) 享元模式(FlayWeight Pattern) 代理模式(Proxy Pattern) 行為型模式(11個) 職責鏈模式(Chain of Responsibility Pattern) 命令模式(Command Pattern) 解釋器模式(Interpreter Pattern) 迭代器模式(Iterator Pattern) 中介者模式(Mediator Pattern) 備忘錄模式(Memento Pattern) 觀察者模式(Observer Pattern) 狀態模式(State Pattern) 策略模式(Strategy Pattern) 板塊模式(Template Method Pattern) 訪問者模式(Visitor Pattern) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]What Is JWT(Json Web Token)-EN</title><url>https://ryantokmanmokmtm.github.io/post/jwt-note/</url><categories><category>backend</category><category>development</category><category>web develpment</category><category>note</category><category>english</category></categories><tags><tag>web develpment</tag><tag>token</tag></tags><content type="html"> What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:
Header Payload Signature JWT Header Header typically consists of two parts
type : what&rsquo;s the type of the token algorithm : what algorithm does this token use to sign/encrypt. such as SHA256,RAS or HMAC { "typ" : "jwt", "alg" : "HS256" } This information will be encoded by base64Url algorithm in order to generate the JWT Header
JWT payload In payload is typically saving some users information and other useful information.
Be carefulthat payload must not include any secret information due to base64Url algorithm is easy to be decrypted.
JWT Payload standard claims
{ "sub" :"",//subject "aud" :"",//audience "jti" :"",//jwt id "iat" :"",//Issued at "iss" :"",//Issuer - who is the publisher of the jwt "nbf" :"",//Not Before - JWT is not available before the time jwt set. // other user information that developer set //for example: "user_name" : "jackson_tmm", "email" : "admin@admin.com" } This information will be encoded by base64Url algorithm in order to generate the JWT Payload
Signature The Signature is used to authenticate whether information has been modified during transmission and authenticate the sender that sent this JWT.
To Generate JWT Token Following this function
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), your-256-bit-secret) And these three partes will be combined by a . as following format: xxx.yyy.zzz
//exmaple eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ How it work between Client and server sequenceDiagram Client-Server:POST /authentication {username:xxx..} Note over Client,Server: User logs in alt is authenticated Server-Client:HTTP Status:200 {"token":eyxxx.xx.x} Note over Server,Client: Loged in Succeed else Unauthorized Server-Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Loged in Failed end Client-Server: POST /user/profile {"Authorization":"Bear token"} Note over Server,Client: Get User Profile with token alt succeed Server--Client: HTTP Status:200 {"profile":eyxxx.xx.x} Note over Server,Client: Succeed and response a profile else Unauthorized Server--Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Unauthorized(token error) end</content></entry><entry><title>[CGU]Graduation Project</title><url>https://ryantokmanmokmtm.github.io/project/final-project/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> OTT Movies recommender system-IOS Client Project have been changed/updated
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database Demo Video
--</content></entry><entry><title>About me</title><url>https://ryantokmanmokmtm.github.io/about.html</url><categories/><tags/><content type="html"> 個人簡歷(中) Resume(EN) Introduction 你好~ 歡迎來到我的網站!
我是Jackson.tmm, 是一個從香港來到台灣讀大學的四年級學生。目前就讀於長庚大學-資訊工程學系(Computer Science And Information Engineering)。目前已經畢業了。我目前主要是研究學習後端開發的技術。
2020年 - 基於IOS的微博UI Clone 2020年 -第一次學習IOS開發的Demo 2020年 - 基於IOS的Netfilx UI Clone 2020年 - 第一次嘗試自學建模的作品 - 雷神之錘 2020年 - 第二次嘗試自學建模的作品 - 美國隊長盾 2020年 - 送給自己20歲的生日禮物的一顆排球模型 2020年 - 香港霓虹燈 2020年 - 模擬水還是很好玩的(渲染了12小時 (◑‿◐) ) 2020年 - 燈籠魚(Lophiiformes)作品 2020年 - 第一次學遊戲開發的作品 2021年 - 第一次網絡課學習建模的作業 2021年 - 第一次網絡課學習建模的結課作品(還沒上貼圖>&lt;,有空就上) 2022年 - 電影資源社群平台App 2023年 - 通訊軟體App Interest 跑步，打球，說唱，唱歌，看電影，看動漫 遊戲設計，遊戲美術，3D建模 搞設計，寫程式 跟朋友分享、交流 特別喜歡宇宙/人類起源相關的奇怪知識 Current Plan 學更多有關後端開發，系統設計相關的技術 學好英文(看電影不要看字幕，能更外國人交流的程度) 考好雅思 跑去考多益了 哈哈哈 (目前660 目標800+) 做好自己,不比較,但一起學習一起進步 Contact Me: Email @Jacksontmm in Telegram</content></entry></search>