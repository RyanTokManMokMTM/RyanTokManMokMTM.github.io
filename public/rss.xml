<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jackson.tmm</title><link>http://localhost:58072/</link><description>Recent content on Jackson.tmm</description><generator>Hugo</generator><language>zh-TW</language><lastBuildDate>Sun, 10 Nov 2024 15:29:39 +0800</lastBuildDate><atom:link href="http://localhost:58072/rss.xml" rel="self" type="application/rss+xml"/><item><title>2024年軟體工程師(Software engineer)面試總結</title><link>http://localhost:58072/post/share/2024-swe-interview-summary/</link><pubDate>Sun, 10 Nov 2024 15:29:39 +0800</pubDate><guid>http://localhost:58072/post/share/2024-swe-interview-summary/</guid><description>&lt;h2 id="簡介-intro">簡介 Intro
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b-intro">&lt;/a>
&lt;/h2>&lt;p>在過去的幾個月裡一直在找新的工作機會，從2024/8/27起開始在各大招聘平台投遞履歷以及約面談。這篇文章主要是想分享這段時間面試經歷以及復盤面試！&lt;/p></description></item><item><title>[筆記] 平衡樹 Balance Tree</title><link>http://localhost:58072/post/note/balance-tree/</link><pubDate>Thu, 31 Oct 2024 15:28:20 +0800</pubDate><guid>http://localhost:58072/post/note/balance-tree/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>在講述Balance Tree之前，我們先來看一種情況。現在我們根據數據來建立一棵Binary Tree，譬如說以下的數據 : [4,5,6,7,8,9,10], 我們就會建立出以下這顆Binary Tree:&lt;br>
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/helper/unblanceTree.png" alt="unbalance-tree" />&lt;/p>
&lt;p>從這顆樹上我們會發現它其實就只是一個Linked List，查詢/插入效率還是一樣是O(n)，為了解決這個問題這裡需要&lt;strong>平衡樹&lt;/strong>來幫忙解決。&lt;/p>
&lt;h2 id="什麼是平衡樹">什麼是平衡樹
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%af%e5%b9%b3%e8%a1%a1%e6%a8%b9">&lt;/a>
&lt;/h2>&lt;p>從上述可見，查詢的效率是取決於樹的深度，那是不是可以將過深的分支平均到其他分支，使得每顆子樹的深度都差不多，是不是就可以大大提高查詢效率了呢？因此，平衡樹(Balance tree)就是為了解決這個問題而誕生的！
將上述例子轉換成平衡樹的話，會變成這個樣子：
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/helper/balanceTree.png" alt="balance-tree" />&lt;/p>
&lt;p>這樣我們查詢的效率從O(n)減少到了O(logn)。&lt;br>
接下來會簡單介紹幾個比較常見的平衡樹&lt;/p>
&lt;h3 id="avl-樹avl-tree---self-balanced-binary-search-tree">AVL 樹(AVL Tree) - self balanced binary search tree
&lt;a class="header-anchor" href="#avl-%e6%a8%b9avl-tree---self-balanced-binary-search-tree">&lt;/a>
&lt;/h3>&lt;p>AVL樹又稱平衡二元樹，透過節點旋轉的方式使得子樹的高度差介於1之間，也就是說最深的子樹和最淺的子樹之間的高度不會大於1層。&lt;br>
AVL樹有以下特點：&lt;/p>
&lt;ol>
&lt;li>基於二元樹(BST)數據結構&lt;/li>
&lt;li>通過自旋的方式建構平衡樹&lt;/li>
&lt;li>每個節點保存1筆數據&lt;/li>
&lt;li>左右子樹是一棵平衡樹&lt;/li>
&lt;li>子節點保存1份數據&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>自旋方式&lt;/strong>
&lt;em>找到不平衡tree的根(root)節點對該節點做旋轉，也就是最近的一個祖先(ancestor)。&lt;/em>
&lt;strong>對不平衡樹的root的3個節點做旋轉，其他節點旋時暫時無視，旋轉過後再處理(放到合理的位置)&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>左子樹不平衡&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>左左旋轉 - LL rotation
就是左子樹的左邊跟右子樹不平衡，這個選擇比較簡單：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>對不平衡樹的根節點做&lt;em>右旋轉&lt;/em>就可以了。
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/helper/LL-rotate.png" alt="ll-rorate" />
&lt;em>在fig 2中，對A節點做了旋轉後，BR節點會變成了A節點的左子樹，因為BR節點在原本的樹中為右子樹，所以永遠都會在B節點的右邊且比A小。&lt;/em>&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>左右旋轉 - LR rotation&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>對不平衡樹的左子樹節點做左旋，再對根節點做右旋
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/helper/LR-rotate.png" alt="lr-rorate" />&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>右子樹不平衡 - 跟上面差不多，只是做反方向&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>右右不平衡 - RR rotation&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>對不平衡的根節點做&lt;em>左旋轉&lt;/em>
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/helper/RR-rotate.png" alt="RR-rorate" />
&lt;em>在fig 2中，對A節點做了旋轉後，BL節點會變成了A節點的右子樹，因為BRL節點在原本的樹中為左子樹，所以永遠都會在B節點的左邊且比A大。&lt;/em>&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>右左不平衡 - RL rotation&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>對不平衡樹的左子樹節點做右旋，再對根節點做左旋
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/helper/RL-rotate.png" alt="RL-rorate" />&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>平衡樹的問題&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>數據多時，自旋處理多&lt;/li>
&lt;li>數據多時，樹高度越來越高，影響查詢效率&lt;/li>
&lt;/ol>
&lt;h3 id="紅黑樹red-black-tree">紅黑樹(Red-black Tree)
&lt;a class="header-anchor" href="#%e7%b4%85%e9%bb%91%e6%a8%b9red-black-tree">&lt;/a>
&lt;/h3>&lt;p>紅黑色也就是字面上的意思，樹上只有黑色和紅色2種節點。其他紅色和黑色節點不能相鄰，要麼就是紅黑或者黑紅，不能是紅紅或者黑黑。而紅黑書有一下特點：1&lt;/p>
&lt;ol>
&lt;li>優化AVL tree旋轉多的問題，通過2次旋轉就能達到平衡&lt;/li>
&lt;li>分為紅色和黑色節點&lt;/li>
&lt;li>允許深子樹的高度不超過淺子樹高度的2x就可以，而非相差1層就要做旋轉。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>紅黑樹的操作&lt;/strong>&lt;/p>
&lt;h3 id="b樹b-tree家族">B樹(B Tree)家族
&lt;a class="header-anchor" href="#b%e6%a8%b9b-tree%e5%ae%b6%e6%97%8f">&lt;/a>
&lt;/h3>&lt;h4 id="b-樹">B 樹
&lt;a class="header-anchor" href="#b-%e6%a8%b9">&lt;/a>
&lt;/h4>&lt;h4 id="b-樹-1">B+ 樹
&lt;a class="header-anchor" href="#b-%e6%a8%b9-1">&lt;/a>
&lt;/h4>&lt;h4 id="b--樹">B- 樹
&lt;a class="header-anchor" href="#b--%e6%a8%b9">&lt;/a>
&lt;/h4>&lt;h2 id="總結-summary">總結 summary
&lt;a class="header-anchor" href="#%e7%b8%bd%e7%b5%90-summary">&lt;/a>
&lt;/h2>&lt;!-- 
### 為什麼需要平衡樹

### 平衡樹的類型以及簡單介紹
#### AVL Tree

#### Red black Tree

#### B-Tree &amp; B+ Tree

### 參考 --></description></item><item><title>[筆記] Mysql 事務</title><link>http://localhost:58072/post/note/mysql_transcation/</link><pubDate>Mon, 28 Oct 2024 12:23:35 +0800</pubDate><guid>http://localhost:58072/post/note/mysql_transcation/</guid><description>&lt;h3 id="什麼是事務">什麼是事務
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%af%e4%ba%8b%e5%8b%99">&lt;/a>
&lt;/h3>&lt;h3 id="鎖和mvcc">鎖和MVCC
&lt;a class="header-anchor" href="#%e9%8e%96%e5%92%8cmvcc">&lt;/a>
&lt;/h3></description></item><item><title>[筆記]MySQL 索引</title><link>http://localhost:58072/post/note/mysql_index/</link><pubDate>Mon, 28 Oct 2024 12:23:28 +0800</pubDate><guid>http://localhost:58072/post/note/mysql_index/</guid><description>&lt;h3 id="什麼是索引">什麼是索引
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%af%e7%b4%a2%e5%bc%95">&lt;/a>
&lt;/h3>&lt;h3 id="mysql中如何使用索引">MySQL中如何使用索引
&lt;a class="header-anchor" href="#mysql%e4%b8%ad%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95">&lt;/a>
&lt;/h3>&lt;h3 id="索引如何在查詢中快速搜尋">索引如何在查詢中快速搜尋
&lt;a class="header-anchor" href="#%e7%b4%a2%e5%bc%95%e5%a6%82%e4%bd%95%e5%9c%a8%e6%9f%a5%e8%a9%a2%e4%b8%ad%e5%bf%ab%e9%80%9f%e6%90%9c%e5%b0%8b">&lt;/a>
&lt;/h3></description></item><item><title>[筆記] B+ Tree</title><link>http://localhost:58072/post/note/b+_tree/</link><pubDate>Mon, 28 Oct 2024 12:23:11 +0800</pubDate><guid>http://localhost:58072/post/note/b+_tree/</guid><description>&lt;h3 id="什麼是b-樹">什麼是B+ 樹
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afb-%e6%a8%b9">&lt;/a>
&lt;/h3>&lt;p>我們先看看B+ tree的定義，再來看看他長什麼樣子：&lt;br>
**定義: **
B+ 樹是一種平衡樹(Balance Tree)，而B+ 樹可以包含二個或以上的子節點，所以是N元平衡樹。 B+ 樹的特點如下：&lt;/p>
&lt;ol>
&lt;li>子節點且非葉子節點中包含n個key，其n個key對應一棵n元樹&lt;/li>
&lt;li>葉子節點包含了key的全部的數據，數據只有在葉子節點中命中&lt;/li>
&lt;li>子節點包含了其子樹節點的最小/最大的key&lt;/li>
&lt;li>對於一棵m元的B+樹，每個子節點最多為m-1個key，也就是最多保存m-1筆紀錄。&lt;/li>
&lt;li>相連葉子節點通過pointer連結&lt;/li>
&lt;li>節點的元素key的左子樹都是小於這個key，右子樹都是大於或者等於它。&lt;/li>
&lt;li>子節點/葉子階段都是有序的&lt;/li>
&lt;/ol>
&lt;h3 id="b-樹操作">B+ 樹操作
&lt;a class="header-anchor" href="#b-%e6%a8%b9%e6%93%8d%e4%bd%9c">&lt;/a>
&lt;/h3>&lt;p>我們知道了B+ 樹有序的了，現在對它進行操作：&lt;/p>
&lt;ol>
&lt;li>查詢&lt;/li>
&lt;li>根據Key來對B+ tree進行Binary Search來查找。不論找到或者找不到，都會從Root到葉子走出一條路徑。&lt;/li>
&lt;li>從Root開始隨機查詢。&lt;/li>
&lt;li>插入
這裡會有不同的情況:&lt;/li>
&lt;li>移除&lt;/li>
&lt;/ol>
&lt;h3 id="參考">參考
&lt;a class="header-anchor" href="#%e5%8f%83%e8%80%83">&lt;/a>
&lt;/h3></description></item><item><title>說明</title><link>http://localhost:58072/english/init/</link><pubDate>Sat, 28 Sep 2024 21:51:01 +0800</pubDate><guid>http://localhost:58072/english/init/</guid><description>&lt;h3 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h3>&lt;p>開啟此分類的主要目的是想要學習英文這們語言。深知自己的英文能力沒有到很好，甚至是很爛。因此想要開啟一個分類來紀錄學習英文的過程。&lt;/p>
&lt;h3 id="方法">方法
&lt;a class="header-anchor" href="#%e6%96%b9%e6%b3%95">&lt;/a>
&lt;/h3>&lt;p>主要是會透過閱讀文章的方式來學習，從各個文章中學習不同的句子和單字。 但不會限制在於文章可能會出現不同形式來學習&lt;/p></description></item><item><title>71天的日本之旅</title><link>http://localhost:58072/memories/jp-trip/</link><pubDate>Sun, 14 Jul 2024 16:46:58 +0800</pubDate><guid>http://localhost:58072/memories/jp-trip/</guid><description>&lt;h2 id="71天---日本體驗生活">71天 - 日本體驗生活📝
&lt;a class="header-anchor" href="#71%e5%a4%a9---%e6%97%a5%e6%9c%ac%e9%ab%94%e9%a9%97%e7%94%9f%e6%b4%bb">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>2024年5月1日 ～ 2024年7月10日&lt;/strong>
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/jp/full-jp.png" alt="June" />&lt;/p>
&lt;h2 id="行程">行程
&lt;a class="header-anchor" href="#%e8%a1%8c%e7%a8%8b">&lt;/a>
&lt;/h2>&lt;ul>
&lt;li>東京✓
&lt;ul>
&lt;li>新宿 ✓&lt;/li>
&lt;li>原宿 ✓&lt;/li>
&lt;li>澀谷 ✓&lt;/li>
&lt;li>下北澤 ✓&lt;/li>
&lt;li>吉祥寺 ✓&lt;/li>
&lt;li>中野 ✓&lt;/li>
&lt;li>上野 ✓&lt;/li>
&lt;li>熱海 - 海上花火大會✓&lt;/li>
&lt;li>鐮倉 ✓&lt;/li>
&lt;li>江之島 ✓&lt;/li>
&lt;li>台場 ✓&lt;/li>
&lt;li>舞濱/迪士尼 ✓&lt;/li>
&lt;li>橫濱 ✓&lt;/li>
&lt;li>銀座 ✓&lt;/li>
&lt;li>池袋 ✓&lt;/li>
&lt;li>秋葉原 ✓&lt;/li>
&lt;li>春日部 ✓&lt;/li>
&lt;li>淺草 ✓&lt;/li>
&lt;li>豐島園 - 東京哈利波特影城 ✓&lt;/li>
&lt;li>東京車站 ✓&lt;/li>
&lt;li>阿佐谷 ✓&lt;/li>
&lt;li>高圓寺 ✓&lt;/li>
&lt;li>日本橋 ✓&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大阪✓
&lt;ul>
&lt;li>難波 ✓&lt;/li>
&lt;li>櫻川 ✓&lt;/li>
&lt;li>心齋橋 ✓&lt;/li>
&lt;li>櫻島 - 日本環球影城 ✓&lt;/li>
&lt;li>大阪城 ✓&lt;/li>
&lt;li>梅田 ✓&lt;/li>
&lt;li>恵美須町 - 通天閣 ✓&lt;/li>
&lt;li>奈良 - 奈良公園 ✓&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>京都✓
&lt;ul>
&lt;li>京都車站 ✓&lt;/li>
&lt;li>清水寺 ✓&lt;/li>
&lt;li>金閣寺 ✓&lt;/li>
&lt;li>八板神社 ✓&lt;/li>
&lt;li>春日大社 ✓&lt;/li>
&lt;li>平安神宮 ✓&lt;/li>
&lt;li>伏見稻荷大社 ✓&lt;/li>
&lt;li>御法神社 ✓&lt;/li>
&lt;li>京都國立博物館 ✓&lt;/li>
&lt;li>錦市場 ✓&lt;/li>
&lt;li>嵐山&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>名古屋✓
&lt;ul>
&lt;li>名古屋城 ✓&lt;/li>
&lt;li>名古屋站 ✓&lt;/li>
&lt;li>名古屋港水族館 ✓&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="感想">感想
&lt;a class="header-anchor" href="#%e6%84%9f%e6%83%b3">&lt;/a>
&lt;/h2>&lt;ul>
&lt;li>日本街道很乾淨&lt;/li>
&lt;li>食物有點鹹和沒什麼蔬菜卻還不錯吃&lt;/li>
&lt;li>東京JR很方便但線路很多有點麻煩&lt;/li>
&lt;li>食物種類不算很多&lt;/li>
&lt;li>夏天很熱切很乾燥&lt;/li>
&lt;li>女生都會化妝、包包會掛娃娃和鞋子都很高&lt;/li>
&lt;li>日本人都很有禮貌&lt;/li>
&lt;li>電車裡面很安靜&lt;/li>
&lt;li>新幹線有bug，出了新幹線的站但還在JR站，如果去了其他地方原本的車票就出不去，要去工作人員那邊補錢&lt;/li>
&lt;li>如果同一站出入必須去工作人員哪裡&lt;/li>
&lt;li>垃圾分類還挺麻煩的&lt;/li>
&lt;li>國內飛機航班比新幹線還便宜&lt;/li>
&lt;li>巴士都是先讓乘客下車，才到其他乘客上車&lt;/li>
&lt;li>巴士是後面上車，前門下車且下車在付款&lt;/li>
&lt;li>巴士的車費不論哪裡上車/下車都是同一車費&lt;/li>
&lt;li>東京都是坐電車、京都卻是巴士比較方便&lt;/li>
&lt;li>日本用英文不太能溝通&lt;/li>
&lt;/ul>
&lt;h2 id="整體感受">整體感受
&lt;a class="header-anchor" href="#%e6%95%b4%e9%ab%94%e6%84%9f%e5%8f%97">&lt;/a>
&lt;/h2>&lt;p>整體來說這趟路程雖然花了1,200,000+日幣，但是我覺得值得花這麼多錢去換來這麼一個體驗！如果下次還有機會，還是會繼續體驗的😁！&lt;/p></description></item><item><title>7月份的日本 - 結束</title><link>http://localhost:58072/memories/jp-july/</link><pubDate>Sun, 14 Jul 2024 16:46:54 +0800</pubDate><guid>http://localhost:58072/memories/jp-july/</guid><description>&lt;h2 id="7月份在日本體驗生活的日記">7月份在日本體驗生活的日記
&lt;a class="header-anchor" href="#7%e6%9c%88%e4%bb%bd%e5%9c%a8%e6%97%a5%e6%9c%ac%e9%ab%94%e9%a9%97%e7%94%9f%e6%b4%bb%e7%9a%84%e6%97%a5%e8%a8%98">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>2024年7月1日～2024年7月10日&lt;/strong>
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/jp/july.png" alt="May" />&lt;/p>
&lt;h2 id="行程">行程
&lt;a class="header-anchor" href="#%e8%a1%8c%e7%a8%8b">&lt;/a>
&lt;/h2>&lt;p>這是這趟旅程的最後的10天了，但是實際遊玩時間就只有9天而已。剩下的這9天也沒有浪費，也有去不同的地方看看。&lt;/p></description></item><item><title>6月份的日本</title><link>http://localhost:58072/memories/jp-june/</link><pubDate>Sat, 13 Jul 2024 23:44:29 +0800</pubDate><guid>http://localhost:58072/memories/jp-june/</guid><description>&lt;h2 id="6月份在日本體驗生活的日記">6月份在日本體驗生活的日記
&lt;a class="header-anchor" href="#6%e6%9c%88%e4%bb%bd%e5%9c%a8%e6%97%a5%e6%9c%ac%e9%ab%94%e9%a9%97%e7%94%9f%e6%b4%bb%e7%9a%84%e6%97%a5%e8%a8%98">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>2024年6月1日 ～ 2024年6月30日&lt;/strong>
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/jp/june.png" alt="June" />&lt;/p>
&lt;h2 id="行程">行程
&lt;a class="header-anchor" href="#%e8%a1%8c%e7%a8%8b">&lt;/a>
&lt;/h2>&lt;p>不知不覺得再日本度過了一個月，這個月除了在東京以外，還去了&lt;strong>大阪&lt;/strong>和&lt;strong>京都&lt;/strong>這2個原理東京的地方旅遊！&lt;br>
6月初的時候去了「藤子・f・不二雄博物館」參觀，這裡放了很多有關藤子・f・不二雄的創作經歷和作品，講述了創作「多啦A夢」之前的歷程。&lt;br>
隨後6月10號跟6月11號都去了「&lt;strong>東京迪士尼海洋&lt;/strong>」遊玩，因為之前迪士尼海洋6/6新開園區「&lt;strong>fantasy springs 夢幻泉鄉&lt;/strong>」開幕，然而新園區的遊樂設施必須要拿到DPA/預約等候卡才能進去。但是提早入園卷只有住飯店的人才能得到，所以我們為了確保能進入到新園區遊玩。但是迪士尼海洋一共有6個飯店，只有住在其中2個飯店「&lt;em>東京迪士尼海洋夢幻泉鄉大飯店&lt;/em>」以及「&lt;em>東京迪士尼樂園大飯店&lt;/em>」才能獲得。我們5月份刷了很幾天，終於是刷到了「東京迪士尼樂園大飯店」，雖然不是對著表演區，哈哈哈。6/10號的時候，我們就提著行李出發前往迪士尼海洋，當時還下著小雨呢。一到樂園就馬上去飯店checkIn和放下行李馬上就去遊玩，但幸運的是在等待其他遊樂設施的途中，讓我們意外的刷到了「&lt;strong>冰雪奇緣&lt;/strong>」的預約等候卡，超級幸運的，明天就可以少搶一個了，嘿嘿！晚上，我們買了海洋表演的DPA，雖然天氣的關係沒有看到煙花，但是這個表演還是很值得看的！！&lt;br>
6/11早上，我們拿著提早入園卷在外面等候，其實已經有很多人早早在外面等待了。一入園我們就馬上拿起手機開始搶！但是我的信用卡有問題搶DPA失敗，可惡，我們最後也成功拿到「&lt;strong>魔髮奇緣&lt;/strong>」的預約等號卡以及「&lt;strong>小飛俠&lt;/strong>」的DPA，雖然最後沒有成功拿到「&lt;strong>小仙子&lt;/strong>」的預約等號卡，但是「小飛俠」卻拿到了2次預約等號卡，哈哈哈，也算是有進到新園區多次了😌。在離開園區之前也再看了一次海洋的表演，真的很值得看，下次再去的話還是一樣會看完再離開。&lt;/p></description></item><item><title>5月份的日本</title><link>http://localhost:58072/memories/jp-may/</link><pubDate>Sun, 09 Jun 2024 01:59:34 +0900</pubDate><guid>http://localhost:58072/memories/jp-may/</guid><description>&lt;h2 id="5月份在日本體驗生活的日記">5月份在日本體驗生活的日記
&lt;a class="header-anchor" href="#5%e6%9c%88%e4%bb%bd%e5%9c%a8%e6%97%a5%e6%9c%ac%e9%ab%94%e9%a9%97%e7%94%9f%e6%b4%bb%e7%9a%84%e6%97%a5%e8%a8%98">&lt;/a>
&lt;/h2>&lt;p>&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/jp/may.png" alt="May" />&lt;/p>
&lt;h3 id="為什麼會在日本這麼久呢">為什麼會在日本這麼久呢
&lt;a class="header-anchor" href="#%e7%82%ba%e4%bb%80%e9%ba%bc%e6%9c%83%e5%9c%a8%e6%97%a5%e6%9c%ac%e9%80%99%e9%ba%bc%e4%b9%85%e5%91%a2">&lt;/a>
&lt;/h3>&lt;p>本來的計劃是去日本旅遊7天左右的，而且在2月底的時候機票和酒店都定好了，但是因為工作上的一些的原因，就從7天換成了2個月了，哈哈哈。因為酒店定了不能退，所以就在淺草那邊住了7天的酒店，然後就到朋友家住了，嘿嘿，快樂！&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP(完結) - 總結</title><link>http://localhost:58072/post/project/chat-app-final-summary/</link><pubDate>Sun, 21 Apr 2024 23:12:11 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-final-summary/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>Hi, 已經有一段時間沒有更新了，因為最近在研究多人串流的問題。這篇文章主要是分享我做了些什麼以及對這個project做個總結，這裡的意思就是這個project終於完成了！！花了我近1年的時間呢。&lt;br>
雖然這個project已完成，但是依然還有些問題，如果我們之後還有這個能力在修復～ 這些問題使得串流沒有這麼的穩定，但還是可以玩的呢！&lt;br>
在進入今天主題之前，如果你不記得或不知道這個project關於什麼的話，可以回去閱讀這幾篇文章：&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-story-alignment-updated/" title="ChatApp(Ⅶ)" >
 ChatApp(Ⅶ)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-story-multiple-img-updated/" title="ChatApp(Ⅷ)" >
 ChatApp(Ⅷ)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-sticker-shop-updated/" title="ChatApp(IX)" >
 ChatApp(IX)
 
&lt;/a>&lt;/p></description></item><item><title>2023年度總結(2023 annual summary)</title><link>http://localhost:58072/memories/summary-of-2023/</link><pubDate>Mon, 01 Jan 2024 19:43:15 +0800</pubDate><guid>http://localhost:58072/memories/summary-of-2023/</guid><description>&lt;h1 id="2023目標進度條目標">2023目標進度條目標：
&lt;a class="header-anchor" href="#2023%e7%9b%ae%e6%a8%99%e9%80%b2%e5%ba%a6%e6%a2%9d%e7%9b%ae%e6%a8%99">&lt;/a>
&lt;/h1>&lt;ul>
&lt;li>&lt;del>找到合適的工作&lt;/del> -&amp;gt; 算了找了工作&lt;/li>
&lt;li>競賽積分達到1700+ : 鴿了&lt;/li>
&lt;li>嘗試拿下Knight 段位 : 鴿了&lt;/li>
&lt;li>&lt;del>英文聽說讀寫好好練&lt;/del> -&amp;gt; 持續學習&lt;/li>
&lt;li>&lt;del>多參與活動&lt;/del> -&amp;gt; 參與的活動還是很多的&lt;/li>
&lt;li>&lt;del>考好雅思&lt;/del> -&amp;gt; 持續學習&lt;/li>
&lt;/ul>
&lt;h1 id="年初">年初
&lt;a class="header-anchor" href="#%e5%b9%b4%e5%88%9d">&lt;/a>
&lt;/h1>&lt;p>1月份的時候， 大概2年半快3年沒回家是時候應該要回家一趟了。於是就訂了1月10號的機票回家。或許是太久沒有踏入這個成長的地方感覺真的變的不一樣了，真的有種離鄉別井多年回到家的感覺，很懷念且很感動！然而這個時候還在疫情影響恢復的初期，所以大家都帶著口罩以免感染。在疫情這2年，我在台灣都沒有感染過，回來第一週就被感染，真的有夠不幸，嗚嗚嗚。不過我的症狀並沒有像網路上說的一樣呼吸困難，發燒等痛苦的症狀，只有喉嚨像被刀割。雖然很痛苦，但是一週後就康復了。很幸運，不用去住醫院，不幸的是我爸被我傳染了，但他也很快也就康復了！&lt;/p></description></item><item><title>香港迪士尼跨年(迪士尼第一次跨年活動)</title><link>http://localhost:58072/memories/last-day-of-2023/</link><pubDate>Sun, 31 Dec 2023 23:35:33 +0800</pubDate><guid>http://localhost:58072/memories/last-day-of-2023/</guid><description>&lt;p>因為2023年年初的時候有去香港迪士尼遊玩一天，就想著就在迪士尼來在完美的ending。於是便有了年尾去迪士尼度過最後一天的念頭，剛好今年迪士尼也是第一次舉辦跨年活動，開心！！！！&lt;br>
所以就想透過此文章記錄一次這個完美的時刻！嘿嘿😁&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 貼圖更新(III)</title><link>http://localhost:58072/post/project/chat-app-sticker-shop-updated/</link><pubDate>Sat, 11 Nov 2023 11:08:40 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-sticker-shop-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>如果您想了解該項目的內容，請閱讀以下文章&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-story-alignment-updated/" title="ChatApp(Ⅶ)" >
 ChatApp(Ⅶ)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-story-multiple-img-updated/" title="ChatApp(Ⅷ)" >
 ChatApp(Ⅷ)
 
&lt;/a>&lt;/p>
&lt;h2 id="demo">Demo
&lt;a class="header-anchor" href="#demo">&lt;/a>
&lt;/h2>&lt;p>&lt;video src="http://localhost:58072/videos/chat-app/sticker-shop.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;h2 id="簡介-1">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b-1">&lt;/a>
&lt;/h2>&lt;p>正如我在
&lt;a href="http://localhost:58072/post/chat-app-sticker-updated/" title="這篇文章" >
 這篇文章
 
&lt;/a>中提到的，我添加了一個關於貼紙的新功能，它可以在聊天中使用提供的貼圖資源。但這還不夠，對用戶來說也不靈活。因此，我開發了更多關於貼紙功能的內容。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 限時動態更新(III)</title><link>http://localhost:58072/post/project/chat-app-story-view-updated/</link><pubDate>Thu, 09 Nov 2023 20:23:44 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-story-view-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>如果您想了解該項目的內容，請閱讀以下文章。

&lt;a href="http://localhost:58072/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-story-alignment-updated/" title="ChatApp(Ⅶ)" >
 ChatApp(Ⅶ)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-story-multiple-img-updated/" title="ChatApp(Ⅷ)" >
 ChatApp(Ⅷ)
 
&lt;/a>&lt;/p>
&lt;h2 id="demo">Demo
&lt;a class="header-anchor" href="#demo">&lt;/a>
&lt;/h2>&lt;p>&lt;video src="http://localhost:58072/videos/chat-app/instance-story-view.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;h2 id="描述">描述
&lt;a class="header-anchor" href="#%e6%8f%8f%e8%bf%b0">&lt;/a>
&lt;/h2>&lt;p>在先前的版本中，用戶只能查看好友的故事並回覆該限時動態。它除了回覆故事之外不能和朋友有任何互動，所以在這個版本中，我打算為它添加更多的互動功能。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 限時動態更新(II)</title><link>http://localhost:58072/post/project/chat-app-story-multiple-img-updated/</link><pubDate>Sun, 10 Sep 2023 12:49:44 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-story-multiple-img-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>如果您想了解該項目的內容，請閱讀以下文章。

&lt;a href="http://localhost:58072/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;/p>
&lt;p>這是關於限時動態功能的demo，類似於instagram（我的UI參考來自instagram xD）。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 限時動態更新(I)</title><link>http://localhost:58072/post/project/chat-app-story-alignment-updated/</link><pubDate>Tue, 05 Sep 2023 20:19:33 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-story-alignment-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>如果您想了解該項目的內容，請閱讀以下文章。&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-sticker-updated/" title="ChatApp(VI)" >
 ChatApp(VI)
 
&lt;/a>&lt;/p>
&lt;h2 id="demo">Demo
&lt;a class="header-anchor" href="#demo">&lt;/a>
&lt;/h2>&lt;p>&lt;video src="http://localhost:58072/videos/chat-app/instance-story-alignment.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;h2 id="todo">TODO
&lt;a class="header-anchor" href="#todo">&lt;/a>
&lt;/h2>&lt;p>在先前的版本中，它確實允許用戶將多個&lt;code>文本&lt;/code>添加到他們的&lt;code>限時動態&lt;/code>中。但如果不使用眼睛就很難對齊所有文字項目。因此，在這個版本中，我決定添加一個對齊工具來幫助他們，這類似於「Instagram」對齊工具。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - 貼圖更新(I)</title><link>http://localhost:58072/post/project/chat-app-sticker-updated/</link><pubDate>Wed, 24 May 2023 21:32:47 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-sticker-updated/</guid><description>&lt;h2 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>關於這個專案我就不多說了，如果你對這個專案有興趣的話，請看我之前的貼文。在之前的文章中，我已經詳細介紹了這個專案。

&lt;a href="http://localhost:58072/post/chat-app-init/" title="ChatApp(I)" >
 ChatApp(I)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-demo/" title="ChatApp(II)" >
 ChatApp(II)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-update/" title="ChatApp(III)" >
 ChatApp(III)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-final/" title="ChatApp(IV)" >
 ChatApp(IV)
 
&lt;/a>&lt;br>

&lt;a href="http://localhost:58072/post/chat-app-voice-chat/" title="ChatApp(V)" >
 ChatApp(V)
 
&lt;/a>&lt;/p>
&lt;p>&lt;video src="http://localhost:58072/videos/chat-app/sticker-demo.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;p>在demo影片中，您可以看到貼圖功能與網路上任何其他即時通訊應用程式類似。用戶能夠存取我們提供的所有可用貼圖並將其發送給其他用戶或群組。但問題是我們如何提供使用者貼圖資源，貼圖從哪裡來呢？&lt;br>
為了解決第一個問題，我們可以透過在客戶端或使用者能夠存取它之前將所有必要的圖像上傳到伺服器來建立貼圖資源。每個建立的貼圖資源都會被分配一個唯一的ID作為其貼圖ID。與相同貼圖ID相關的所有資源都將以標準化格式重新命名，以便於存取。 &lt;code>stickerID_index.format&lt;/code>。&lt;/p></description></item><item><title>[Leetcode] Maximum Twin Sum of a Linked List(M)</title><link>http://localhost:58072/leetcodes/leetcode2130/</link><pubDate>Thu, 18 May 2023 15:44:17 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode2130/</guid><description>&lt;h2 id="leetcode-2130---maximum-twin-sum-of-a-linked-list">LeetCode 2130 - Maximum Twin Sum of a Linked List
&lt;a class="header-anchor" href="#leetcode-2130---maximum-twin-sum-of-a-linked-list">&lt;/a>
&lt;/h2>&lt;p>In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &amp;lt;= i &amp;lt;= (n / 2) - 1.&lt;/p>
&lt;p>For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.
The twin sum is defined as the sum of a node and its twin.
Given the head of a linked list with even length, return the maximum twin sum of the linked list.&lt;/p></description></item><item><title>[DONE] Chat App - 2024/04/20</title><link>http://localhost:58072/project/chat-app/</link><pubDate>Mon, 15 May 2023 13:49:17 +0800</pubDate><guid>http://localhost:58072/project/chat-app/</guid><description>&lt;p>
&lt;a href="https://github.com/RyanTokManMokMTM/swiftui-chat-app" title="Chat App - Frontend" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 &lt;strong>Chat App - Frontend&lt;/strong>
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;br>

&lt;a href="https://github.com/RyanTokManMokMTM/chat-app-server" title="Chat App - Backend" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 &lt;strong>Chat App - Backend&lt;/strong>
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/p>
&lt;p>&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/chat-app/2024-04-20-final.png" alt="new-ver" />&lt;/p>
&lt;h3 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h3>&lt;p>因為之前的&lt;code>OTT電影社群APP&lt;/code>中有包含通訊的功能，但是那個App所實現的功能就只是簡單的存文字聊天而已，而那個app主要的focus點並不在通訊上，所以只有簡簡單單的實作了通訊，沒有到完整的通訊，例如：發送文字，發送圖片，發送文件等等的通訊功能。所以這次的side project所實作的app則主要focus在&lt;strong>通訊&lt;/strong>這個點上。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP - RTC小更新</title><link>http://localhost:58072/post/project/chat-app-voice-chat/</link><pubDate>Sat, 13 May 2023 23:58:58 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-voice-chat/</guid><description>&lt;h4 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h4>&lt;p>我在
&lt;a href="http://localhost:58072/post/chat-app-init" title="[開發者日記] 聊天通訊APP(一)" >
 [開發者日記] 聊天通訊APP(一)
 
&lt;/a>中有提及過這app會有&lt;/p>
&lt;ul>
&lt;li>語音通訊&lt;/li>
&lt;li>視頻通訊&lt;/li>
&lt;/ul>
&lt;p>這次他們真的來了！！廢話少說先看視頻&lt;br>
&lt;video src="http://localhost:58072/videos/chat-app/voice-chat.mp4" controls="controls" width="500" height="300">&lt;/video>&lt;/p>
&lt;h4 id="說明">說明
&lt;a class="header-anchor" href="#%e8%aa%aa%e6%98%8e">&lt;/a>
&lt;/h4>&lt;p>雖然現在只有展示了語音通訊(Voice-chat),但是他們的工作原理其實是差不多的，就差在有沒有傳送視頻數據而已。老實說，這個功能其實言研究了2個月都不知道要從何入手，而github上的simple-demo又是UIKit的版本，所以就一直拖，一直研究。知道最近就想試試也無妨，最多也就不成功，萬一它成功了呢！於是我便開始寫，寫了1-2天，發現失敗了，哈哈哈。然後debug了一下，發現好像是沒有連接上的問題，於是又花了一整天來測試是否有成功連接，當成功連接上且文字數據傳送成功的那一刻，那個激動的心啊❤️！！！然後打開視訊，還真的成功了！！！！好開心！&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP(四) - 最終章</title><link>http://localhost:58072/post/project/chat-app-final/</link><pubDate>Mon, 01 May 2023 19:25:38 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-final/</guid><description>&lt;h3 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h3>&lt;p>在之前
&lt;a href="http://localhost:58072/post/chat-app-init" title="序章" >
 序章
 
&lt;/a>中，雖然已經大概介紹過這個app在幹嘛。但是因為這次是&lt;strong>最終章&lt;/strong>的成品展示(或許有些部分沒實現😂)，所以就允許我囉嗦得再說一次吧！&lt;/p>
&lt;p>這個app主要是focus在Websocket，也就是實時通訊上。雖然但是HTTP的部分還是不能少的🤣，哈哈哈。所以這個App的Server-side包含了HTTP和Websocket 2個部分。HTTP的部分主要是用作CURD,而Websocket的部分則是用於個人通訊和群組通訊。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP(三) - 聊天小更新</title><link>http://localhost:58072/post/project/chat-app-update/</link><pubDate>Sat, 29 Apr 2023 20:17:18 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-update/</guid><description>&lt;p>廢話少說直接上影片&lt;/p>
&lt;p>&lt;video src="http://localhost:58072/videos/chat-app/message-update1.mp4" controls="controls" width="500">&lt;/video>&lt;/p>
&lt;p>對上一次的
&lt;a href="http://localhost:58072/post/chat-app-demo/" title="demo" >
 demo
 
&lt;/a>中，雖然也包含了個人聊天和群組聊天的部分，但是只支援普通文本和圖片的傳送，而這次修復了文件發送，音頻發送已經視頻發送的部分。而音頻可以直接聆聽接收到的音頻，而視頻則可以直接觀看。&lt;br>
除此之外還添加了系統資訊，例如：群組的建立，群組加入，群組退出並通知群組人員。&lt;/p></description></item><item><title>[開發者日記] 聊天通訊APP(二) - Demo</title><link>http://localhost:58072/post/project/chat-app-demo/</link><pubDate>Mon, 24 Apr 2023 12:24:38 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-demo/</guid><description>&lt;p>這篇文章主要是展示一下整個App的Demo，廢話不多說，先上視頻:&lt;br>
&lt;video src="http://localhost:58072/videos/chat-app/full-demo-1.mp4" controls="controls" width="500" height="300">&lt;/video>&lt;/p>
&lt;h3 id="demo說明">Demo說明
&lt;a class="header-anchor" href="#demo%e8%aa%aa%e6%98%8e">&lt;/a>
&lt;/h3>&lt;p>這個App的詳細介紹在
&lt;a href="http://localhost:58072/post/chat-app-init" title="[開發者日記] 聊天通訊APP(一)" >
 [開發者日記] 聊天通訊APP(一)
 
&lt;/a>中已經有基本的介紹，這裡就不作過多的介紹了。&lt;br>
這裡主要是說明一下以上Demo中所展示的內容：&lt;/p></description></item><item><title>[開發日記] 聊天通訊APP(一) - 序章</title><link>http://localhost:58072/post/project/chat-app-init/</link><pubDate>Wed, 19 Apr 2023 17:08:14 +0800</pubDate><guid>http://localhost:58072/post/project/chat-app-init/</guid><description>&lt;p>因為之前的&lt;code>OTT電影社群APP&lt;/code>中有包含通訊的功能，但是那個App所實現的功能就只是簡單的存文字聊天而已，而那個app主要的focus點並不在通訊上，所以只有簡簡單單的實作了通訊，沒有到完整的通訊，例如：發送文字，發送圖片，發送文件等等的通訊功能。所以這次的side project所實作的app則主要focus在&lt;strong>通訊&lt;/strong>這個點上。&lt;/p></description></item><item><title>🇹🇼倒數</title><link>http://localhost:58072/memories/last-moment-in-taiwan/</link><pubDate>Wed, 05 Apr 2023 13:22:03 +0800</pubDate><guid>http://localhost:58072/memories/last-moment-in-taiwan/</guid><description>&lt;p>在2023年1月的時候，因為已經快3年沒有回家了，所以勢必要回去一趟。所以在1月10號的時候買了回去的票。其實這次回去只要還是想看看香港的環境如何。在這個月裡面跟高中同學吃飯也了解到了許多資訊,開始考慮是否可以回來找工作，畢竟台灣找工作還是有一點難度，工作環境好像也沒有很優。除此之外，去年也有在考慮到澳洲讀研究生，如果在台灣工作可能很難達到這個目標，所以決定回來找工作，回來就只是為了存錢，沒有別的。&lt;/p></description></item><item><title>[筆記] Linked List 資料結構</title><link>http://localhost:58072/post/note/note-linkedlist/</link><pubDate>Fri, 10 Mar 2023 14:42:22 +0800</pubDate><guid>http://localhost:58072/post/note/note-linkedlist/</guid><description>&lt;p>Linked List是一個很常用的資料結構，&lt;/p>
&lt;h2 id="設計linked-list">設計Linked List
&lt;a class="header-anchor" href="#%e8%a8%ad%e8%a8%88linked-list">&lt;/a>
&lt;/h2></description></item><item><title>[筆記] Binary Search 演算法</title><link>http://localhost:58072/post/note/note-binarysearch/</link><pubDate>Thu, 09 Mar 2023 13:48:46 +0800</pubDate><guid>http://localhost:58072/post/note/note-binarysearch/</guid><description>&lt;p>Binary Search 演算法是用於在一個有序array中搜尋一個值的演算法 - TC:O(log n)。相較於Linear Search(線性搜尋) - TC:O(n),其效率大大提高。&lt;/p></description></item><item><title>[筆記] KMP - Knuth-Morris-Pratt 演算法</title><link>http://localhost:58072/post/note/note-kmp/</link><pubDate>Mon, 06 Mar 2023 12:32:40 +0800</pubDate><guid>http://localhost:58072/post/note/note-kmp/</guid><description>&lt;p>KMP(Knuth-Morris-Pratt) 算法是一個用於字符串匹配的一個算法，但確實有點抽象和複雜，因此打算寫一篇筆記來紀錄一下這個算法！&lt;br>
給定一個&lt;code>text&lt;/code>以及&lt;code>pattern&lt;/code>字符串，透過KMP 算法可以在&lt;code>text&lt;/code>中是否存在&lt;code>pattern&lt;/code>這個字符串。&lt;/p></description></item><item><title>2022年度總結(2023 annual summary)</title><link>http://localhost:58072/memories/summary-of-2022/</link><pubDate>Sun, 01 Jan 2023 21:19:23 +0800</pubDate><guid>http://localhost:58072/memories/summary-of-2022/</guid><description>&lt;h1 id="年初">年初
&lt;a class="header-anchor" href="#%e5%b9%b4%e5%88%9d">&lt;/a>
&lt;/h1>&lt;p>今年是我踏入大學的第四年，也就是大學生活的最後一年的最後一個學期，這個學期也沒有什麼課程可以修，主要修的是《雲端系統》, 《編譯器原理》以及《網絡安全與管理》。因為當時看到課程安排的寬鬆，因此打算抽出部分時間去實習，因此開始了尋找實現之旅。可能經歷有點少，在找實習的過程中處處碰壁，申請了眾多公司都沒有回應，只有提交了作業跟申請的&lt;code>Dcard Backend Intern&lt;/code>給我發了感謝信，而且也拿到了一間&lt;code>Block chain&lt;/code>的公司的面試機會，但是因為是橋生的關係再加上申請的期限已截止，只能夠面試一次，因此實習之旅宣告失敗。因此只能收拾心情迎接畢業的到來。&lt;/p></description></item><item><title>2022年LeetCode年度總結(Summary)</title><link>http://localhost:58072/post/coding/lc-sumarry-of-2022/</link><pubDate>Sun, 01 Jan 2023 12:42:37 +0800</pubDate><guid>http://localhost:58072/post/coding/lc-sumarry-of-2022/</guid><description>&lt;h1 id="leetcode-總結">Leetcode 總結
&lt;a class="header-anchor" href="#leetcode-%e7%b8%bd%e7%b5%90">&lt;/a>
&lt;/h1>&lt;p>&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/lc-2022/lc-2022.png" alt="lc-2022" />&lt;/p>
&lt;p>雖然在2021年暑假的這段時間有刷過一整子大概有50道題左右，但是2021年9月到12月在忙畢業專題因此就停止了。直到我12月份去找投實習&lt;code>MataApp 的全棧實習生&lt;/code>時，公司給我發來了一份&lt;code>OA&lt;/code>或叫&lt;code>面試題&lt;/code>並要求在2小時內完成。當時就很激動的便開始寫了(實習問的都有多難),結果都的是算法題(當時一臉懵逼)。最後我花了將近5個小時的時間才完成(超時),收到了深深的打擊(收到了感謝信)，也下定了決心2022年好好認真刷題。&lt;/p></description></item><item><title>簡歷模板 Resume Template</title><link>http://localhost:58072/resources/resume-template/</link><pubDate>Sat, 24 Dec 2022 16:58:43 +0800</pubDate><guid>http://localhost:58072/resources/resume-template/</guid><description>&lt;h1 id="中英文簡歷模板">中英文簡歷模板
&lt;a class="header-anchor" href="#%e4%b8%ad%e8%8b%b1%e6%96%87%e7%b0%a1%e6%ad%b7%e6%a8%a1%e6%9d%bf">&lt;/a>
&lt;/h1>&lt;p>
&lt;a href="http://localhost:58072/files/Resume-template%28en%29.docx" title="English CV Template(docx)" >
 English CV Template(docx)
 
&lt;/a>
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/files/eng-cv.png" alt="English CV Template" />&lt;/p>
&lt;p>
&lt;a href="http://localhost:58072/files/Resume-template%28ch%29.docx" title="中文模板(docx)" >
 中文模板(docx)
 
&lt;/a>
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/files/ch-cv.png" alt="chinese CV Template" />&lt;/p>
&lt;h4 id="資料來源">資料來源
&lt;a class="header-anchor" href="#%e8%b3%87%e6%96%99%e4%be%86%e6%ba%90">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>
&lt;a href="https://dreambigcareer.com/" title="DBC" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 DBC
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>透過Kops工具在AWS中部署K8S集群</title><link>http://localhost:58072/post/coding/kuberneters-on-aws/</link><pubDate>Fri, 23 Dec 2022 14:39:46 +0800</pubDate><guid>http://localhost:58072/post/coding/kuberneters-on-aws/</guid><description>&lt;h2 id="這篇文章主要是講述如何在aws雲服務中部署kubernetes集群">這篇文章主要是講述如何在AWS雲服務中部署Kubernetes集群
&lt;a class="header-anchor" href="#%e9%80%99%e7%af%87%e6%96%87%e7%ab%a0%e4%b8%bb%e8%a6%81%e6%98%af%e8%ac%9b%e8%bf%b0%e5%a6%82%e4%bd%95%e5%9c%a8aws%e9%9b%b2%e6%9c%8d%e5%8b%99%e4%b8%ad%e9%83%a8%e7%bd%b2kubernetes%e9%9b%86%e7%be%a4">&lt;/a>
&lt;/h2>&lt;p>首先，我們需要準備使用一下工具進行設置&lt;/p>
&lt;ul>
&lt;li>KOps - 一個能讓我們輕鬆無痛部署Kubernetes到任何雲服務的工具，可以想象為集群的kubectl&lt;/li>
&lt;li>AWS IAM - 申請一個能讓Kops存取權限的賬號&lt;/li>
&lt;li>AWS S3 Bucket - 用來作為存取Kubernets資料的資料庫&lt;/li>
&lt;li>AWS Route53 - 用於使用自定義Domain Name 並連接到Master Node中&lt;/li>
&lt;li>GoDady - 作為DNS 服務供應商&lt;/li>
&lt;/ul>
&lt;h4 id="前置工作">前置工作
&lt;a class="header-anchor" href="#%e5%89%8d%e7%bd%ae%e5%b7%a5%e4%bd%9c">&lt;/a>
&lt;/h4>&lt;h5 id="在電腦中安裝kops工具用於幫助我們部署集群">在電腦中安裝&lt;code>KOps&lt;/code>工具用於幫助我們部署集群
&lt;a class="header-anchor" href="#%e5%9c%a8%e9%9b%bb%e8%85%a6%e4%b8%ad%e5%ae%89%e8%a3%9dkops%e5%b7%a5%e5%85%b7%e7%94%a8%e6%96%bc%e5%b9%ab%e5%8a%a9%e6%88%91%e5%80%91%e9%83%a8%e7%bd%b2%e9%9b%86%e7%be%a4">&lt;/a>
&lt;/h5>&lt;blockquote>
&lt;p>想要了解更多關於KOps的讀者，可以參閱
&lt;a href="https://kops.sigs.k8s.io/" title="kOps-Kubernetes Operations" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 kOps-Kubernetes Operations
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/p></description></item><item><title>[Side-Project] Movie App</title><link>http://localhost:58072/project/movie-app/</link><pubDate>Sat, 10 Dec 2022 15:45:56 +0800</pubDate><guid>http://localhost:58072/project/movie-app/</guid><description>&lt;p>
&lt;a href="https://github.com/RyanTokManMokMTM/MovieAppSwiftUI.git" title="Movie App - Frontend" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 &lt;strong>Movie App - Frontend&lt;/strong>
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;br>

&lt;a href="https://github.com/RyanTokManMokMTM/movie-server" title="Movie App - Backend" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 &lt;strong>Movie App - Backend&lt;/strong>
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/p>
&lt;p>&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/ott_app/movie-app/AppImg.png" alt="client" />&lt;/p>
&lt;h3 id="簡介">簡介
&lt;a class="header-anchor" href="#%e7%b0%a1%e4%bb%8b">&lt;/a>
&lt;/h3>&lt;p>開發這個App的目的主要是為了解決在搜尋電影OTT資源以及電影內容討論分散在多個不同平台等問題，如:搜尋到的資源是無效/不合法的，花費大量時間在搜尋上等等&amp;hellip;。因此這個App主要分成2個組成部分，分別是電影資訊搜尋獲取OTT資源，並整合不同OTT平台的電影資源，供用戶選擇合法資源，並過濾無效資源以及電影分享社群，供用戶在觀看完電影後，直接在App中發佈相關文章以分享給其他用戶，而無需在不同平台發佈。&lt;/p></description></item><item><title>[總結]Leetcode 週賽第319場復盤總結</title><link>http://localhost:58072/post/coding/leetcode-contest319/</link><pubDate>Sun, 13 Nov 2022 11:45:46 +0800</pubDate><guid>http://localhost:58072/post/coding/leetcode-contest319/</guid><description>&lt;h1 id="今日為2022年11月13日週日---leetcode-週賽第319場">今日為2022年11月13日(週日) - Leetcode 週賽第319場
&lt;a class="header-anchor" href="#%e4%bb%8a%e6%97%a5%e7%82%ba2022%e5%b9%b411%e6%9c%8813%e6%97%a5%e9%80%b1%e6%97%a5---leetcode-%e9%80%b1%e8%b3%bd%e7%ac%ac319%e5%a0%b4">&lt;/a>
&lt;/h1>&lt;blockquote>
&lt;p>目前參加週賽主要的目的是學習跟訓練，所有當前主要focus在解Easy 跟 Medium的題目，Hard的題目暫且先跳過了&lt;/p>
&lt;/blockquote>
&lt;h3 id="週賽題目如下">週賽題目如下:
&lt;a class="header-anchor" href="#%e9%80%b1%e8%b3%bd%e9%a1%8c%e7%9b%ae%e5%a6%82%e4%b8%8b">&lt;/a>
&lt;/h3>&lt;ol>
&lt;li>Convert the Temperature - &lt;strong>Easy&lt;/strong>&lt;/li>
&lt;li>Number of Subarrays With LCM Equal to K - &lt;strong>Medium&lt;/strong>&lt;/li>
&lt;li>Minimum Number of Operations to Sort a Binary Tree by Level - &lt;strong>Medium&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h3 id="convert-the-temperature---easy">Convert the Temperature - Easy
&lt;a class="header-anchor" href="#convert-the-temperature---easy">&lt;/a>
&lt;/h3>&lt;p>You are given a non-negative floating point number rounded to two decimal places &lt;code>celsius&lt;/code>, that denotes &lt;strong>the temperature in Celsius&lt;/strong>.&lt;/p></description></item><item><title>[Leetcode] Maximum Length of Repeated Subarray(Medium)</title><link>http://localhost:58072/leetcodes/leetcode718/</link><pubDate>Tue, 20 Sep 2022 14:47:44 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode718/</guid><description>&lt;h2 id="leetcode-718---maximum-length-of-repeated-subarray">LeetCode 718 - Maximum Length of Repeated Subarray
&lt;a class="header-anchor" href="#leetcode-718---maximum-length-of-repeated-subarray">&lt;/a>
&lt;/h2>&lt;p>Given two integer arrays ``nums1&lt;code>and&lt;/code>nums2`, return the maximum length of a subarray that appears in both arrays.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The repeated subarray with maximum length is [3,2,1].
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題要我們找出2個&lt;code>array&lt;/code>中最長的相同&lt;code>subarray&lt;/code>。這題有點類似於
&lt;a href="http://localhost:58072/notes/lcm" title="最長公共子序列" >
 最長公共子序列
 
&lt;/a>,但是不同的是&lt;code>子序列&lt;/code>不一樣的&lt;strong>連續的&lt;/strong>,而&lt;code>subarray&lt;/code>是必須要&lt;strong>連續的&lt;/strong>。哪我們只需要改寫一下&lt;code>最長公共子序列&lt;/code>,我們只需要更新&lt;strong>相等&lt;/strong>的元素即可。其餘的都不需要關心。&lt;/p></description></item><item><title>[Leetcode] Find Duplicate File in System(Medium)</title><link>http://localhost:58072/leetcodes/leetcode609/</link><pubDate>Mon, 19 Sep 2022 14:41:56 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode609/</guid><description>&lt;h2 id="leetcode-42---trapping-rain-water">LeetCode 42 - Trapping Rain Water
&lt;a class="header-anchor" href="#leetcode-42---trapping-rain-water">&lt;/a>
&lt;/h2>&lt;p>Given a list &lt;code>paths&lt;/code> of directory info, including the directory path, and all the files with contents in this directory, return &lt;em>all the duplicate files in the file system in terms of their paths&lt;/em>. You may return the answer in &lt;strong>any order&lt;/strong>.&lt;/p>
&lt;p>A group of duplicate files consists of at least two files that have the same content.&lt;/p>
&lt;p>A single directory info string in the input list has the following format:&lt;/p></description></item><item><title>Leetcode Weekly Contest 331(第一次參加競賽)</title><link>http://localhost:58072/post/coding/leetcodeweeklycontest331/</link><pubDate>Sun, 18 Sep 2022 16:32:34 +0800</pubDate><guid>http://localhost:58072/post/coding/leetcodeweeklycontest331/</guid><description>&lt;blockquote>
&lt;p>今天是我第一次參加&lt;strong>Leetcode 雙週賽&lt;/strong>，所以想記錄一下今天的競賽題目。希望能透過博客來記錄自己的競賽狀況。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>本週AC題數為:4/4&lt;/strong>&lt;/p>
&lt;h2 id="題目">題目
&lt;a class="header-anchor" href="#%e9%a1%8c%e7%9b%ae">&lt;/a>
&lt;/h2>&lt;h3 id="2413-smallest-even-multipleeasy---ac">2413. Smallest Even Multiple(EASY) - AC
&lt;a class="header-anchor" href="#2413-smallest-even-multipleeasy---ac">&lt;/a>
&lt;/h3>&lt;p>Given a positive integer &lt;code>n&lt;/code>, return the smallest positive integer that is a multiple of both &lt;code>2&lt;/code> and &lt;code>n&lt;/code>.&lt;/p></description></item><item><title>[Leetcode] Trapping Rain Water(Hard)</title><link>http://localhost:58072/leetcodes/leetcode42/</link><pubDate>Sun, 18 Sep 2022 14:29:08 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode42/</guid><description>&lt;h2 id="leetcode-42---trapping-rain-water">LeetCode 42 - Trapping Rain Water
&lt;a class="header-anchor" href="#leetcode-42---trapping-rain-water">&lt;/a>
&lt;/h2>&lt;p>Given &lt;code>n&lt;/code> non-negative integers representing an elevation map where the width of each bar is &lt;code>1&lt;/code>, compute how much water it can trap after raining.
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: height = [4,2,0,3,2,5]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 9
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題是給定一個&lt;code>array&lt;/code>代表著&lt;strong>高度&lt;/strong>，問我們一共可以裝多少水。這題的解題思路，假設當前是&lt;code>i&lt;/code>,那我當前這個&lt;code>i&lt;/code>是否可以裝水呢？我們是是不是要知道&lt;code>i&lt;/code>的左手邊的最高的柱子(&lt;code>x&lt;/code>)和最右手邊的最高的柱子(&lt;code>y&lt;/code>)，那跟柱子比較矮而且是不是大於現在這個&lt;code>i&lt;/code>。假設&lt;code>IFF x &amp;lt; y &amp;amp;&amp;amp; x &amp;gt; i&lt;/code>,哪&lt;code>i&lt;/code>可以裝的水就會是&lt;code>x - i&lt;/code>那麼多。所以說，我們必須要知道當前&lt;code>i&lt;/code>的左邊最高和&lt;code>i&lt;/code>的右邊最高是多少。哪要怎麼做呢？我們可以透過預處理的方式，預先計算左手邊(&lt;code>i之前&lt;/code>)最大值以及右手邊(&lt;code>i之後&lt;/code>)的最大值，然後在根據以上的方法即可解出答案。&lt;/p></description></item><item><title>[Leetcode] Palindrome Pairs(Hard)</title><link>http://localhost:58072/leetcodes/leetcode336/</link><pubDate>Sat, 17 Sep 2022 20:41:48 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode336/</guid><description>&lt;h2 id="leetcode-336---palindrome-pairs">LeetCode 336 - Palindrome Pairs
&lt;a class="header-anchor" href="#leetcode-336---palindrome-pairs">&lt;/a>
&lt;/h2>&lt;p>Given a list of &lt;strong>unique&lt;/strong> words, return all the pairs of the &lt;em>&lt;strong>distinct&lt;/strong>&lt;/em> indices &lt;code>(i, j)&lt;/code> in the given list, so that the concatenation of the two words &lt;code>words[i] + words[j]&lt;/code> is a palindrome.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: words = [&amp;#34;abcd&amp;#34;,&amp;#34;dcba&amp;#34;,&amp;#34;lls&amp;#34;,&amp;#34;s&amp;#34;,&amp;#34;sssll&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[0,1],[1,0],[3,2],[2,4]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The palindromes are [&amp;#34;dcbaabcd&amp;#34;,&amp;#34;abcddcba&amp;#34;,&amp;#34;slls&amp;#34;,&amp;#34;llssssll&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: words = [&amp;#34;bat&amp;#34;,&amp;#34;tab&amp;#34;,&amp;#34;cat&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[0,1],[1,0]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The palindromes are [&amp;#34;battab&amp;#34;,&amp;#34;tabbat&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>在解這題之前我們先要知道有哪些情況是成立Palindrome。&lt;/p></description></item><item><title>[Leetcode] Maximum Score from Performing Multiplication Operations(Medium)</title><link>http://localhost:58072/leetcodes/leetcode1770/</link><pubDate>Fri, 16 Sep 2022 20:42:00 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1770/</guid><description>&lt;h2 id="leetcode-1770---maximum-score-from-performing-multiplication-operations">LeetCode 1770 - Maximum Score from Performing Multiplication Operations
&lt;a class="header-anchor" href="#leetcode-1770---maximum-score-from-performing-multiplication-operations">&lt;/a>
&lt;/h2>&lt;p>You are given two integer arrays &lt;code>nums&lt;/code> and &lt;code>multipliers&lt;/code> of size &lt;code>n&lt;/code> and &lt;code>m&lt;/code> respectively, where &lt;code>n &amp;gt;= m&lt;/code>. The arrays are &lt;strong>1-indexed&lt;/strong>.&lt;/p>
&lt;p>You begin with a score of &lt;code>0&lt;/code>. You want to perform &lt;strong>exactly&lt;/strong> &lt;code>m&lt;/code> operations. On the &lt;code>ith&lt;/code> operation (&lt;strong>1-indexed&lt;/strong>), you will:&lt;/p>
&lt;ul>
&lt;li>Choose one integer &lt;code>x&lt;/code> from &lt;strong>either the start or the end&lt;/strong> of the array &lt;code>nums&lt;/code>.&lt;/li>
&lt;li>Add &lt;code>multipliers[i] * &lt;/code>x` to your score.&lt;/li>
&lt;li>Remove x from the array &lt;code>nums&lt;/code>.
Return the maximum score after performing m operations.
example&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,2,3], multipliers = [3,2,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 14
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: An optimal solution is as follows:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [1], adding 1 * 1 = 1 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The total score is 9 + 4 + 1 = 14.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 102
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: An optimal solution is as follows:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The total score is 50 + 15 - 9 + 4 + 42 = 102.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題最主要的重點是對於每個&lt;code>multipliers[i]&lt;/code>,它只能挑選最左邊或者最右邊的值。所有，我們需要知道&lt;code>multipliers[i]&lt;/code>拿最左邊的值最後的結果比較大，還是拿最右邊後的結果比較大。為了避免重複計算而超時，所以我們需要使用&lt;code>dp&lt;/code>來幫助我們記錄當前最優解。&lt;code>注:因multipliers最多為m個，所有最多只能從nums拿m個數字&lt;/code>&lt;/p></description></item><item><title>[Leetcode] Pancake Sorting(Medium)</title><link>http://localhost:58072/leetcodes/leetcode969/</link><pubDate>Thu, 15 Sep 2022 00:31:46 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode969/</guid><description>&lt;h2 id="leetcode-969---pancake-sorting">LeetCode 969 - Pancake Sorting
&lt;a class="header-anchor" href="#leetcode-969---pancake-sorting">&lt;/a>
&lt;/h2>&lt;p>Given an array of integers &lt;code>arr&lt;/code>, sort the array by performing a series of &lt;strong>pancake flips&lt;/strong>.&lt;/p>
&lt;p>In one pancake flip we do the following steps:&lt;/p>
&lt;ul>
&lt;li>Choose an integer &lt;code>k&lt;/code> where &lt;code>1 &amp;lt;= k &amp;lt;= arr.length&lt;/code>.&lt;/li>
&lt;li>Reverse the sub-array &lt;code>arr[0...k-1]&lt;/code> (&lt;strong>0-indexed&lt;/strong>).
For example, if arr = &lt;code>[3,2,1,4]&lt;/code> and we performed a pancake flip choosing &lt;code>k = 3&lt;/code>, we reverse the sub-array &lt;code>[3,2,1]&lt;/code>, so arr = &lt;code>[1,2,3,4]&lt;/code> after the pancake flip at k = 3.&lt;/li>
&lt;/ul>
&lt;p>Return an array of the &lt;code>k&lt;/code>-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within &lt;code>10 * arr.length&lt;/code> flips will be judged as correct.
example&lt;/p></description></item><item><title>[Leetcode] Find Original Array From Doubled Array(Medium)</title><link>http://localhost:58072/leetcodes/leetcode2007/</link><pubDate>Thu, 15 Sep 2022 00:21:27 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode2007/</guid><description>&lt;h2 id="leetcode-2007---find-original-array-from-doubled-array">LeetCode 2007 - Find Original Array From Doubled Array
&lt;a class="header-anchor" href="#leetcode-2007---find-original-array-from-doubled-array">&lt;/a>
&lt;/h2>&lt;p>An integer array &lt;code>original&lt;/code> is transformed into a &lt;strong>doubled&lt;/strong> array changed by appending &lt;strong>twice the value&lt;/strong> of every element in original, and then randomly &lt;strong>shuffling&lt;/strong> the resulting array.&lt;/p>
&lt;p>Given an array &lt;code>changed&lt;/code>, return &lt;code>original&lt;/code> if &lt;code>changed&lt;/code> is a &lt;strong>doubled&lt;/strong> array. If &lt;code>changed&lt;/code> is not a &lt;strong>doubled&lt;/strong> array, &lt;em>return an empty array. The elements in &lt;code>original&lt;/code> may be returned in any order&lt;/em>.
example&lt;/p></description></item><item><title>[Leetcode] Pseudo-Palindromic Paths in a Binary Tree(Medium)</title><link>http://localhost:58072/leetcodes/leetcode1457/</link><pubDate>Wed, 14 Sep 2022 15:27:08 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1457/</guid><description>&lt;h2 id="leetcode-1457---pseudo-palindromic-paths-in-a-binary-tree">LeetCode 1457 - Pseudo-Palindromic Paths in a Binary Tree
&lt;a class="header-anchor" href="#leetcode-1457---pseudo-palindromic-paths-in-a-binary-tree">&lt;/a>
&lt;/h2>&lt;p>Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be &lt;strong>pseudo-palindromic&lt;/strong> if at least one permutation of the node values in the path is a palindrome.&lt;/p>
&lt;p>&lt;em>Return the number of &lt;strong>pseudo-palindromic&lt;/strong> paths going from the root node to leaf nodes.&lt;/em>
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [2,3,1,3,1,null,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 2 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [2,1,1,1,3,null,null,null,null,null,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [9]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這一題簡單的來說就是讓我們從&lt;strong>Binary Tree&lt;/strong>中找到有幾條&lt;code>path&lt;/code>是一個&lt;em>Palindromic(Pseudo-Palindromic)偽迴文串&lt;/em>。
也就是說從&lt;code>root到leaft&lt;/code>的&lt;code>path&lt;/code>是一個&lt;strong>Palindromic&lt;/strong>。 (我們只需要知道path是否能組成&lt;em>Palindromic&lt;/em>即可)&lt;/p></description></item><item><title>[Leetcode] UTF-8 Validation(Medium)</title><link>http://localhost:58072/leetcodes/leetcode393/</link><pubDate>Tue, 13 Sep 2022 14:41:37 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode393/</guid><description>&lt;h2 id="leetcode-393---utf-8-validation">LeetCode 393 - UTF-8 Validation
&lt;a class="header-anchor" href="#leetcode-393---utf-8-validation">&lt;/a>
&lt;/h2>&lt;p>Given an integer array &lt;code>data&lt;/code> representing the data, return whether it is a valid &lt;strong>UTF-8&lt;/strong> encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).&lt;/p>
&lt;p>A character in &lt;strong>UTF8&lt;/strong> can be from &lt;strong>1 to 4 bytes&lt;/strong> long, subjected to the following rules:&lt;/p>
&lt;ol>
&lt;li>For a &lt;strong>1-byte&lt;/strong> character, the first bit is a &lt;code>0&lt;/code>, followed by its Unicode code.&lt;/li>
&lt;li>For an &lt;strong>n-bytes&lt;/strong> character, the first n bits are all one&amp;rsquo;s, the &lt;code>n + 1&lt;/code> bit is &lt;code>0&lt;/code>, followed by &lt;code>n - 1&lt;/code> bytes with the most significant &lt;code>2&lt;/code> bits being &lt;code>10&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>This is how the UTF-8 encoding would work:&lt;/p></description></item><item><title>[Leetcode] Bag of Tokens(Medium)</title><link>http://localhost:58072/leetcodes/leetcode948/</link><pubDate>Mon, 12 Sep 2022 18:01:44 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode948/</guid><description>&lt;h2 id="leetcode-948---bag-of-tokens">LeetCode 948 - Bag of Tokens
&lt;a class="header-anchor" href="#leetcode-948---bag-of-tokens">&lt;/a>
&lt;/h2>&lt;p>You have an initial &lt;strong>power&lt;/strong> of &lt;code>power&lt;/code>, an initial &lt;strong>score&lt;/strong> of &lt;code>0&lt;/code>, and a bag of &lt;code>tokens&lt;/code> where &lt;code>tokens[i]&lt;/code> is the value of the i&lt;sup>th&lt;/sup> token (0-indexed).&lt;/p>
&lt;p>Your goal is to maximize your total &lt;strong>score&lt;/strong> by potentially playing each token in one of two ways:&lt;/p>
&lt;ul>
&lt;li>If your current &lt;strong>power&lt;/strong> is at least &lt;code>tokens[i]&lt;/code>, you may play the i&lt;sup>th&lt;/sup> token face up, losing &lt;code>tokens[i]&lt;/code>&lt;strong>power&lt;/strong> and gaining &lt;code>1&lt;/code>a score.&lt;/li>
&lt;li>If your current &lt;strong>score&lt;/strong> is at least &lt;code>1&lt;/code>, you may play the i&lt;sup>th&lt;/sup> token face down, gaining &lt;code>tokens[i]&lt;/code> &lt;strong>power&lt;/strong> and losing &lt;code>1&lt;/code> &lt;strong>score&lt;/strong>.
Each token may be played &lt;strong>at most&lt;/strong> once and &lt;strong>in any order&lt;/strong>. You do &lt;strong>not&lt;/strong> have to play all the tokens.&lt;/li>
&lt;/ul>
&lt;p>Return &lt;em>the largest possible &lt;strong>score&lt;/strong> you can achieve after playing any number of tokens&lt;/em>.&lt;/p></description></item><item><title>[Leetcode] The Number of Weak Characters in the Game(Medium)</title><link>http://localhost:58072/leetcodes/leetcode1996/</link><pubDate>Fri, 09 Sep 2022 23:36:50 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1996/</guid><description>&lt;h2 id="leetcode-1996---the-number-of-weak-characters-in-the-game">LeetCode 1996 - The Number of Weak Characters in the Game
&lt;a class="header-anchor" href="#leetcode-1996---the-number-of-weak-characters-in-the-game">&lt;/a>
&lt;/h2>&lt;p>You are playing a game that contains multiple characters, and each of the characters has &lt;strong>two&lt;/strong> main properties: &lt;strong>attack&lt;/strong> and &lt;strong>defense&lt;/strong>. You are given a 2D integer array &lt;code>properties&lt;/code> where &lt;code>properties[i] = [attacki, defensei]&lt;/code> represents the properties of the i&lt;sup>th&lt;/sup> character in the game.&lt;/p>
&lt;p>A character is said to be &lt;strong>weak&lt;/strong> if any other character has &lt;strong>both&lt;/strong> attack and defense levels &lt;strong>strictly greater&lt;/strong> than this character&amp;rsquo;s attack and defense levels. More formally, a character &lt;code>i&lt;/code> is said to be &lt;strong>weak&lt;/strong> if there exists another character &lt;code>j&lt;/code> where attack&lt;sub>j&lt;/sub> attack&lt;sub>i&lt;/sub> and defense&lt;sub>j&lt;/sub> &amp;gt; defense&lt;sub>i&lt;/sub>.&lt;/p></description></item><item><title>[Leetcode] Binary Tree Inorder Traversal(Easy)</title><link>http://localhost:58072/leetcodes/leetcode94/</link><pubDate>Thu, 08 Sep 2022 20:22:06 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode94/</guid><description>&lt;h2 id="leetcode-94---binary-tree-inorder-traversal">LeetCode 94 - Binary Tree Inorder Traversal
&lt;a class="header-anchor" href="#leetcode-94---binary-tree-inorder-traversal">&lt;/a>
&lt;/h2>&lt;p>Given the &lt;code>root&lt;/code> of a binary tree, return &lt;em>the inorder traversal of its nodes&amp;rsquo; values.&lt;/em>&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [1,null,2,3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1,3,2]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題很簡單,只要使用中序遍歷即可。&lt;/p>
&lt;h4 id="solution">Solution:
&lt;a class="header-anchor" href="#solution">&lt;/a>
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Definition for a binary tree node.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * struct TreeNode {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * int val;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * TreeNode *left;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * TreeNode *right;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * TreeNode() : val(0), left(nullptr), right(nullptr) {}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * };
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> inorderTraversal(TreeNode&lt;span style="color:#f92672">*&lt;/span> root) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inorder(root,res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">inorder&lt;/span>(TreeNode&lt;span style="color:#f92672">*&lt;/span> root,vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> res){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>root) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inorder(root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>left,res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.emplace_back(root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inorder(root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>right,res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[筆記]Traversal Graph(圖)</title><link>http://localhost:58072/post/coding/bt-traversal/</link><pubDate>Thu, 08 Sep 2022 10:34:50 +0800</pubDate><guid>http://localhost:58072/post/coding/bt-traversal/</guid><description>&lt;blockquote>
&lt;p>總所周知Binary Tree也是圖的一種(單向無環圖)。所以,今天這裡以Binary Tree 為例。&lt;/p>
&lt;/blockquote>
&lt;h1 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h1>&lt;p>如果今天我們需要以&lt;strong>特定&lt;/strong>的方式遍歷一棵*Binary Tree(圖的一種)*我們怎麼做呢? 我們可以透過DSF(深度優先搜尋)以及BFS(廣度優先搜尋)來幫助我們遍歷&lt;strong>Binary Tree&lt;/strong>&lt;/p></description></item><item><title>[Leetcode] Construct String from Binary Tree(Easy)</title><link>http://localhost:58072/leetcodes/leetcode606/</link><pubDate>Wed, 07 Sep 2022 10:12:28 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode606/</guid><description>&lt;h2 id="leetcode-606---construct-string-from-binary-tree">LeetCode 606 - Construct String from Binary Tree
&lt;a class="header-anchor" href="#leetcode-606---construct-string-from-binary-tree">&lt;/a>
&lt;/h2>&lt;p>Given the &lt;code>root&lt;/code> of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.&lt;/p>
&lt;p>Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [1,2,3,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: &amp;#34;1(2(4))(3)&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Originally, it needs to be &amp;#34;1(2(4)())(3()())&amp;#34;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &amp;#34;1(2(4))(3)&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [1,2,3,null,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: &amp;#34;1(2()(4))(3)&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題就是要讓我們講以&lt;code>string&lt;/code>的方式輸出&lt;strong>Binary Tree&lt;/strong>。只要注意他的規則就可以解決這題。&lt;/p></description></item><item><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><link>http://localhost:58072/leetcodes/leetcode442/</link><pubDate>Tue, 06 Sep 2022 22:02:11 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode442/</guid><description>&lt;h2 id="leetcode-442---find-all-duplicates-in-an-array">LeetCode 442 - Find All Duplicates in an Array
&lt;a class="header-anchor" href="#leetcode-442---find-all-duplicates-in-an-array">&lt;/a>
&lt;/h2>&lt;p>Given an integer array &lt;code>nums&lt;/code> of length &lt;code>n&lt;/code> where all the integers of &lt;code>nums&lt;/code> are in the range &lt;code>[1, n]&lt;/code> and each integer appears &lt;strong>once&lt;/strong> or &lt;strong>twice&lt;/strong>, return an array of all the integers that appears &lt;strong>twice&lt;/strong>.&lt;/p>
&lt;p>You must write an algorithm that runs in &lt;code>O(n)&lt;/code> time and uses only constant extra space.
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [4,3,2,7,8,2,3,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [2,3]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題要我們找出所有在Array裡重複出現2次的數字。解法也很簡單, 因為題目也說了數字會出現1次或者2次,哪我們可以透過&lt;code>Map&lt;/code>來計數,但當前數字已經出現過1次,也就代表當前數字是重複了2次,加入到結果即可。&lt;/p></description></item><item><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><link>http://localhost:58072/leetcodes/leetcode2196/</link><pubDate>Tue, 06 Sep 2022 21:45:02 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode2196/</guid><description>&lt;h2 id="leetcode-2196---create-binary-tree-from-descriptions">LeetCode 2196 - Create Binary Tree From Descriptions
&lt;a class="header-anchor" href="#leetcode-2196---create-binary-tree-from-descriptions">&lt;/a>
&lt;/h2>&lt;p>You are given a 2D integer array &lt;code>descriptions&lt;/code> where &lt;code>descriptions[i] = [parenti, childi, isLefti]&lt;/code> indicates that parenti is the &lt;strong>parent&lt;/strong> of childi in a &lt;strong>binary&lt;/strong> tree of &lt;strong>unique&lt;/strong> values. Furthermore,&lt;/p>
&lt;ul>
&lt;li>If &lt;code>isLefti == 1&lt;/code>, then &lt;strong>child&lt;sub>i&lt;/sub>&lt;/strong> is the left child of &lt;strong>parent&lt;sub>i&lt;/sub>&lt;/strong>.&lt;/li>
&lt;li>If &lt;code>isLefti == 0&lt;/code>, then &lt;strong>child&lt;sub>i&lt;/sub>&lt;/strong> is the right child of &lt;strong>parent&lt;sub>i&lt;/sub>&lt;/strong>.
Construct the binary tree described by &lt;code>descriptions&lt;/code> and return &lt;em>its &lt;strong>root&lt;/strong>&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>The test cases will be generated such that the binary tree is &lt;strong>valid&lt;/strong>.
example&lt;/p></description></item><item><title>[Leetcode] Binary Tree Pruning(Medium)</title><link>http://localhost:58072/leetcodes/leetcode814/</link><pubDate>Tue, 06 Sep 2022 21:30:56 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode814/</guid><description>&lt;h2 id="leetcode-814---binary-tree-pruning">LeetCode 814 - Binary Tree Pruning
&lt;a class="header-anchor" href="#leetcode-814---binary-tree-pruning">&lt;/a>
&lt;/h2>&lt;p>Given the &lt;code>root&lt;/code> of a binary tree, return the same tree where every subtree (of the given tree) not containing a &lt;code>1&lt;/code> has been removed.&lt;/p>
&lt;p>A subtree of a node &lt;code>node&lt;/code> is node plus every node that is a descendant of &lt;code>node&lt;/code>.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [1,null,0,0,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1,null,0,null,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Only the red nodes satisfy the property &amp;#34;every subtree not containing a 1&amp;#34;.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The diagram on the right represents the answer.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [1,0,1,0,0,0,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1,null,1,null,1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題是要讓我們移除所有不包含&lt;code>1&lt;/code>的&lt;code>sub-tree&lt;/code>。所以，我們只要透過&lt;code>DFS&lt;/code>判斷一下&lt;code>node&lt;/code>的&lt;code>left-sub tree&lt;/code> 以及 &lt;code>right-sub tree&lt;/code> 是否都不包含&lt;code>1&lt;/code>:
1. 如果左右子樹都不包含&lt;code>1&lt;/code>且當前&lt;code>node&lt;/code>為0, 直接返回&lt;code>nullptr&lt;/code>
2. 若當前節點為&lt;code>1&lt;/code>就返回自身
2. 左子樹不包含&lt;code>1&lt;/code>, 當前&lt;code>node&lt;/code>的左子樹設成&lt;code>nullptr&lt;/code>;同理右子樹不包含&lt;code>1&lt;/code>,當前&lt;code>node&lt;/code> 的右子數設為&lt;code>nullptr&lt;/code>&lt;/p></description></item><item><title>[開發日記]OTT電影社群APP(一)</title><link>http://localhost:58072/post/project/dev-ottapp-1/</link><pubDate>Tue, 06 Sep 2022 12:36:22 +0800</pubDate><guid>http://localhost:58072/post/project/dev-ottapp-1/</guid><description>&lt;blockquote>
&lt;p>最近這2個月都沒有更新發文章，主要是因為這2個月都在專注重構畢業專題的項目，也是只OTT電影平台。&lt;br>
今天這篇文章主要是跟大家分享這2個月所開發的進度和目前開發到的階段，以此作為這個項目的開發日記。&lt;/p></description></item><item><title>[Leetcode] Reverse Linked List II(Medium)</title><link>http://localhost:58072/leetcodes/leetcode92/</link><pubDate>Thu, 21 Jul 2022 11:09:21 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode92/</guid><description>&lt;h2 id="leetcode-92----reverse-linked-list-ii">LeetCode 92 - Reverse Linked List II
&lt;a class="header-anchor" href="#leetcode-92----reverse-linked-list-ii">&lt;/a>
&lt;/h2>&lt;p>Given the &lt;code>head&lt;/code> of a singly linked list and two integers &lt;code>left&lt;/code> and &lt;code>right&lt;/code> where &lt;code>left &amp;lt;= right&lt;/code>, reverse the nodes of the list from position &lt;code>left&lt;/code> to position &lt;code>right&lt;/code>, and return the &lt;em>reversed list&lt;/em>.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: head = [1,2,3,4,5], left = 2, right = 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1,4,3,2,5]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: head = [5], left = 1, right = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [5]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這一題的問題非常的簡單,就是要讓我們在給定的一個&lt;code>list&lt;/code>中翻轉(Reverse)&lt;code>[left,right]&lt;/code>之間的Node,並返回結果。這題跟&lt;strong>Reverse Linked List I&lt;/strong>解法類似,不同的是多了個翻轉範圍。&lt;br>
首先，我們要做的是在的翻轉的開始的位置。然後再透過recursive來翻轉List,最後返回的&lt;code>node/head&lt;/code>再由&lt;code>left&lt;/code>位置的Node的前一個&lt;code>Node&lt;/code>接起來(如有)就可以了~&lt;/p></description></item><item><title>[Leetcode DP] K Inverse Pairs Array(Hard)</title><link>http://localhost:58072/leetcodes/leetcode629/</link><pubDate>Sun, 17 Jul 2022 11:55:10 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode629/</guid><description>&lt;p>&lt;em>這題主要是學習DP思想，做個小記錄&lt;/em>&lt;/p>
&lt;h2 id="leetcode-629---k-inverse-pairs-array">LeetCode 629 - K Inverse Pairs Array
&lt;a class="header-anchor" href="#leetcode-629---k-inverse-pairs-array">&lt;/a>
&lt;/h2>&lt;p>For an integer array nums, an &lt;strong>inverse pair&lt;/strong> is a pair of integers &lt;code>[i, j]&lt;/code> where &lt;code>0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length&lt;/code> and &lt;code>nums[i] &amp;gt; nums[j]&lt;/code>.&lt;/p>
&lt;p>Given two integers&lt;code>n&lt;/code> and &lt;code>k&lt;/code>, return the number of different arrays consist of numbers from 1 to n such that there are exactly &lt;code>k&lt;/code> &lt;strong>inverse pairs&lt;/strong>. Since the answer can be huge, return it &lt;strong>modulo&lt;/strong> &lt;code>109 + 7&lt;/code>.&lt;/p></description></item><item><title>[Leetcode DP] Counting Bits(Easy)</title><link>http://localhost:58072/leetcodes/leetcodes338/</link><pubDate>Thu, 23 Jun 2022 11:33:51 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcodes338/</guid><description>&lt;h2 id="leetcode-338---counting-bits">LeetCode 338 - Counting Bits
&lt;a class="header-anchor" href="#leetcode-338---counting-bits">&lt;/a>
&lt;/h2>&lt;p>Given an integer &lt;code>n&lt;/code>, return an &lt;em>array &lt;code>ans&lt;/code> of length &lt;code>n + 1&lt;/code> such that for each &lt;code>i&lt;/code> (&lt;code>0 &amp;lt;= i &amp;lt;= n&lt;/code>), &lt;code>ans[i]&lt;/code> is the &lt;strong>number&lt;/strong> of &lt;code>1&lt;/code>&amp;rsquo;s in the binary representation of &lt;code>i&lt;/code>.&lt;/em>&lt;/p>
&lt;p>example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: n = 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [0,1,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0 --&amp;gt; 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 --&amp;gt; 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 --&amp;gt; 10
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: n = 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [0,1,1,2,1,2]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0 --&amp;gt; 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 --&amp;gt; 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 --&amp;gt; 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3 --&amp;gt; 11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4 --&amp;gt; 100
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5 --&amp;gt; 101
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題要我們解決的問題是給定一個數字&lt;code>n&lt;/code>,回傳&lt;code>0 - n&lt;/code>中每個數字包含了多少個為1的&lt;code>bits&lt;/code>。例如: &lt;code>n=2 =&amp;gt; 00,01,10&lt;/code>,回傳的結果便會是&lt;code>[0,1,1]&lt;/code>。&lt;/p></description></item><item><title>[Leetcode] Kth Largest Element in an Array(Medium)</title><link>http://localhost:58072/leetcodes/leetcodes215/</link><pubDate>Wed, 22 Jun 2022 22:55:53 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcodes215/</guid><description>&lt;h2 id="leetcode-1268---search-suggestions-system">LeetCode 1268 - Search Suggestions System
&lt;a class="header-anchor" href="#leetcode-1268---search-suggestions-system">&lt;/a>
&lt;/h2>&lt;p>Given an integer array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return the &lt;code>kth&lt;/code> &lt;em>largest element in the array&lt;/em>.&lt;/p>
&lt;p>Note that it is the &lt;code>kth&lt;/code> largest element in the sorted order, not the &lt;code>kth&lt;/code> distinct element.&lt;/p>
&lt;p>example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,2,1,5,6,4], k = 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題要我們解決的問題是回傳在&lt;code>sorted array&lt;/code>(&lt;em>Input Array沒有排序&lt;/em>)中第&lt;code>kth&lt;/code>大的元素。最簡單的解法是直接排序,然後回傳&lt;code>kth&lt;/code>元素即可。但是, 這裡我們也可以使用&lt;code>Priority Queue(Heap)&lt;/code>來幫我們解決這個問題。因為&lt;code>Priority Queue&lt;/code>的特性,越大的值(&lt;code>MaxHeap&lt;/code>)/越小的值(&lt;code>MinHeap&lt;/code>)會越接近&lt;code>root&lt;/code>,也就是說最大值(&lt;code>MaxHeap&lt;/code>)/最小值(&lt;code>MinHeap&lt;/code>)會在&lt;code>root&lt;/code>。所以我們可以運用&lt;code>MinHeap&lt;/code>來幫助的我們解決這個問題,只要&lt;code>Priority Queue&lt;/code>裡面的元素多於&lt;code>K&lt;/code>個我們就會把&lt;code>top&lt;/code>的值移除，因更小的值會在前面,每次&lt;code>pop&lt;/code>的值都會是當前最小的值,直到最後，省下來的值的&lt;code>root&lt;/code>/&lt;code>top&lt;/code>就會是我們的第&lt;code>K&lt;/code>個最大的值，而&lt;code>priority queue&lt;/code>中最後一個值便會是&lt;code>Input&lt;/code>中最大的值。&lt;/p></description></item><item><title>[Leetcode] Furthest Building You Can Reach(Medium)</title><link>http://localhost:58072/leetcodes/leetcodes1642/</link><pubDate>Tue, 21 Jun 2022 22:55:43 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcodes1642/</guid><description>&lt;h2 id="leetcode-1642---furthest-building-you-can-reach">LeetCode 1642 - Furthest Building You Can Reach
&lt;a class="header-anchor" href="#leetcode-1642---furthest-building-you-can-reach">&lt;/a>
&lt;/h2>&lt;p>You are given an integer array &lt;code>heights&lt;/code> representing the heights of buildings, some &lt;code>bricks&lt;/code>, and some &lt;code>ladders&lt;/code>.&lt;/p>
&lt;p>You start your journey from building &lt;code>0&lt;/code> and move to the next building by possibly using bricks or ladders.&lt;/p>
&lt;p>While moving from building &lt;code>i&lt;/code> to building &lt;code>i+1&lt;/code> (&lt;strong>0-indexed&lt;/strong>),&lt;/p>
&lt;ul>
&lt;li>If the current building&amp;rsquo;s height is &lt;strong>greater than or equal&lt;/strong> to the next building&amp;rsquo;s height, you do not need a ladder or bricks.&lt;/li>
&lt;li>If the current building&amp;rsquo;s height is &lt;strong>less than&lt;/strong> the next building&amp;rsquo;s height, you can either use one ladder or &lt;code>(h[i+1] - h[i])&lt;/code> bricks.
&lt;em>Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>example:&lt;/p></description></item><item><title>[筆記]TrieTree(前綴樹/字典樹)</title><link>http://localhost:58072/post/note/trietree/</link><pubDate>Tue, 21 Jun 2022 11:19:28 +0800</pubDate><guid>http://localhost:58072/post/note/trietree/</guid><description>&lt;h1 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h1>&lt;h2 id="什麼是trietree">什麼是TrieTree?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%aftrietree">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>Trie稱為前綴樹或字典樹,是有序樹的一種,Node的key通常為String類型。Trie Tree與Binary-Searching Tree不同的點是,Trie Tree的Key並不會直接保存在Node中,而是它在Tree中的位置所決定的。一個Node中的所有的childrens都有相同的Prefix(前綴)。假設有個Node的key 為&lt;code>T&lt;/code>,它的children將會是&lt;code>Time&lt;/code>, &lt;code>Tim&lt;/code>, &lt;code>Test&lt;/code>等,因為他們都會相同的Prefix(前綴)&lt;code>T&lt;/code>。&lt;/p></description></item><item><title>[Leetcode] Short Encoding of Words(Medium)</title><link>http://localhost:58072/leetcodes/leetcode802/</link><pubDate>Mon, 20 Jun 2022 12:45:05 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode802/</guid><description>&lt;h2 id="820---short-encoding-of-words">820 - Short Encoding of Words
&lt;a class="header-anchor" href="#820---short-encoding-of-words">&lt;/a>
&lt;/h2>&lt;p>A &lt;strong>valid encoding&lt;/strong> of an array of &lt;code>words&lt;/code> is any reference string s and array of indices indices such that:&lt;/p>
&lt;ul>
&lt;li>&lt;code>words.length&lt;/code> == &lt;code>indices.length&lt;/code>&lt;/li>
&lt;li>The reference string &lt;code>s&lt;/code> ends with the &lt;code>'#'&lt;/code> character.&lt;/li>
&lt;li>For each index indices[i], the &lt;strong>substring&lt;/strong> of s starting from &lt;code>indices[i]&lt;/code> and up to (but not including) the next &lt;code>'#'&lt;/code> character is equal to &lt;code>words[i]&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Given an array of &lt;code>words&lt;/code>, return the length of the shortest reference string &lt;code>s&lt;/code> possible of any valid encoding of &lt;code>words&lt;/code>.&lt;/p></description></item><item><title>[Leetcode] Search Suggestions System[Medium]</title><link>http://localhost:58072/leetcodes/leetcode1268/</link><pubDate>Sun, 19 Jun 2022 12:45:24 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1268/</guid><description>&lt;h2 id="leetcode-1268---search-suggestions-system">LeetCode 1268 - Search Suggestions System
&lt;a class="header-anchor" href="#leetcode-1268---search-suggestions-system">&lt;/a>
&lt;/h2>&lt;p>You are given an array of strings &lt;code>products&lt;/code> and a string &lt;code>searchWord&lt;/code>.&lt;/p>
&lt;p>Design a system that suggests at most three product names from &lt;code>products&lt;/code> after each character of &lt;code>searchWord&lt;/code> is typed. Suggested products should have common prefix with &lt;code>searchWord&lt;/code>. If there are more than three products with a common prefix return the three lexicographically minimums products.&lt;/p>
&lt;p>Return a &lt;em>list of lists of the suggested products&lt;/em> after each character of &lt;code>searchWord&lt;/code> is typed.
example:&lt;/p></description></item><item><title>[雕刻日常]數位雕刻基礎-人頭骨雕刻目前最好的一次!</title><link>http://localhost:58072/post/share/sculpturetrain1/</link><pubDate>Fri, 17 Jun 2022 23:28:22 +0800</pubDate><guid>http://localhost:58072/post/share/sculpturetrain1/</guid><description>&lt;h2 id="直接上圖">直接上圖!
&lt;a class="header-anchor" href="#%e7%9b%b4%e6%8e%a5%e4%b8%8a%e5%9c%96">&lt;/a>
&lt;/h2>&lt;p>&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/design/head-train.jpg" alt="head" />&lt;/p></description></item><item><title>[Leetcode] Longest Palindromic Substring(Medium)</title><link>http://localhost:58072/leetcodes/leetcode5/</link><pubDate>Thu, 16 Jun 2022 14:09:50 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode5/</guid><description>&lt;h2 id="leetcode-5---longest-palindromic-substring">LeetCode 5 - Longest Palindromic Substring
&lt;a class="header-anchor" href="#leetcode-5---longest-palindromic-substring">&lt;/a>
&lt;/h2>&lt;p>Given a string s, return the longest palindromic substring in s.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: s = &amp;#34;babad&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: &amp;#34;bab&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: &amp;#34;aba&amp;#34; is also a valid answer.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: s = &amp;#34;cbbd&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: &amp;#34;bb&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>要解決這題，我們必須要先知道什麼是Palindrome。可以參考這篇文章
&lt;a href="http://localhost:58072/leetcodenotes/palindromicstring" title="Palindromic string迴文" >
 Palindromic string迴文
 
&lt;/a>。而這題要我們找出在給定string中,找到最長的Palindrome。我們可以透過以每個單一字元(&lt;code>index i&lt;/code>)以及倆個字元(&lt;code>index i&lt;/code>,&lt;code>index i+1&lt;/code>)為中心點，並擴展&lt;code>left,right&lt;/code>找出他們的局部的最長Palindrome為多少，然後根據這個長度計算&lt;code>starting point i&lt;/code>以及記錄長度&lt;code>len&lt;/code>,最後以&lt;code>starting point&lt;/code>和&lt;code>len&lt;/code>得出字串中&lt;code>str[startingPoint,len]&lt;/code>為解。&lt;/p></description></item><item><title>[筆記]Palindromic String(迴文字串)</title><link>http://localhost:58072/post/note/palindromicstring/</link><pubDate>Thu, 16 Jun 2022 12:26:03 +0800</pubDate><guid>http://localhost:58072/post/note/palindromicstring/</guid><description>&lt;h1 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h1>&lt;h2 id="什麼是palindromic-string-迴文字串">什麼是Palindromic String 迴文字串
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afpalindromic-string-%e8%bf%b4%e6%96%87%e5%ad%97%e4%b8%b2">&lt;/a>
&lt;/h2>&lt;p>所謂的Palindromic String(迴文字串) 就是以一個字元為中間，而它的左邊以及右邊的組成字元相同。&lt;br>
例子:&lt;br>
&lt;code>abcdcba&lt;/code> 以&lt;code>d&lt;/code>為中心的左跟右的字元一樣。&lt;br>
&lt;code>cdc&lt;/code>左跟右都為&lt;code>c&lt;/code>&lt;br>
&lt;code>bcdcb&lt;/code> 左跟右都為&lt;code>b&lt;/code>&lt;br>
&lt;code>abcdcba&lt;/code> 左跟右都為&lt;code>a&lt;/code>&lt;/p></description></item><item><title>[Leetcode] Delete Operation for Two Strings(Medium)</title><link>http://localhost:58072/leetcodes/leetcode583/</link><pubDate>Tue, 14 Jun 2022 13:37:49 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode583/</guid><description>&lt;h2 id="leetcode-583---delete-operation-for-two-strings">LeetCode 583 - Delete Operation for Two Strings
&lt;a class="header-anchor" href="#leetcode-583---delete-operation-for-two-strings">&lt;/a>
&lt;/h2>&lt;p>Given two strings &lt;code>word1&lt;/code> and &lt;code>word2&lt;/code>, return the minimum number of steps required to make &lt;code>word1&lt;/code> and &lt;code>word2&lt;/code> the same.&lt;/p>
&lt;p>In one &lt;code>step&lt;/code>, you can delete exactly one character in either string
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: word1 = &amp;#34;sea&amp;#34;, word2 = &amp;#34;eat&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: You need one step to make &amp;#34;sea&amp;#34; to &amp;#34;ea&amp;#34; and another step to make &amp;#34;eat&amp;#34; to &amp;#34;ea&amp;#34;.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: word1 = &amp;#34;leetcode&amp;#34;, word2 = &amp;#34;etco&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題要我們解決的問題是給定2個字串&lt;code>Word1&lt;/code>和&lt;code>Word2&lt;/code>,每次從&lt;code>Word1&lt;/code>或者&lt;code>Word2&lt;/code>中移除1個Character，問我們最少需要多少步使得2個string一樣。&lt;br>
首先,我們需要先知道這2個&lt;code>Word&lt;/code>有哪些Character的是一致的。為了能獲得他們之間的最長共同子字串，我們可以透過&lt;code>Longest Commond Substring&lt;/code>來得到他們之間共同子字串的長度，只要每個字串的長度減去LCM的長度，就可以知道各自需要多少步。最後相加起來即可。&lt;br>

&lt;a href="http://localhost:58072/leetcodenotes/lcm" title="Longest Commond Substring Template" >
 Longest Commond Substring Template
 
&lt;/a>&lt;/p></description></item><item><title>[筆記]Longest Common SubString(最長公共子序列)</title><link>http://localhost:58072/post/coding/lcm/</link><pubDate>Tue, 14 Jun 2022 13:11:28 +0800</pubDate><guid>http://localhost:58072/post/coding/lcm/</guid><description>&lt;h1 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h1>&lt;h2 id="什麼是最長公共子序列">什麼是最長公共子序列?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%af%e6%9c%80%e9%95%b7%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97">&lt;/a>
&lt;/h2>&lt;p>給定2個字串&lt;code>string A&lt;/code>和&lt;code>string B&lt;/code>,2個字串中所共同擁有的最長的子字串。&lt;br>
例如:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>String A : leetcode
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String B : ecbod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">他們的最長公共子序列便是&lt;/span>&lt;span style="color:#f92672">`&lt;/span>ecod&lt;span style="color:#f92672">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">解釋&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String A &lt;span style="color:#960050;background-color:#1e0010">包含了&lt;/span> __e_cod_ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> ecod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String B &lt;span style="color:#960050;background-color:#1e0010">包含了&lt;/span> ec_od &lt;span style="color:#f92672">=&amp;gt;&lt;/span> ecod
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="要怎麼找到最長公共子序列lcm呢">要怎麼找到最長公共子序列LCM呢?
&lt;a class="header-anchor" href="#%e8%a6%81%e6%80%8e%e9%ba%bc%e6%89%be%e5%88%b0%e6%9c%80%e9%95%b7%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97lcm%e5%91%a2">&lt;/a>
&lt;/h2>&lt;p>我們需要定義一個數組用於保存當前情況下的最優解,也就是使用&lt;code>DP&lt;/code>的方式。我們需要以每個字符最為考量,並一一匹配，最後得出整體最優解。
&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/leetcodesHelper/lcm.png" alt="LCM" />&lt;/p></description></item><item><title>MetaHuman虛擬數字人初探</title><link>http://localhost:58072/post/share/mataverse-matahuman/</link><pubDate>Sun, 12 Jun 2022 15:01:27 +0800</pubDate><guid>http://localhost:58072/post/share/mataverse-matahuman/</guid><description>&lt;p>因為元宇宙(Metaverse)這個概念火熱,所有我就趁著這個機會了解一下在元宇宙領域中本人覺得比較有趣的東西。也就是這篇文章所要分享給各位的&lt;strong>MetaHuman(虛擬數字人/虛擬數位人)&lt;/strong>&lt;/p></description></item><item><title>[Leetcode] Combination Sum III(Medium)</title><link>http://localhost:58072/leetcodes/leetcode216/</link><pubDate>Tue, 10 May 2022 11:41:43 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode216/</guid><description>&lt;h2 id="leetcode-216---combination-sum-iii">LeetCode 216 - Combination Sum III
&lt;a class="header-anchor" href="#leetcode-216---combination-sum-iii">&lt;/a>
&lt;/h2>&lt;p>Find all valid combinations of &lt;code>k&lt;/code> numbers that sum up to &lt;code>n&lt;/code> such that the following conditions are true:&lt;/p>
&lt;ul>
&lt;li>Only numbers 1 through 9 are used.&lt;/li>
&lt;li>Each number is used &lt;strong>at most once&lt;/strong>.
Return a &lt;em>list of all possible valid combinations&lt;/em>. The list must not contain the same combination twice, and the combinations may be returned in any order.&lt;/li>
&lt;/ul>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: k = 3, n = 7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[1,2,4]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 + 2 + 4 = 7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There are no other valid combinations.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: k = 3, n = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[1,2,6],[1,3,5],[2,3,4]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 + 2 + 6 = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 + 3 + 5 = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 + 3 + 4 = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There are no other valid combinations.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: k = 4, n = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: There are no valid combinations.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &amp;gt; 1, there are no valid combination.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題主要關注的點是數字範圍為&lt;code>[1,9]&lt;/code>，每個結果中，數字只能使用一次，而且數字必須是順序排列。例如:&lt;code>2,3,4&lt;/code>,&lt;code>1,2,5&lt;/code>。解決這題我們可以用&lt;strong>back-traking&lt;/strong>大法。只要我們當前的&lt;code>Sum&lt;/code>大於&lt;code>n&lt;/code>我們就直接退回back track回上一步,因為數值只會越來越大，並不是我們想要的。如果&lt;em>Ans&lt;/em>我們所需的&lt;code>k&lt;/code>個就直接判斷是否等於&lt;code>n&lt;/code>，如果是就直接加入到我們的&lt;em>result&lt;/em>即可。&lt;/p></description></item><item><title>[Leetcode] Letter Combinations of a Phone Number(Medium)</title><link>http://localhost:58072/leetcodes/leetcode17/</link><pubDate>Mon, 09 May 2022 21:50:34 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode17/</guid><description>&lt;h2 id="leetcode-17---letter-combinations-of-a-phone-number">LeetCode 17 - Letter Combinations of a Phone Number
&lt;a class="header-anchor" href="#leetcode-17---letter-combinations-of-a-phone-number">&lt;/a>
&lt;/h2>&lt;p>Given a string containing digits from &lt;code>2-9&lt;/code> inclusive, return all possible letter combinations that the number could represent. Return the answer in &lt;strong>any order&lt;/strong>.&lt;/p>
&lt;p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: digits = &amp;#34;23&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: digits = &amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: digits = &amp;#34;2&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題是要我們拿到&lt;code>Input&lt;/code>的數字所能組合出所有字串。解法也很簡單，我們可以透過&lt;code>Map&lt;/code>記錄每個數字代表來那些字符，然後再透過&lt;strong>Back-tracking&lt;/strong>技巧來幫助我們組合字串。你有可能會問什麼是&lt;strong>Back-tracking&lt;/strong>。簡單來說就是一個&lt;strong>Recursive Function&lt;/strong>,但他會迴避一些不正常的數值。比如:&amp;ldquo;abc&amp;rdquo;,而&amp;quot;abc&amp;quot;可能不是我們要的。因此退回上一步的&amp;quot;ab&amp;quot;,並嘗試其他數值/結果。&lt;/p></description></item><item><title>[Leetcode] Flatten Nested List Iterator(Medium)</title><link>http://localhost:58072/leetcodes/leetcode341/</link><pubDate>Sun, 08 May 2022 06:30:23 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode341/</guid><description>&lt;h2 id="leetcode-341---flatten-nested-list-iterator">LeetCode 341 - Flatten Nested List Iterator
&lt;a class="header-anchor" href="#leetcode-341---flatten-nested-list-iterator">&lt;/a>
&lt;/h2>&lt;p>You are given a nested list of integers &lt;code>nestedList&lt;/code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.&lt;/p>
&lt;p>Implement the NestedIterator &lt;code>class&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>&lt;code>NestedIterator(List&amp;lt;NestedInteger&amp;gt; nestedList)&lt;/code> Initializes the iterator with the nested list &lt;code>nestedList&lt;/code>.&lt;/li>
&lt;li>&lt;code>int next()&lt;/code> Returns the next integer in the nested list.&lt;/li>
&lt;li>&lt;code>boolean hasNext()&lt;/code> Returns &lt;code>true&lt;/code> if there are still some integers in the nested list and false otherwise.&lt;/li>
&lt;/ul>
&lt;p>Your code will be tested with the following pseudocode:&lt;/p></description></item><item><title>[Leetcode] 132 Pattern(Medium)</title><link>http://localhost:58072/leetcodes/leetcode456/</link><pubDate>Sat, 07 May 2022 06:30:23 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode456/</guid><description>&lt;h2 id="leetcode-456---132-pattern">LeetCode 456 - 132 Pattern
&lt;a class="header-anchor" href="#leetcode-456---132-pattern">&lt;/a>
&lt;/h2>&lt;p>Given an array of &lt;code>n&lt;/code> integers nums, a &lt;strong>132 pattern&lt;/strong> is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j].&lt;/p>
&lt;p>Return true &lt;em>if there is a 132 pattern in nums, otherwise, return false&lt;/em>.
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,2,3,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: There is no 132 pattern in the sequence.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,1,4,2]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [-1,3,2,0]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題就是要我們找出&lt;code>List&lt;/code>有沒有符合&lt;code>132 Pattern&lt;/code>。那怎麼才算是&lt;code>132 Pattern&lt;/code>呢。從題目定義可以看出在&lt;code>List&lt;/code>中任意的&lt;code>nums[i] &amp;lt; nums[k] &amp;lt; nums[j]，也就是說&lt;/code>nums[k]&lt;code>為最大,&lt;/code>nums[j]&lt;code>為第二大,&lt;/code>nums[i]`為第三大。&lt;/p></description></item><item><title>[LeetCode] Remove All Adjacent Duplicates in String II(Medium)</title><link>http://localhost:58072/leetcodes/leetcode1209/</link><pubDate>Fri, 06 May 2022 21:19:25 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1209/</guid><description>&lt;h2 id="leetcode-1209---remove-all-adjacent-duplicates-in-string-ii">LeetCode 1209 - Remove All Adjacent Duplicates in String II
&lt;a class="header-anchor" href="#leetcode-1209---remove-all-adjacent-duplicates-in-string-ii">&lt;/a>
&lt;/h2>&lt;p>You are given a string &lt;code>s&lt;/code> and an integer &lt;code>k&lt;/code>, a &lt;code>k&lt;/code> &lt;strong>duplicate removal&lt;/strong> consists of choosing &lt;code>k&lt;/code> adjacent and equal letters from &lt;code>s&lt;/code> and removing them, causing the left and the right side of the deleted substring to concatenate together.&lt;/p>
&lt;p>We repeatedly make &lt;code>k&lt;/code> duplicate removals on &lt;code>s&lt;/code> until we no longer can.&lt;/p>
&lt;p>Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.&lt;/p></description></item><item><title>[Leetcode] Implement Stack using Queues(Easy)</title><link>http://localhost:58072/leetcodes/leetcode225/</link><pubDate>Thu, 05 May 2022 09:39:35 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode225/</guid><description>&lt;h2 id="leetcode-225---implement-stack-using-queues">LeetCode 225 - Implement Stack using Queues
&lt;a class="header-anchor" href="#leetcode-225---implement-stack-using-queues">&lt;/a>
&lt;/h2>&lt;p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (&lt;code>push&lt;/code>, &lt;code>top&lt;/code>, &lt;code>pop&lt;/code>, and &lt;code>empty&lt;/code>).&lt;/p>
&lt;p>Implement the &lt;code>MyStack&lt;/code> class:&lt;/p>
&lt;ul>
&lt;li>void &lt;code>push(int x)&lt;/code> Pushes element x to the top of the stack.&lt;/li>
&lt;li>int &lt;code>pop()&lt;/code> Removes the element on the top of the stack and returns it.&lt;/li>
&lt;li>int &lt;code>top()&lt;/code> Returns the element on the top of the stack.&lt;/li>
&lt;li>boolean &lt;code>empty()&lt;/code> Returns &lt;code>true&lt;/code> if the stack is empty, &lt;code>false&lt;/code> otherwise.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Notes&lt;/strong>:&lt;/p></description></item><item><title>[Leetcode] Max Number of K-Sum Pairs(Medium)</title><link>http://localhost:58072/leetcodes/leetcode1679/</link><pubDate>Wed, 04 May 2022 20:11:43 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1679/</guid><description>&lt;h2 id="leetcode-1679---max-number-of-k-sum-pairs">LeetCode 1679 - Max Number of K-Sum Pairs
&lt;a class="header-anchor" href="#leetcode-1679---max-number-of-k-sum-pairs">&lt;/a>
&lt;/h2>&lt;p>You are given an integer array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>.&lt;/p>
&lt;p>In one operation, you can pick two numbers from the array whose sum equals &lt;code>k&lt;/code> and remove them from the array.&lt;/p>
&lt;p>Return &lt;code>the maximum number of operations you can perform on the array&lt;/code>.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,2,3,4], k = 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Starting with nums = [1,2,3,4]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Remove numbers 1 and 4, then nums = [2,3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Remove numbers 2 and 3, then nums = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There are no more pairs that sum up to 5, hence a total of 2 operations.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,1,3,4,3], k = 6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Starting with nums = [3,1,3,4,3]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Remove the first two 3&amp;#39;s, then nums = [1,4,3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There are no more pairs that sum up to 6, hence a total of 1 operation.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題就是要移除&lt;code>Array&lt;/code>中2個elements加起來等於&lt;code>k&lt;/code>的操作有幾次。&lt;br>
第一個解法，我們可以使用&lt;code>sorting&lt;/code>以及&lt;code>two-pointer approach&lt;/code>來解決。先將&lt;code>array&lt;/code>排序，然後設置&lt;code>i&lt;/code>為0,&lt;code>j&lt;/code>為&lt;code>n-1&lt;/code>,直接使用iteration找出&lt;code>nums[i]+nums[j] = k&lt;/code>的數，然後&lt;code>answer+1&lt;/code>即可。&lt;/p></description></item><item><title>[Leetcode] Shortest Unsorted Continuous Subarray(Medium)</title><link>http://localhost:58072/leetcodes/leetcode581/</link><pubDate>Tue, 03 May 2022 18:27:24 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode581/</guid><description>&lt;h2 id="leetcode-581---shortest-unsorted-continuous-subarray">LeetCode 581 - Shortest Unsorted Continuous Subarray
&lt;a class="header-anchor" href="#leetcode-581---shortest-unsorted-continuous-subarray">&lt;/a>
&lt;/h2>&lt;p>Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.&lt;/p>
&lt;p>Return &lt;code>the shortest such subarray and output its length&lt;/code>.&lt;/p>
&lt;p>example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [2,6,4,8,10,9,15]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,2,3,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題比較難懂一點點，這裡先做一下題目的解釋。這題主要先問的是在輸入的&lt;code>Array&lt;/code>裡面找到一個最小需要排序的&lt;code>Sub-array&lt;/code>。&lt;br>
從例子&lt;code>[2,6,4,8,10,9,15]&lt;/code>中，我們可以很明顯的看到&lt;code>[6,4,8,10,9]&lt;/code>並不是ascending order(順序),而這個&lt;code>sub-array&lt;/code>要進行排序的話，所有elements都需要進行排序，所以，他的length是&lt;code>5&lt;/code>。&lt;br>
再舉另外一個例子&lt;code>[1,3,2,3,3]&lt;/code>，這個&lt;code>Array&lt;/code>我們可以看到&lt;code>[3,2,3,3]&lt;/code>並不是順序的，但是在這個&lt;code>sub-array&lt;/code>裡面,只有&lt;code>[3,2]&lt;/code>需要排序,所以，他的結果會是&lt;code>2&lt;/code>。&lt;/p></description></item><item><title>[Leetcode] Sort Array By Parity(Easy)</title><link>http://localhost:58072/leetcodes/leetcode905/</link><pubDate>Mon, 02 May 2022 18:19:41 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode905/</guid><description>&lt;h2 id="leetcode-905---sort-array-by-parity">LeetCode 905 - Sort Array By Parity
&lt;a class="header-anchor" href="#leetcode-905---sort-array-by-parity">&lt;/a>
&lt;/h2>&lt;p>Given an integer array &lt;code>nums&lt;/code>, move all the even integers at the beginning of the array followed by all the odd integers.&lt;/p>
&lt;p>Return &lt;strong>any array&lt;/strong> that satisfies this condition.&lt;/p>
&lt;p>example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,1,2,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [2,4,3,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [0]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [0]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這個問題很簡單，就是把偶數移動到Array的前面，基數移動到後面。我們這裡可以使用&lt;code>Two-pointer approach&lt;/code>, &lt;code>i&lt;/code>為尋找前面的基數，而&lt;code>j&lt;/code> 為尋找後面的偶數，只要&lt;code>nums[i]&lt;/code>為基數,&lt;code>nums[j]&lt;/code>為偶數就進行交換。&lt;/p></description></item><item><title>[Leetcode] Backspace String Compare(Easy)</title><link>http://localhost:58072/leetcodes/leetcode844/</link><pubDate>Sun, 01 May 2022 17:52:25 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode844/</guid><description>&lt;h2 id="leetcode-844---backspace-string-compare">LeetCode 844 - Backspace String Compare
&lt;a class="header-anchor" href="#leetcode-844---backspace-string-compare">&lt;/a>
&lt;/h2>&lt;p>Given two strings s and t, return true &lt;em>if they are equal when both are typed into empty text editors&lt;/em>. &lt;code>'#'&lt;/code> means a backspace character.&lt;/p>
&lt;p>Note that after backspacing an empty text, the text will continue empty.&lt;/p>
&lt;p>example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: s = &amp;#34;ab#c&amp;#34;, t = &amp;#34;ad#c&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Both s and t become &amp;#34;ac&amp;#34;.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: s = &amp;#34;ab##&amp;#34;, t = &amp;#34;c#d#&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Both s and t become &amp;#34;&amp;#34;.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: s = &amp;#34;a#c&amp;#34;, t = &amp;#34;b&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: s becomes &amp;#34;c&amp;#34; while t becomes &amp;#34;b&amp;#34;.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題主要要什麼比較2個String移除於&lt;code>#&lt;/code>前的字符後是否為相同的String，就相當於&lt;code>Backspace(#) 字符&lt;/code>。
這題有2種解法:&lt;/p></description></item><item><title>[Leetcode] Trim a Binary Search Tree(Medium)</title><link>http://localhost:58072/leetcodes/leetcode669/</link><pubDate>Fri, 15 Apr 2022 18:29:14 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode669/</guid><description>&lt;h2 id="leetcode-669---trim-a-binary-search-tree">LeetCode 669 - Trim a Binary Search Tree
&lt;a class="header-anchor" href="#leetcode-669---trim-a-binary-search-tree">&lt;/a>
&lt;/h2>&lt;p>Given the root of a binary search tree and the lowest and highest boundaries as &lt;code>low&lt;/code> and &lt;code>high&lt;/code>, trim the tree so that all its elements lies in &lt;code>[low, high]&lt;/code>. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&amp;rsquo;s descendant should remain a descendant). It can be proven that there is a &lt;strong>unique answer&lt;/strong>.&lt;/p></description></item><item><title>[Leetcode] Search in a Binary Search Tree(Easy)</title><link>http://localhost:58072/leetcodes/leetcode700/</link><pubDate>Thu, 14 Apr 2022 15:05:44 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode700/</guid><description>&lt;h2 id="leetcode-700---search-in-a-binary-search-tree">LeetCode 700 - Search in a Binary Search Tree
&lt;a class="header-anchor" href="#leetcode-700---search-in-a-binary-search-tree">&lt;/a>
&lt;/h2>&lt;p>You are given the root of a binary search tree (BST) and an integer val.&lt;/p>
&lt;p>Find the node in the BST that the node&amp;rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [4,2,7,1,3], val = 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [2,1,3]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [4,2,7,1,3], val = 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>在解決問題之前，我們需要知道什麼是&lt;code>Binary Search Tree&lt;/code>。根據&lt;code>BST&lt;/code>的定義:&lt;/p></description></item><item><title>[Leetcode] Shift 2D Grid(Easy)</title><link>http://localhost:58072/leetcodes/leetcode1260/</link><pubDate>Wed, 13 Apr 2022 19:14:44 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1260/</guid><description>&lt;h2 id="leetcode-1260----shift-2d-grid">LeetCode 1260 - Shift 2D Grid
&lt;a class="header-anchor" href="#leetcode-1260----shift-2d-grid">&lt;/a>
&lt;/h2>&lt;p>Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.&lt;/p>
&lt;p>In one shift operation:&lt;/p>
&lt;ul>
&lt;li>Element at grid[i][j] moves to grid[i][j + 1].&lt;/li>
&lt;li>Element at grid[i][n - 1] moves to grid[i + 1][0].&lt;/li>
&lt;li>Element at grid[m - 1][n - 1] moves to grid[0][0].&lt;/li>
&lt;/ul>
&lt;p>Return the 2D grid after applying shift operation k times.&lt;/p>
&lt;p>example&lt;/p></description></item><item><title>[Leetcode] Spiral Matrix II(Medium)</title><link>http://localhost:58072/leetcodes/leetcode59/</link><pubDate>Wed, 13 Apr 2022 14:26:29 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode59/</guid><description>&lt;h2 id="leetcode-59----spiral-matrix-ii">LeetCode 59 - Spiral Matrix II
&lt;a class="header-anchor" href="#leetcode-59----spiral-matrix-ii">&lt;/a>
&lt;/h2>&lt;p>Given a positive integer n, generate an n x n matrix filled with elements from 1 to n&lt;sup>2&lt;/sup> in spiral order.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: n = 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[1,2,3],[8,9,4],[7,6,5]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: n = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[1]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題跟&lt;code>Spiral Matrix&lt;/code>做法差不多，我們不難發現他的移動模式就是(&lt;em>右→下↓左←上&lt;/em>)，我們只需要通過幾個變數來限制移動的步數。另外，這題需要我們返回一個n&lt;sup>2&lt;/sup>的array，所以，需要額外定義一個counter來記錄每次插入的數值為多少，因此，只要counter 到達n&lt;sup>2&lt;/sup>的大小就知道是否完成插入所需的值。&lt;/p></description></item><item><title>[Leetcode] Game of Life(Medium)</title><link>http://localhost:58072/leetcodes/leetcode289/</link><pubDate>Tue, 12 Apr 2022 19:15:53 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode289/</guid><description>&lt;h2 id="leetcode-289----game-of-life">LeetCode 289 - Game of Life
&lt;a class="header-anchor" href="#leetcode-289----game-of-life">&lt;/a>
&lt;/h2>&lt;p>According to Wikipedia&amp;rsquo;s article: &amp;ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;rdquo;&lt;/p>
&lt;p>The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):&lt;/p></description></item><item><title>[Leetcode] Baseball Game(Easy)</title><link>http://localhost:58072/leetcodes/leetcode682/</link><pubDate>Sun, 10 Apr 2022 19:15:31 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode682/</guid><description>&lt;h2 id="leetcode-682---baseball-game">LeetCode 682 - Baseball Game
&lt;a class="header-anchor" href="#leetcode-682---baseball-game">&lt;/a>
&lt;/h2>&lt;p>You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&amp;rsquo; scores.&lt;/p>
&lt;p>At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:&lt;/p></description></item><item><title>[Note]Creational Singleton Pattern</title><link>http://localhost:58072/post/design-pattern/creational-singleton-pattern/</link><pubDate>Sat, 09 Apr 2022 11:19:39 +0800</pubDate><guid>http://localhost:58072/post/design-pattern/creational-singleton-pattern/</guid><description>&lt;h2 id="什麼是singleton-pattern單例模式呢">什麼是Singleton Pattern(單例模式)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afsingleton-pattern%e5%96%ae%e4%be%8b%e6%a8%a1%e5%bc%8f%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>定義:一個Class在系統中只會存在一個實例(instance),整個系統中只提供1個可使用的instance,以確保唯一性,並節省系統資源。&lt;/p></description></item><item><title>[Leetcode] Top K Frequent Elements(Medium)</title><link>http://localhost:58072/leetcodes/leetcode347/</link><pubDate>Sat, 09 Apr 2022 06:22:34 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode347/</guid><description>&lt;h2 id="leetcode-347---top-k-frequent-elements">LeetCode 347 - Top K Frequent Elements
&lt;a class="header-anchor" href="#leetcode-347---top-k-frequent-elements">&lt;/a>
&lt;/h2>&lt;p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,1,1,2,2,3], k = 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1,2]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1], k = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這一題需要我們返回K個數量最多的element。所以，我們可以使用&lt;code>map&lt;/code>記錄我們array中element的個數，然後在把他們以&lt;code>&amp;lt;frequency,element&amp;gt;&lt;/code>存到&lt;code>priority queue/max queue&lt;/code>，最後只要返回&lt;code>priority queue&lt;/code>中的&lt;code>k&lt;/code>個element即可。&lt;/p></description></item><item><title>[Leetcode] Kth Largest Element in a Stream(Easy)</title><link>http://localhost:58072/leetcodes/leetcode703/</link><pubDate>Fri, 08 Apr 2022 20:21:39 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode703/</guid><description>&lt;h2 id="leetcode-703---kth-largest-element-in-a-stream">LeetCode 703 - Kth Largest Element in a Stream
&lt;a class="header-anchor" href="#leetcode-703---kth-largest-element-in-a-stream">&lt;/a>
&lt;/h2>&lt;p>Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p>
&lt;p>Implement KthLargest class:&lt;/p>
&lt;ul>
&lt;li>&lt;code>KthLargest(int k, int[] nums)&lt;/code> Initializes the object with the integer &lt;code>k&lt;/code> and the stream of integers nums.&lt;/li>
&lt;li>&lt;code>int add(int val)&lt;/code> Appends the integer val to the stream and returns the element representing the kth largest element in the stream.&lt;/li>
&lt;/ul>
&lt;p>example:&lt;/p></description></item><item><title>長庚大學-畢業專題獎項</title><link>http://localhost:58072/achievement/my-first-reward/</link><pubDate>Mon, 04 Apr 2022 19:07:44 +0800</pubDate><guid>http://localhost:58072/achievement/my-first-reward/</guid><description>&lt;h3 id="reward">Reward
&lt;a class="header-anchor" href="#reward">&lt;/a>
&lt;/h3>&lt;p>這是我跟組員們一起討論、辛苦了多個日夜，能一起做寫程式，分享知識的感覺真的很棒&amp;gt;&amp;lt;。雖然不知道以後還沒有機會一起合作，但還是非常感謝他們願意陪我躲在實驗室裡面一整天(╥╯^╰╥)。希望他們能好好生活，好好學習！&lt;/p></description></item><item><title>[Note]Creational Abstract Factory</title><link>http://localhost:58072/post/design-pattern/creational-abstract-factory/</link><pubDate>Sun, 03 Apr 2022 19:38:20 +0800</pubDate><guid>http://localhost:58072/post/design-pattern/creational-abstract-factory/</guid><description>&lt;h2 id="什麼是abstract-factory抽象工廠呢">什麼是Abstract Factory(抽象工廠)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afabstract-factory%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%bb%a0%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>定義: 又稱為Kit模式。提供一個創建系列相關或者互相依賴的Interface，而無需指定其具體的class&lt;/p>
&lt;/blockquote>
&lt;h3 id="簡單例子">簡單例子
&lt;a class="header-anchor" href="#%e7%b0%a1%e5%96%ae%e4%be%8b%e5%ad%90">&lt;/a>
&lt;/h3>&lt;p>&lt;em>注: 以下程式單純用於解釋，並不能實際執行&lt;/em>&lt;/p></description></item><item><title>[Note]Simple RateLimiter Example Based on IP</title><link>http://localhost:58072/post/note/simple-ratelimiter-example-based-on-ip/</link><pubDate>Wed, 30 Mar 2022 16:05:57 +0800</pubDate><guid>http://localhost:58072/post/note/simple-ratelimiter-example-based-on-ip/</guid><description>&lt;h3 id="基於gin實作rate-limiter">基於Gin實作Rate Limiter
&lt;a class="header-anchor" href="#%e5%9f%ba%e6%96%bcgin%e5%af%a6%e4%bd%9crate-limiter">&lt;/a>
&lt;/h3>&lt;p>假設我們有2個APIs,而每個API都需要消耗1個&lt;code>Tokens&lt;/code>&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">uri&lt;/th>
 &lt;th style="text-align: left">method&lt;/th>
 &lt;th style="text-align: left">desc&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">/api/posts/{id}&lt;/td>
 &lt;td style="text-align: left">GET&lt;/td>
 &lt;td style="text-align: left">return a simple demo message&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">/ping&lt;/td>
 &lt;td style="text-align: left">GET&lt;/td>
 &lt;td style="text-align: left">return pong&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>我們先設置一下rate limiter桶子的容量只能放下一個tokens,而tokens則會每秒生產5個。存取API時,若沒有Token可以用，就需要等待token下一次生產並放到桶子裡，才能繼續進行下去。&lt;/strong>&lt;/p></description></item><item><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><link>http://localhost:58072/post/note/token-bucket-intro/</link><pubDate>Tue, 29 Mar 2022 18:33:07 +0800</pubDate><guid>http://localhost:58072/post/note/token-bucket-intro/</guid><description>&lt;h2 id="token-bucket令牌桶算法">Token Bucket(令牌桶算法)
&lt;a class="header-anchor" href="#token-bucket%e4%bb%a4%e7%89%8c%e6%a1%b6%e7%ae%97%e6%b3%95">&lt;/a>
&lt;/h2>&lt;h4 id="什麼是token-bucket-呢">什麼是Token Bucket 呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%aftoken-bucket-%e5%91%a2">&lt;/a>
&lt;/h4>&lt;blockquote>
&lt;p>簡單來說就是運用Token Bucket的系統會以一個設定的速率往桶子(Bucket)裡面丟令牌(Token)。如果請求(Request)需要被處理時，就必需得Bucket裡的Token。當桶子裡面的沒有Token可以分配/獲取時，也就是說Bucket現在是空的(Token已經被其他令牌拿完了)，系統則會拒絕這個請求的服務。&lt;/p></description></item><item><title>[Note]Creational-Factory</title><link>http://localhost:58072/post/design-pattern/creational-factory/</link><pubDate>Sun, 27 Mar 2022 16:55:17 +0800</pubDate><guid>http://localhost:58072/post/design-pattern/creational-factory/</guid><description>&lt;h2 id="什麼是factory工廠呢">什麼是Factory(工廠)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%affactory%e5%b7%a5%e5%bb%a0%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>定義:建立一個接口,讓子類自己決定實現哪一個Factory,其&lt;strong>重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題&lt;/strong>&lt;/p></description></item><item><title>[Note]Creational-Simple Factory</title><link>http://localhost:58072/post/design-pattern/creational-simple-factory/</link><pubDate>Sun, 27 Mar 2022 16:42:45 +0800</pubDate><guid>http://localhost:58072/post/design-pattern/creational-simple-factory/</guid><description>&lt;h2 id="什麼是simple-factory簡單工廠呢">什麼是Simple Factory(簡單工廠)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afsimple-factory%e7%b0%a1%e5%96%ae%e5%b7%a5%e5%bb%a0%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>簡單而言就是: 由一個工廠來生產全部產品
定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object&lt;/p></description></item><item><title>[Note]Design Pattern Princeple</title><link>http://localhost:58072/post/design-pattern/design-pattern-princeple/</link><pubDate>Sun, 27 Mar 2022 16:18:55 +0800</pubDate><guid>http://localhost:58072/post/design-pattern/design-pattern-princeple/</guid><description>&lt;h2 id="什麼是design-pattern設計模式呢">什麼是Design Pattern(設計模式)呢?
&lt;a class="header-anchor" href="#%e4%bb%80%e9%ba%bc%e6%98%afdesign-pattern%e8%a8%ad%e8%a8%88%e6%a8%a1%e5%bc%8f%e5%91%a2">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，&lt;strong>如何解決問題的一種方案&lt;/strong>&lt;/p></description></item><item><title>[Note]What Is JWT(Json Web Token)-EN</title><link>http://localhost:58072/post/note/jwt-note/</link><pubDate>Thu, 24 Mar 2022 13:52:49 +0800</pubDate><guid>http://localhost:58072/post/note/jwt-note/</guid><description>&lt;h2 id="what-is-jwtjson-web-token">What is JWT(Json Web Token)?
&lt;a class="header-anchor" href="#what-is-jwtjson-web-token">&lt;/a>
&lt;/h2>&lt;p>The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.&lt;br>
It&amp;rsquo;s used for &lt;em>identity authentication&lt;/em> between client and the server that allows accessing resources in the server.&lt;/p>
&lt;h2 id="the-structure-of-jwt">The Structure of JWT
&lt;a class="header-anchor" href="#the-structure-of-jwt">&lt;/a>
&lt;/h2>&lt;p>JWT consists of three parts including:&lt;/p></description></item><item><title>[CGU]Graduation Project</title><link>http://localhost:58072/project/final-project/</link><pubDate>Fri, 31 Dec 2021 20:22:11 +0800</pubDate><guid>http://localhost:58072/project/final-project/</guid><description>&lt;p>&lt;del>
&lt;a href="https://github.com/RyanTokManMokMTM/MovieAppSwiftUI.git" title="OTT Movies recommender system-IOS Client" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 &lt;strong>OTT Movies recommender system-IOS Client&lt;/strong>
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/del>
Project have been changed/updated&lt;/p>
&lt;p>&lt;img src="http://localhost:58072/imgs/img-lazy-loading.gif" data-src="http://localhost:58072/imgs/iosClient.png" alt="client" />&lt;/p>
&lt;h3 id="frontend">Frontend
&lt;a class="header-anchor" href="#frontend">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>SwiftUI apple framework&lt;/li>
&lt;li>UIKit apple framework&lt;/li>
&lt;/ul>
&lt;h4 id="backend">Backend
&lt;a class="header-anchor" href="#backend">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>Vapor Swift Backend framework&lt;/li>
&lt;/ul>
&lt;h4 id="database">Database:
&lt;a class="header-anchor" href="#database">&lt;/a>
&lt;/h4>&lt;ul>
&lt;li>PostgresSQL Database&lt;/li>
&lt;/ul>
&lt;h3 id="demo-video">Demo Video
&lt;a class="header-anchor" href="#demo-video">&lt;/a>
&lt;/h3>&lt;p>&lt;video src="http://localhost:58072/videos/final.MP4" controls="controls" width="500" height="300">&lt;/video>&lt;/p>
&lt;!-- ### Updated Video
&lt;video src="http://localhost:58072/videos/ott-app.mov" controls="controls" width="500" height="300">&lt;/video> --></description></item><item><title>About me 關於我</title><link>http://localhost:58072/about.html</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><guid>http://localhost:58072/about.html</guid><description>&lt;h3 id="introduction">Introduction
&lt;a class="header-anchor" href="#introduction">&lt;/a>
&lt;/h3>&lt;p>你好~ 歡迎來到我的網站!&lt;br>
我是Jackson.tmm, 是一個從香港來到台灣讀大學的四年級學生。&lt;del>目前就讀於&lt;strong>長庚大學-資訊工程學系(Computer Science And Information Engineering)&lt;/strong>&lt;/del>。目前已經畢業了。我目前主要是研究學習&lt;strong>後端開發&lt;/strong>的技術。&lt;/p></description></item></channel></rss>