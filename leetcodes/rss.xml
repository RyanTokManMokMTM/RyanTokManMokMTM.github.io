<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcodes on Jackson的博客</title><link>https://ryantokmanmokmtm.github.io/leetcodes/</link><description>Recent content in Leetcodes on Jackson的博客</description><generator>Hugo</generator><language>zh-TW</language><lastBuildDate>Thu, 18 May 2023 15:44:17 +0800</lastBuildDate><atom:link href="https://ryantokmanmokmtm.github.io/leetcodes/rss.xml" rel="self" type="application/rss+xml"/><item><title>[Leetcode] Maximum Twin Sum of a Linked List(M)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2130/</link><pubDate>Thu, 18 May 2023 15:44:17 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2130/</guid><description>LeetCode 2130 - Maximum Twin Sum of a Linked List In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &amp;lt;= i &amp;lt;= (n / 2) - 1. For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of</description></item><item><title>[Leetcode] Maximum Length of Repeated Subarray(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode718/</link><pubDate>Tue, 20 Sep 2022 14:47:44 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode718/</guid><description>LeetCode 718 - Maximum Length of Repeated Subarray Given two integer arrays ``nums1andnums2`, return the maximum length of a subarray that appears in both arrays. Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3,2,1]. Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0] Output: 5 How can we solve this problem? 這題要我們找出2個arr</description></item><item><title>[Leetcode] Find Duplicate File in System(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode609/</link><pubDate>Mon, 19 Sep 2022 14:41:56 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode609/</guid><description>LeetCode 42 - Trapping Rain Water Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order. A group of duplicate files consists of at least two files that have the same content. A single directory info string in</description></item><item><title>[Leetcode] Trapping Rain Water(Hard)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode42/</link><pubDate>Sun, 18 Sep 2022 14:29:08 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode42/</guid><description>LeetCode 42 - Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. example Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Input: height = [4,2,0,3,2,5] Output: 9 How</description></item><item><title>[Leetcode] Palindrome Pairs(Hard)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode336/</link><pubDate>Sat, 17 Sep 2022 20:41:48 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode336/</guid><description>LeetCode 336 - Palindrome Pairs Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome. example Input: words = [&amp;#34;abcd&amp;#34;,&amp;#34;dcba&amp;#34;,&amp;#34;lls&amp;#34;,&amp;#34;s&amp;#34;,&amp;#34;sssll&amp;#34;] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [&amp;#34;dcbaabcd&amp;#34;,&amp;#34;abcddcba&amp;#34;,&amp;#34;slls&amp;#34;,&amp;#34;llssssll&amp;#34;] Input: words = [&amp;#34;bat&amp;#34;,&amp;#34;tab&amp;#34;,&amp;#34;cat&amp;#34;] Output: [[0,1],[1,0]] Explanation: The palindromes are [&amp;#34;battab&amp;#34;,&amp;#34;tabbat&amp;#34;] How can we solve this problem? 在解</description></item><item><title>[Leetcode] Maximum Score from Performing Multiplication Operations(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1770/</link><pubDate>Fri, 16 Sep 2022 20:42:00 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1770/</guid><description>LeetCode 1770 - Maximum Score from Performing Multiplication Operations You are given two integer arrays nums and multipliers of size n and m respectively, where n &amp;gt;= m. The arrays are 1-indexed. You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will: Choose one integer x from either the start or the end of the array nums. Add multipliers[i]</description></item><item><title>[Leetcode] Pancake Sorting(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode969/</link><pubDate>Thu, 15 Sep 2022 00:31:46 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode969/</guid><description>LeetCode 969 - Pancake Sorting Given an array of integers arr, sort the array by performing a series of pancake flips. In one pancake flip we do the following steps: Choose an integer k where 1 &amp;lt;= k &amp;lt;= arr.length. Reverse the sub-array arr[0...k-1] (0-indexed). For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4]</description></item><item><title>[Leetcode] Find Original Array From Doubled Array(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2007/</link><pubDate>Thu, 15 Sep 2022 00:21:27 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2007/</guid><description>LeetCode 2007 - Find Original Array From Doubled Array An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array. Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.</description></item><item><title>[Leetcode] Pseudo-Palindromic Paths in a Binary Tree(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1457/</link><pubDate>Wed, 14 Sep 2022 15:27:08 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1457/</guid><description>LeetCode 1457 - Pseudo-Palindromic Paths in a Binary Tree Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome. Return the number of pseudo-palindromic paths going from the root node to leaf nodes. example Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation:</description></item><item><title>[Leetcode] UTF-8 Validation(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode393/</link><pubDate>Tue, 13 Sep 2022 14:41:37 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode393/</guid><description>LeetCode 393 - UTF-8 Validation Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters). A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For a 1-byte character, the first bit is a 0, followed by its Unicode code. For an n-bytes character, the first</description></item><item><title>[Leetcode] Bag of Tokens(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode948/</link><pubDate>Mon, 12 Sep 2022 18:01:44 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode948/</guid><description>LeetCode 948 - Bag of Tokens You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed). Your goal is to maximize your total score by potentially playing each token in one of two ways: If your current power is at least tokens[i], you may play the ith token face up, losing tokens[i]power and</description></item><item><title>[Leetcode] The Number of Weak Characters in the Game(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1996/</link><pubDate>Fri, 09 Sep 2022 23:36:50 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1996/</guid><description>LeetCode 1996 - The Number of Weak Characters in the Game You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game. A character is said to be weak if any other character has both attack and</description></item><item><title>[Leetcode] Binary Tree Inorder Traversal(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode94/</link><pubDate>Thu, 08 Sep 2022 20:22:06 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode94/</guid><description>LeetCode 94 - Binary Tree Inorder Traversal Given the root of a binary tree, return the inorder traversal of its nodes&amp;rsquo; values. example Input: root = [1,null,2,3] Output: [1,3,2] Input: root = [] Output: [] Input: root = [1] Output: [1] How can we solve this problem? 這題很簡單,只要使用中序遍歷即可。 Solution: /** * Definition for a</description></item><item><title>[Leetcode] Construct String from Binary Tree(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode606/</link><pubDate>Wed, 07 Sep 2022 10:12:28 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode606/</guid><description>LeetCode 606 - Construct String from Binary Tree Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. example Input: root = [1,2,3,4] Output: &amp;#34;1(2(4))(3)&amp;#34; Explanation: Originally, it needs to be</description></item><item><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode442/</link><pubDate>Tue, 06 Sep 2022 22:02:11 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode442/</guid><description>LeetCode 442 - Find All Duplicates in an Array Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice. You must write an algorithm that runs in O(n) time and uses only constant extra space. example Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Input:</description></item><item><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2196/</link><pubDate>Tue, 06 Sep 2022 21:45:02 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2196/</guid><description>LeetCode 2196 - Create Binary Tree From Descriptions You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore, If isLefti == 1, then childi is the left child of parenti. If isLefti == 0, then childi is the right child of parenti. Construct the binary tree described by descriptions and</description></item><item><title>[Leetcode] Binary Tree Pruning(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode814/</link><pubDate>Tue, 06 Sep 2022 21:30:56 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode814/</guid><description>LeetCode 814 - Binary Tree Pruning Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed. A subtree of a node node is node plus every node that is a descendant of node. example Input: root = [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property &amp;#34;every subtree not containing a 1&amp;#34;. The</description></item><item><title>[Leetcode] Reverse Linked List II(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode92/</link><pubDate>Thu, 21 Jul 2022 11:09:21 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode92/</guid><description>LeetCode 92 - Reverse Linked List II Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list. example Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Input: head = [5], left = 1, right = 1 Output: [5] How can we</description></item><item><title>[Leetcode DP] K Inverse Pairs Array(Hard)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode629/</link><pubDate>Sun, 17 Jul 2022 11:55:10 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode629/</guid><description>這題主要是學習DP思想，做個小記錄 LeetCode 629 - K Inverse Pairs Array For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length and nums[i] &amp;gt; nums[j]. Given two integersn and k, return the number of different arrays consist of numbers from 1 to n such</description></item><item><title>[Leetcode DP] Counting Bits(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes338/</link><pubDate>Thu, 23 Jun 2022 11:33:51 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes338/</guid><description>LeetCode 338 - Counting Bits Given an integer n, return an array ans of length n + 1 such that for each i (0 &amp;lt;= i &amp;lt;= n), ans[i] is the number of 1&amp;rsquo;s in the binary representation of i. example: Input: n = 2 Output: [0,1,1] Explanation: 0 --&amp;gt; 0 1 --&amp;gt; 1 2 --&amp;gt; 10 Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 --&amp;gt; 0 1 --&amp;gt; 1</description></item><item><title>[Leetcode] Kth Largest Element in an Array(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes215/</link><pubDate>Wed, 22 Jun 2022 22:55:53 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes215/</guid><description>LeetCode 1268 - Search Suggestions System Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. example: Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 How can we solve this problem? 這題要我們</description></item><item><title>[Leetcode] Furthest Building You Can Reach(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes1642/</link><pubDate>Tue, 21 Jun 2022 22:55:43 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes1642/</guid><description>LeetCode 1642 - Furthest Building You Can Reach You are given an integer array heights representing the heights of buildings, some bricks, and some ladders. You start your journey from building 0 and move to the next building by possibly using bricks or ladders. While moving from building i to building i+1 (0-indexed), If the current building&amp;rsquo;s height is greater than or equal to the next building&amp;rsquo;s height, you do</description></item><item><title>[Leetcode] Short Encoding of Words(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode802/</link><pubDate>Mon, 20 Jun 2022 12:45:05 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode802/</guid><description>820 - Short Encoding of Words A valid encoding of an array of words is any reference string s and array of indices indices such that: words.length == indices.length The reference string s ends with the '#' character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i]. Given an array of words, return the</description></item><item><title>[Leetcode] Longest Palindromic Substring(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode5/</link><pubDate>Thu, 16 Jun 2022 14:09:50 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode5/</guid><description>LeetCode 5 - Longest Palindromic Substring Given a string s, return the longest palindromic substring in s. example Input: s = &amp;#34;babad&amp;#34; Output: &amp;#34;bab&amp;#34; Explanation: &amp;#34;aba&amp;#34; is also a valid answer. Input: s = &amp;#34;cbbd&amp;#34; Output: &amp;#34;bb&amp;#34; How can we solve this problem? 要解決這題，我們必須要先知道什麼是Palindrome</description></item><item><title>[Leetcode] Combination Sum III(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode216/</link><pubDate>Tue, 10 May 2022 11:41:43 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode216/</guid><description>LeetCode 216 - Combination Sum III Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. example Input: k = 3,</description></item><item><title>[Leetcode] Letter Combinations of a Phone Number(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode17/</link><pubDate>Mon, 09 May 2022 21:50:34 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode17/</guid><description>LeetCode 17 - Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. example Input: digits = &amp;#34;23&amp;#34; Output: [&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;] Input: digits = &amp;#34;&amp;#34; Output: []</description></item><item><title>[Leetcode] Flatten Nested List Iterator(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode341/</link><pubDate>Sun, 08 May 2022 06:30:23 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode341/</guid><description>LeetCode 341 - Flatten Nested List Iterator You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: NestedIterator(List&amp;lt;NestedInteger&amp;gt; nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there</description></item><item><title>[Leetcode] 132 Pattern(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode456/</link><pubDate>Sat, 07 May 2022 06:30:23 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode456/</guid><description>LeetCode 456 - 132 Pattern Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. example Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Input: nums =</description></item><item><title>[LeetCode] Remove All Adjacent Duplicates in String II(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1209/</link><pubDate>Fri, 06 May 2022 21:19:25 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1209/</guid><description>LeetCode 1209 - Remove All Adjacent Duplicates in String II You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can. Return the final string after all</description></item><item><title>[Leetcode] Implement Stack using Queues(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode225/</link><pubDate>Thu, 05 May 2022 09:39:35 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode225/</guid><description>LeetCode 225 - Implement Stack using Queues Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the</description></item><item><title>[Leetcode] Max Number of K-Sum Pairs(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1679/</link><pubDate>Wed, 04 May 2022 20:11:43 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1679/</guid><description>LeetCode 1679 - Max Number of K-Sum Pairs You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array. example Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove</description></item><item><title>[Leetcode] Shortest Unsorted Continuous Subarray(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode581/</link><pubDate>Tue, 03 May 2022 18:27:24 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode581/</guid><description>LeetCode 581 - Shortest Unsorted Continuous Subarray Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length. example: Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make</description></item><item><title>[Leetcode] Sort Array By Parity(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode905/</link><pubDate>Mon, 02 May 2022 18:19:41 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode905/</guid><description>LeetCode 905 - Sort Array By Parity Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. example: Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Input: nums = [0] Output: [0] How can we solve this problem? 這個問題</description></item><item><title>[Leetcode] Backspace String Compare(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode844/</link><pubDate>Sun, 01 May 2022 17:52:25 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode844/</guid><description>LeetCode 844 - Backspace String Compare Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character. Note that after backspacing an empty text, the text will continue empty. example: Input: s = &amp;#34;ab#c&amp;#34;, t = &amp;#34;ad#c&amp;#34; Output: true Explanation: Both s and t become &amp;#34;ac&amp;#34;. Input: s = &amp;#34;ab##&amp;#34;, t = &amp;#34;c#d#&amp;#34; Output: true Explanation:</description></item><item><title>[Leetcode] Trim a Binary Search Tree(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode669/</link><pubDate>Fri, 15 Apr 2022 18:29:14 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode669/</guid><description>LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&amp;rsquo;s descendant should remain a descendant). It can be proven that there</description></item><item><title>[Leetcode] Search in a Binary Search Tree(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode700/</link><pubDate>Thu, 14 Apr 2022 15:05:44 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode700/</guid><description>LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node&amp;rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. example Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5</description></item><item><title>[Leetcode] Shift 2D Grid(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1260/</link><pubDate>Wed, 13 Apr 2022 19:14:44 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1260/</guid><description>LeetCode 1260 - Shift 2D Grid Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times. example</description></item><item><title>[Leetcode] Spiral Matrix II(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode59/</link><pubDate>Wed, 13 Apr 2022 14:26:29 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode59/</guid><description>LeetCode 59 - Spiral Matrix II Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. example Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Input: n = 1 Output: [[1]] How can we solve this problem? 這題跟Spiral Matrix做法差不多，我們不</description></item><item><title>[Leetcode] Game of Life(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode289/</link><pubDate>Tue, 12 Apr 2022 19:15:53 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode289/</guid><description>LeetCode 289 - Game of Life According to Wikipedia&amp;rsquo;s article: &amp;ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;rdquo; The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight</description></item><item><title>[Leetcode] Baseball Game(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode682/</link><pubDate>Sun, 10 Apr 2022 19:15:31 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode682/</guid><description>LeetCode 682 - Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&amp;rsquo; scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the</description></item><item><title>[Leetcode] Top K Frequent Elements(Medium)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode347/</link><pubDate>Sat, 09 Apr 2022 06:22:34 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode347/</guid><description>LeetCode 347 - Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. example Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] How can we solve this problem? 這一題需要我們返回K個數量最多</description></item><item><title>[Leetcode] Kth Largest Element in a Stream(Easy)</title><link>https://ryantokmanmokmtm.github.io/leetcodes/leetcode703/</link><pubDate>Fri, 08 Apr 2022 20:21:39 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/leetcodes/leetcode703/</guid><description>LeetCode 703 - Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns</description></item></channel></rss>