<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>[Leetcode] Bag of Tokens(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode948/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>greedy</tag><tag>sort</tag><tag>two pointer</tag></tags><content type="html"> LeetCode 948 - Bag of Tokens You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed).
Your goal is to maximize your total score by potentially playing each token in one of two ways:
If your current power is at least tokens[i], you may play the ith token face up, losing tokens[i]power and gaining 1a score. If your current score is at least 1, you may play the ith token face down, gaining tokens[i] power and losing 1 score. Each token may be played at most once and in any order. You do not have to play all the tokens. Return the largest possible score you can achieve after playing any number of tokens.
example
Input: tokens = [100,200], power = 150 Output: 1 Explanation: Play the 0th token (100) face up, your power becomes 50 and score becomes 1. There is no need to play the 1st token since you cannot play it face up to add to your score. Input: tokens = [100,200,300,400], power = 200 Output: 2 Explanation: Play the tokens in this order to get a score of 2: 1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1. 2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0. 3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1. 4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2. How can we solve this problem? 這題的解題思路是這樣透過貪心(gready),也就是說我能用多少power換分就用多少，如果不夠了我就用分換power。換句話說，就是先從最低的token開始換,直到足夠的power後，就以分來換取最高的power,直到不符合條件未知或者沒有任何token可以買為止。
因為要知道當前最大和最小，所以要先排序
Solution: class Solution { public: int bagOfTokensScore(vector&lt;int>&amp; tokens, int power) { //maxinum if(tokens.empty())return 0; int score = 0; sort(tokens.begin(),tokens.end()); /* strategy: get the mininum token if not enough -> get maxinum token if it has enough power -> get this token */ int i = 0; int j = tokens.size() - 1; int res = 0; while(i &lt;= j){ if(power >= tokens[i]){ score += 1; power -= tokens[i++]; res = max(res,score); }else if(score > 0){ score -= 1; power += tokens[j--]; } else break; } return res; } };</content></entry><entry><title>[Leetcode] The Number of Weak Characters in the Game(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1996/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 1996 - The Number of Weak Characters in the Game You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.
A character is said to be weak if any other character has both attack and defense levels strictly greater than this character&rsquo;s attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj attacki and defensej > defensei.
Return the number of weak characters.
example
Input: properties = [[5,5],[6,3],[3,6]] Output: 0 Explanation: No character has strictly greater attack and defense than the other. Input: properties = [[2,2],[3,3]] Output: 1 Explanation: The first character is weak because the second character has a strictly greater attack and defense. How can we solve this problem? 這題就是要我們找出多少個弱角色(會被攻擊的人)。對於這種包含了2個維度資訊的題目(attack,defense)，直接藉並不好解，所以，通常我們都會固定一個維度去解另外一個維度，這樣就會相對容易許多。
這題我們可以透過固定attack這個維度。因為我們知道高attack的可以攻擊低attackd的人。所以我們根據attack做排序。這樣attack就會是單調遞增排序。我們自然就可以不讓管這個維度(因為已經符合 attacki &lt; attackj 這個條件)。之後我們只需要處理defense這個維度就可以了。
defense這個維度必須以單調遞減的方式處理! 為什麼呢?
假設 Attack : [[1,1],[1,2],[2,4]] -> 這裡會有2個attack為1的角色。如果不以遞減的方式除了,這樣就會不符合條件(相同attack不能互打)。所以一遞減方式會變成這樣[[1,2],[1,1]...]，這樣一來就能避免互打的情況
解決完維度問題後，就很簡單了，只需要透過stack就可以知道有多少個人被攻擊了。只要進來的人defense的比stack top的人defense 大就+1即可。
Solution: class Solution { public: int numberOfWeakCharacters(vector&lt;vector&lt;int>>&amp; pro) { //[attacki, defensei] sort(pro.begin(),pro.end(),[&amp;](auto &amp;a1,auto &amp;a2){ if(a1[0]==a2[0]){ return a1[1]>a2[1]; } return a1[0]&lt;a2[0]; }); /* 3: 6 5: 5 6: 3 */ /* get the maxinum defense value from previous group if previous group defense value is greater the current group characteri -> this guy is the weak one in this case: [9,1] is a weak character [10,5] ->[9,1] [10,4] ->[9,1] [10,3] ->[9,1] [10,2] ->[9,1] [9,2] is a weak character [10,5] ->[9,3] [10,4] ->[9,3] */ int res = 0; stack&lt;int> s; for(int i = 0;i&lt;pro.size();i++){ while(!s.empty() &amp;&amp; s.top() &lt; pro[i][1]){ s.pop(); res++; } s.push(pro[i][1]); } return res; } };</content></entry><entry><title>[Leetcode] Binary Tree Inorder Traversal(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode94/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>traversal</tag></tags><content type="html"> LeetCode 94 - Binary Tree Inorder Traversal Given the root of a binary tree, return the inorder traversal of its nodes&rsquo; values.
example
Input: root = [1,null,2,3] Output: [1,3,2] Input: root = [] Output: [] Input: root = [1] Output: [1] How can we solve this problem? 這題很簡單,只要使用中序遍歷即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int> inorderTraversal(TreeNode* root) { vector&lt;int> res; inorder(root,res); return res; } void inorder(TreeNode* root,vector&lt;int>&amp; res){ if(!root) return; inorder(root->left,res); res.emplace_back(root->val); inorder(root->right,res); } };</content></entry><entry><title>[Leetcode] Construct String from Binary Tree(EASY)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode606/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>array</tag><tag>recursive</tag><tag>dsf</tag></tags><content type="html"> LeetCode 606 - Construct String from Binary Tree Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.
Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. example
Input: root = [1,2,3,4] Output: "1(2(4))(3)" Explanation: Originally, it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)" Input: root = [1,2,3,null,4] Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output How can we solve this problem? 這題就是要讓我們講以string的方式輸出Binary Tree。只要注意他的規則就可以解決這題。
node的children都會被()包裹住 node如果有left-child沒有right-child可以無視right-child的() node如果有right-child沒有left-child,left-child的位置必須包含一個()
根據以上這幾條輸出規則，透過postorder traversal就可以解決。 postorder traversal : traverse Left-child -> Right-child -> self node
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { string res; solution(root,res); return res; } //Solution A string constructStr(TreeNode* root){ if(!root) return ""; string cur = to_string(root->val); if(root->left) cur += '(' + tree2str(root->left) +')'; else if(root->right) cur += "()"; //for no left child but right child case if(root->right) cur += '(' + tree2str(root->right) +')'; return cur; } //Solution B void solution(TreeNode* root,string &amp;res){ if(!root) return; res += to_string(root->val); if(root->left || root->right){ res+= "("; solution(root->left,res); res+= ")"; if(root->right){ res+= "("; solution(root->right,res); res+= ")"; } } } };</content></entry><entry><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode442/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>hash map</tag></tags><content type="html"> LeetCode 442 - Find All Duplicates in an Array Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
You must write an algorithm that runs in O(n) time and uses only constant extra space. example
Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Input: nums = [1] Output: [] How can we solve this problem? 這題要我們找出所有在Array裡重複出現2次的數字。解法也很簡單, 因為題目也說了數字會出現1次或者2次,哪我們可以透過Map來計數,但當前數字已經出現過1次,也就代表當前數字是重複了2次,加入到結果即可。
Solution: class Solution { public: vector&lt;int> findDuplicates(vector&lt;int>&amp; nums) { vector&lt;int> res; // unordered_map&lt;int,int> m; int n = nums.size(); vector&lt;int> m(nums.size() + 1); // 1 - n for(int i = 0;i&lt;n;i++){ if (m[nums[i]] == 0) { m[nums[i]] ++; }else{ res.emplace_back(nums[i]); } } return res; } };</content></entry><entry><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2196/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>array</tag><tag>hash map</tag></tags><content type="html"> LeetCode 2196 - Create Binary Tree From Descriptions You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,
If isLefti == 1, then childi is the left child of parenti. If isLefti == 0, then childi is the right child of parenti. Construct the binary tree described by descriptions and return its root. The test cases will be generated such that the binary tree is valid. example
Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] Output: [50,20,80,15,17,19] Explanation: The root node is the node with value 50 since it has no parent. The resulting binary tree is shown in the diagram. Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]] Output: [1,2,null,null,3,4] Explanation: The root node is the node with value 1 since it has no parent. The resulting binary tree is shown in the diagram. How can we solve this problem? 這是給定一個2維的Array,根據Array[i]建構一棵Binary tree。主要得問題是哪一個是成為Tree root呢?要怎麼知道有哪些Child Node呢?
我們透過Map來幫助我們記錄所有Child Node,以便之後的建構 因每個Child Node都必須有一個Parent Node,也就是說在Map中能找到的Node必定是有Parent的，當找到1個Node沒有在Map中，也就代表著該Node必定是整棵Binary Tree的Head。
根據1跟2的邏輯,並使用一個Loop來建構Binary Tree即可。 Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* createBinaryTree(vector&lt;vector&lt;int>>&amp; des) { unordered_map&lt;int,TreeNode*> m; TreeNode* head = nullptr; //creating all node ->child node for(int i = 0;i&lt;des.size();i++) m[des[i][1]] = new TreeNode(des[i][1]); // all child node,except head node for(int i = 0;i&lt;des.size();i++){ //getting root node from map if(m.find(des[i][0]) == m.end()){ //getting head node TreeNode* root = new TreeNode(des[i][0]); head = root; m[des[i][0]] = root; } if(des[i][2]){ m[des[i][0]]->left = m.find(des[i][1]) == m.end() ? new TreeNode(des[i][1]) : m[des[i][1]]; }else { m[des[i][0]]->right = m.find(des[i][1]) == m.end() ? new TreeNode(des[i][1]) : m[des[i][1]];; } } return head; } };</content></entry><entry><title>[Leetcode] Binary Tree Pruning(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode814/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>recursive</tag></tags><content type="html"> LeetCode 814 - Binary Tree Pruning Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.
A subtree of a node node is node plus every node that is a descendant of node.
example
Input: root = [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer. Input: root = [1,0,1,0,0,0,1] Output: [1,null,1,null,1] How can we solve this problem? 這題是要讓我們移除所有不包含1的sub-tree。所以，我們只要透過DFS判斷一下node的left-sub tree 以及 right-sub tree 是否都不包含1: 1. 如果左右子樹都不包含1且當前node為0, 直接返回nullptr 2. 若當前節點為1就返回自身 2. 左子樹不包含1, 當前node的左子樹設成nullptr;同理右子樹不包含1,當前node 的右子數設為nullptr
Solution: class Solution { public: TreeNode* pruneTree(TreeNode* root) { if(!root) return nullptr; root->left = solution(root->left); //contain 1? root->right = solution(root->right); //contain 1? if (root->val == 0 &amp;&amp; !root->left &amp;&amp; !root->right) return nullptr; //remove itself return root; } // TreeNode* solution(TreeNode* root){ // if(!root) return nullptr; // root->left = solution(root->left); //contain 1? // root->right = solution(root->right); //contain 1? // if(root->val == 0 &amp;&amp; !root->left &amp;&amp; !root->right) return nullptr; //remove itself // return root; // } // bool solutionA(TreeNode* root){ // if(!root) return false; // if(!root->left &amp;&amp; !root->right) return root->val == 1; // bool left = solution(root->left); //contain 1? // bool right = solution(root->right); //contain 1? // if(!left) root->left = nullptr; // if(!right) root->right = nullptr; // return left || right || root->val == 1; // } };</content></entry><entry><title>[開發日記]OTT電影社群APP(一)</title><url>https://ryantokmanmokmtm.github.io/post/dev-ottapp-1/</url><categories><category>side-project</category><category>ios</category><category>dev-diary</category></categories><tags><tag>ios</tag><tag>dev</tag></tags><content type="html"> 最近這2個月都沒有更新發文章，主要是因為這2個月都在專注重構畢業專題的項目，也是只OTT電影平台。
今天這篇文章主要是跟大家分享這2個月所開發的進度和目前開發到的階段，以此作為這個項目的開發日記。
目前的成果 廢話少說，先上圖！
前端UI: 主界面 包含APP4個主要得核心功能
電影預覽與電影搜尋 - 提供了以電影類別預覽以及根據電影情況的預覽。如熱門電影,最受歡迎等&hellip; 用戶電影評論與影評分享 - 可允許用戶在觀看完電影後，寫下觀後感與他人分享 聊天與通知 - 可與朋友進行即時討論 用戶個人頁 - 包含了用戶基本訊息,發佈的文章,喜歡的電影以及收藏的電影 電影搜尋/預覽界面 功能如下：
讓用戶以文字的方式進行電影的查詢
讓用戶按著電影類別來預覽不同的電影
未實現功能如下：
刷新以及獲取更多資料 電影資訊界面 功能如下：
提供電影基本以及詳細資訊(包含電影說明,演員,成員,宣傳影片等) 為用戶提供OTT資源(如有串流平台提供資源)，並直連至該平台進行觀看 為用戶提供相似的電影 用戶可以點讚或者收藏電影 未實現功能如下：
刷新以及獲取更多資料 用戶社群與文章發佈界面 功能如下：
為用戶推送最新的電影評論文章 為用戶推送關注用戶的最新評論文章 用戶可以對文章直接評論以及點讚 用戶可以自行建立文章，發表電影感想 文章都會提供電影導向連接，可直接跳轉至電影詳細 未實現功能如下：
留言點讚 刷新以及獲取更多資料 聊天與通知界面 這部分的界面目前只使用了假數據進行UI設計，還沒設計對應的API
這部分會使用到Websocket 技術的幫助(還在研究當中QQ)
未實現功能如下：
用戶與用戶之間的對話 為用戶推送點讚,關注,留言的通知 直接搜尋好友進行通訊 刷新以及獲取更多資料 個人與他人資訊界面 功能如下：
用戶可以編輯更新個人資訊 用戶可以觀看用戶發表文章 用戶可以觀看用戶點讚電影 用戶可以觀看用戶收藏列表 用戶可以建立自定義的片單 未實現功能如下：
移除片單 移除片單中的電影 刷新以及獲取更多資料 後端API 已完成 SERVER HEALTH USER API USER GENRE API MOVIE API USER GENRE API POST LIKES API LIKED MOVIE API COMMENT LIKES API FRIEND API COMMENT API 待完成 Websocket 消息推送 Unit Test 部署至K8S以及AWS 總結 以上內容就是我7-8月之間所完成的開發事項。但APP還有很多地方沒有完成和完善！讓我們期待下一次的開發日記(*❦ω❦)
謝謝各位的耐心觀看！</content></entry><entry><title>[Leetcode] Reverse Linked List II(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode92/</url><categories><category>leetcode</category></categories><tags><tag>list</tag><tag>recursive</tag></tags><content type="html"> LeetCode 92 - Reverse Linked List II Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
example
Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Input: head = [5], left = 1, right = 1 Output: [5] How can we solve this problem? 這一題的問題非常的簡單,就是要讓我們在給定的一個list中翻轉(Reverse)[left,right]之間的Node,並返回結果。這題跟Reverse Linked List I解法類似,不同的是多了個翻轉範圍。
首先，我們要做的是在的翻轉的開始的位置。然後再透過recursive來翻轉List,最後返回的node/head再由left位置的Node的前一個Node接起來(如有)就可以了~
Solution: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { ListNode* theNodeAfter = nullptr; // ListNode* pre = nullptr; // ListNode* starting = nullptr; // ListNode* last = nullptr; // ListNode* first = nullptr; public: ListNode* reverseBetween(ListNode* head, int left, int right) { // if(head->next == nullptr) return head; // if(left == right) return head; // //getting the starting point // int n = right - left; // starting = head; // while(--left > 0){ // pre = starting; // starting = starting->next; // } // // cout &lt;&lt; starting->val &lt;&lt; endl; // reverseList(0,n,starting); //reverse list between left and right // if(pre != nullptr) pre->next = first; // else head = first; // last->next = afterBreak; if(left == 1){ //found //reverse the list return reverseList(right,head); //reverse the list and return the new head which node is the right node } head->next = reverseBetween(head->next,left - 1,right - 1); //keep finding the starting point return head; } ListNode* reverseList(int right,ListNode* head){ if(right == 1){ theNodeAfter = head->next; return head; } ListNode* last = reverseList(right-1,head->next); head->next->next=head; head->next=theNodeAfter; // return last; } // void reverseList(int i ,int n,ListNode* head){ // if(i == n){ // afterBreak = head->next; // head->next = nullptr; // first = head; // last = head; // return; // } // reverseList(i+1,n,head->next); // head->next =nullptr; // last->next = head; // last = last->next; // } };</content></entry><entry><title>[Leetcode DP] K Inverse Pairs Array(HARD)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode629/</url><categories/><tags/><content type="html"> 這題主要是學習DP思想，做個小記錄
LeetCode 629 - K Inverse Pairs Array For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &lt;= i &lt; j &lt; nums.length and nums[i] > nums[j].
Given two integersn and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7.
example:
Input: n = 3, k = 0 Output: 1 Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. Input: n = 3, k = 1 Output: 2 Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. How can we solve this problem? 題解 這題就是說給定一個數字n,從[1,n]中所能組成inverse pair為k組的有多少種組合方法。
INVERSE PAIR 的定義：
i &lt; j 且 num[i] > nums[j]
如 [2,1] 的INVERSE PAIR為1; 相反[1,2]的INVERSE PAIR 為 0
解法 這題我們需要使用到DP(動態規劃)
DP規劃:
題目很明確的問了我們在n array 中所能組成K個inverse pair有多少個，所以DP[i][j]表示的是i個數字在array中,組成j。 定義DP[n+1][k+1] 計算DP的值
假設已知dp[4][j], j:0....k 加入4呢? [x,x,x](1-3的任意組合) + 4 dp[4][j] => 加入4到array 中為j個 inverse pair</content></entry><entry><title>[Leetcode DP] Counting Bits(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes338/</url><categories><category>leetcode</category></categories><tags><tag>bit operation</tag><tag>dynamic programming</tag></tags><content type="html"> LeetCode 338 - Counting Bits Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1&rsquo;s in the binary representation of i.
example:
Input: n = 2 Output: [0,1,1] Explanation: 0 --> 0 1 --> 1 2 --> 10 Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 --> 0 1 --> 1 2 --> 10 3 --> 11 4 --> 100 5 --> 101 How can we solve this problem? 這題要我們解決的問題是給定一個數字n,回傳0 - n中每個數字包含了多少個為1的bits。例如: n=2 => 00,01,10,回傳的結果便會是[0,1,1]。
Bit Operation approach 這裡我們可以透過bit operation AND 來解決這個問題。從Truth Table中: A B Y(AND) 0 0 0 0 1 0 1 0 0 1 1 1 我們可以到只有1AND1才會是True,所有我們只需要對每一個bit與當前counter的值做AND,如果為1就bitCounter++就可以計算出每一個值的bits的數目。
因為一個Int類型為4BYTE,包含了32個bits,所以對於[0,n]中每一個數字都必須做32次的LOOP,因此Time Complexity是O(32N)。
Solution: class Solution { public: vector&lt;int> countBits(int n) { for(int i = 0;i&lt;n+1;i++){ int temp = 0; for(int j = 0;j&lt;=31;j++){ if( (1 &lt;&lt; j) &amp; i) temp++; } res[i]=temp; } return res; } }; Dynamic Programming approach 我們可以先觀察一下每個數字的Binary,以n=8為例: 從圖中我們可以看得到只有1個bit為1的數字都是2i,而我們所需要計算的[2i , 2i+1-1]之間的數字的數目即可。 但是,我們要怎麼計算呢?
首先,我們需要知道怎麼計算[2i , 2i+1-1]裡面的bits的數目,然後我們在觀察一下Binary: 如下圖: 我們可以發現[2i , 2i+1-1]都會想相隔2i-1個，也就是說我們只需要定義一個變數j作為offset 就可以移動到需要計算數字的位置( 0 &lt;= j &lt;= 2i-1 )。例如: i=2(22 = 4),2+0(2),2+1(3)。
接下來,我們可以透過DP來幫助我們計算。
定義BASE CASE:
DP[0] = 0 //number 0 不包含任何1&rsquo;s
根據目前2i,求出DP[2i+j] = DP[j],直到計算到(n)
注意: i 會根據i是否到達2i,最後進行Left-Shift(Double自己)
注意: j 作為[0,2i)的指標
例如:
DP[1] = DP[0] + 1 //比DP[0] 多一Bits
DP[2] = DP[0] + 1 //比DP[0] 多一Bits => 也可以視為在2的區間的1, DP[1] = DP[2] = 1
DP[3] = DP[1] + 1 //比DP[1] 多一Bits DP[4] = DP[0] + 1 //比DP[1] 多一Bits
Solution: class Solution { public: vector&lt;int> countBits(int n) { //Trying to use DP vector&lt;int> dp(n + 1); //from 0 to n dp[0] = 0; //base case int bits = 1; //2^0 = 1 int i = 0; while(bits &lt;= n){ //bits will be pow of 2 ->1,2,4,8,16,24 while(i&lt;bits &amp;&amp; i + bits &lt;= n){ dp[i + bits] = dp[i] + 1; i++; } i = 0; bits = bits &lt;&lt; 1; //double bits value // cout &lt;&lt; bits; } return dp; } };</content></entry><entry><title>[Leetcode] Kth Largest Element in an Array(MIDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes215/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>array</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 1268 - Search Suggestions System Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
example:
Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 How can we solve this problem? 這題要我們解決的問題是回傳在sorted array(Input Array沒有排序)中第kth大的元素。最簡單的解法是直接排序,然後回傳kth元素即可。但是, 這裡我們也可以使用Priority Queue(Heap)來幫我們解決這個問題。因為Priority Queue的特性,越大的值(MaxHeap)/越小的值(MinHeap)會越接近root,也就是說最大值(MaxHeap)/最小值(MinHeap)會在root。所以我們可以運用MinHeap來幫助的我們解決這個問題,只要Priority Queue裡面的元素多於K個我們就會把top的值移除，因更小的值會在前面,每次pop的值都會是當前最小的值,直到最後，省下來的值的root/top就會是我們的第K個最大的值，而priority queue中最後一個值便會是Input中最大的值。
Solution: class Solution { public: int findKthLargest(vector&lt;int>&amp; nums, int k) { priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; for(int i = 0;i&lt;nums.size();i++){ q.push(nums[i]); if(q.size() > k) q.pop(); } return q.top(); } };</content></entry><entry><title>[Leetcode] Furthest Building You Can Reach(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes1642/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>heap</tag><tag>priority queue</tag><tag>greedy</tag></tags><content type="html"> LeetCode 1642 - Furthest Building You Can Reach You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.
You start your journey from building 0 and move to the next building by possibly using bricks or ladders.
While moving from building i to building i+1 (0-indexed),
If the current building&rsquo;s height is greater than or equal to the next building&rsquo;s height, you do not need a ladder or bricks. If the current building&rsquo;s height is less than the next building&rsquo;s height, you can either use one ladder or (h[i+1] - h[i]) bricks. Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally. example:
Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 Output: 4 Explanation: Starting at building 0, you can follow these steps: - Go to building 1 without using ladders nor bricks since 4 >= 2. - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7. - Go to building 3 without using ladders nor bricks since 7 >= 6. - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9. It is impossible to go beyond building 4 because you do not have any more bricks or ladders. Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 Output: 7 Input: heights = [14,3,19,3], bricks = 17, ladders = 0 Output: 3 How can we solve this problem? 這個要我們解決的問題是給定一定數量的磚塊brick和梯子ladder,問我們最遠能到達哪一棟建築(array index)。 我們主要注意的是題目給定的幾個限制條件。
如果i+1的建築比i建築矮,我們可以不用任何磚塊(bricks)或者梯子ladders 如果i+1的建築比i建築搞，我們必須使用一個梯子ladders或者(h[i+1] - h[i])個磚塊(bricks) 從這裡我們可以看到梯子ladders無論建築有多高，我們都可以到達。相反磚塊(bricks)則需要數量。所以，我們要解決這個問題會優先考慮使用梯子ladders。如果梯子ladders 使用完畢，我們可以將前面2個建築之間高度最小的梯子ladders回收,使用磚塊(bricks)取代。如果磚塊(bricks)也不夠或者超出提供的數量，就代表我們最遠可以到達的建築為i-1(因為i建築,我們沒有足夠的磚塊brick和梯子ladder)。如果梯子的數量跟建築的數量一樣多,直接回傳最後一棟(n-1)即可。
Solution: class Solution { public: int furthestBuilding(vector&lt;int>&amp; h, int bricks, int ladders) { //Using all ladders first //if there is no other ladders,we try to use bricks(mininum one) instead of a ladder //if there have enough ladders //just return n-1(index) priority_queue&lt;int, vector&lt;int>, greater&lt;int>> laddersUsed; //min heap //O(n*log l(min Head insert)) for(int i = 1;i&lt;h.size();i++){ //use all ladders int climbingHeigh = h[i] - h[i-1]; if(climbingHeigh &lt;= 0) continue; //we can climb it laddersUsed.push(climbingHeigh); //our ladder is enough? if(laddersUsed.size() &lt;= ladders) continue; //our ladder is not enough //try to use bricks to instead if our bricks is not enough too,return previous index(neither bricks nor ladders can reach ith building) bricks -= laddersUsed.top(); laddersUsed.pop(); if(bricks &lt; 0) return i-1; } return h.size() - 1; } //Time Exceed // int dfs(vector&lt;int>&amp; h,int i,int bricks, int ladders){ // if(bricks &lt; 0 || ladders &lt; 0) return i-1; // // if(bricks == 0 &amp;&amp; ladders == 0) return i; // if(i == h.size()-1) return i; // int res = 0; // if(h[i] > h[i+1]) { // res = solution(h,i+1,bricks,ladders); // }else{ // //either bricks ladders // int bricksCase = solution(h,i+1,bricks - (h[i+1]-h[i]),ladders); // int laddersCase = solution(h,i+1,bricks,ladders-1); // res = max(bricksCase,laddersCase); // } // return res; // } };</content></entry><entry><title>TrieTree(前綴樹/字典樹)</title><url>https://ryantokmanmokmtm.github.io/notes/trietree/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>data structure</tag></tags><content type="html"> Introduction 什麼是TrieTree? Trie稱為前綴樹或字典樹,是有序樹的一種,Node的key通常為String類型。Trie Tree與Binary-Searching Tree不同的點是,Trie Tree的Key並不會直接保存在Node中,而是它在Tree中的位置所決定的。一個Node中的所有的childrens都有相同的Prefix(前綴)。假設有個Node的key 為T,它的children將會是Time, Tim, Test等,因為他們都會相同的Prefix(前綴)T。
Trie Tree 的應用 字符前綴匹配 - 網頁URL,搜尋等 搜索關鍵字時,返回前綴最相似的可能結果 Trie Tree 結構圖 Trie Tree Template class TrieNode{ public: TrieNode(){ //suppose we are considering a string consist with a-z //at most 26 childrens for a node child = vector&lt;TrieNode*>(26); } vector&lt;TrieNode*> child; // bool isWord = false; //indicate current word is a word void AddNode(string&amp; str){ TrieNode*root = this; for(int i = 0;i&lt;str.length();i++){ //adding a node that key is str[i] if(!root->child[str[i] - 'a']) root->child[str[i] - 'a'] = new TrieNode(); root = root->child[str[i] - 'a']; } } //Other function define here... //Find a word etc... }; 參考資料 https://zh.wikipedia.org/wiki/Trie</content></entry><entry><title>[Leetcode] Short Encoding of Words(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode802/</url><categories/><tags><tag>string</tag><tag>array</tag><tag>TrieTree</tag></tags><content type="html"> 820 - Short Encoding of Words A valid encoding of an array of words is any reference string s and array of indices indices such that:
words.length == indices.length The reference string s ends with the '#' character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i]. Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.
example:
Input: words = ["time", "me", "bell"] Output: 10 Explanation: A valid encoding would be s = "time#bell#" and indices = [0, 2, 5]. words[0] = "time", the substring of s starting from indices[0] = 0 to the next '#' is underlined in "time#bell#" words[1] = "me", the substring of s starting from indices[1] = 2 to the next '#' is underlined in "time#bell#" words[2] = "bell", the substring of s starting from indices[2] = 5 to the next '#' is underlined in "time#bell#" Input: words = ["t"] Output: 2 Explanation: A valid encoding would be s = "t#" and indices = [0]. How can we solve this problem? 這題看上去好像很難理解它要我們解決什麼問題。但是我們可以從例子中可以觀察到他就只是單純用#來分隔每個子串。例如:time,me,bell會以這樣的方式進行Encoding,time#me#bell。但是問題要找出我們最短的是Encoding 長度為多少，也就是有重疊的Word我們無需額外加入到子串中，就剛才的例子我們可以看得出來time和me都包含了me。所以,我們Encoding會從time#me#bell縮短為time#bell#
哪我們要怎麼知道是否不用額外加入到字串中呢? 題目中有給出幾個條件(不符合條件需插入至String結尾):
對於任何words[j],從string中的indices[i] 到#前,與words[j]相同,也就是與words[j]是string的後綴(suffix)。例如：time和me, me是time的後綴。 words[i]的長度等於indices的長度。也就是words[i]-indices會等於words[j]。例如words[i]為4,indices為1,words[j]為2。4-1 != 2，也就是代表words[j]不是words[i]的後綴。 Solution: 我們可以透過Tire Tree來解決這個問題。因為我們要知道words有沒有相同後綴(suffix),所以建構Tree的時候,需要放過來插入。直到 leaf(葉子) 就會知道當前有相同後綴(suffix)的長度為多少，最後加總加一起，就是我們要的結果。
class TrieNode{ public: TrieNode(){ node = vector&lt;TrieNode*>(26); } vector&lt;TrieNode*> node; }; int AddWord(TrieNode* root,string&amp; w){ int res = -1; //if some words have the same suffix,it will return 0 ,-1+'#' = 0 for(auto i = w.rbegin();i&lt;w.rend();i++){ if(!root->node[*i - 'a']){ root->node[*i - 'a'] = new TrieNode(); res = w.length(); } root = root->node[*i - 'a']; } return res + 1; //extra } class Solution { public: int minimumLengthEncoding(vector&lt;string>&amp; words) { int res = 0; sort(words.begin(),words.end(),[&amp;](string&amp; a, string&amp; b){ return a.length() > b.length(); }); TrieNode* root = new TrieNode(); for(int i = 0;i&lt;words.size();i++) res += AddWord(root,words[i]); // findShortWords(0,root,res); return res; } }; 另外一種解法是我們只需要知道哪些words[j]跟words[i]有共同的suffix且符合條件。
過濾掉重複的words,並生成unique的list 大到小排序(根據字串的長度),因為我們要知道words[i]是否包含了words[j]。如果words[i].length() &lt; words[j].length()就一定不會包含。 計算長度: 看看words[j]有沒有符合條件 words[j]可能在words[i]不只出現過一次。所以我們需要找出所有可能。直到找出符合條件的或者沒有找到符合條件的。例如:timt(i),t(j), j在i出現了2次,而且有一個是符號條件的,也就是indices為3的t。 class Solution { public: int minimumLengthEncoding(vector&lt;string>&amp; words){ set&lt;string> unique(words.begin(),words.end()); //O(n) vector&lt;string> list; for(auto word : unique) list.push_back(word); //O(n) //sorting by word size //O n log n sort(list.begin(),list.end(),[&amp;](string&amp; a,string&amp; b){ return a.length() > b.length(); }); vector&lt;int> v(list.size(),0); int res = 0; //O n*n-1 = n^2 for(int i = 0;i&lt;list.size();i++){ if(v[i]) continue; for(int j = i+1;j&lt;list.size();j++){ int index = list[i].find(list[j]); if(index == -1) continue; //not found,go to next one if(index != -1 &amp;&amp; list[i].length() == index + list[j].length()){ v[j] = 1; }else{ while((index = list[i].find(list[j],index)) != -1){ if(list[i].length() == index + list[j].length()) { v[j] = 1; break; } index ++; } } } res += list[i].length() + 1; //adding extra # } } };</content></entry><entry><title>[雕刻日常]數位雕刻基礎-人頭骨雕刻目前最好的一次!</title><url>https://ryantokmanmokmtm.github.io/post/sculpturetrain1/</url><categories><category>3D modeling</category></categories><tags><tag>design</tag><tag>zbrush</tag><tag>character modeling</tag></tags><content type="html"> 直接上圖!</content></entry><entry><title>[Leetcode] Longest Palindromic Substring(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode5/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>dynamic programming</tag></tags><content type="html"> LeetCode 5 - Longest Palindromic Substring Given a string s, return the longest palindromic substring in s.
example
Input: s = "babad" Output: "bab" Explanation: "aba" is also a valid answer. Input: s = "cbbd" Output: "bb" How can we solve this problem? 要解決這題，我們必須要先知道什麼是Palindrome。可以參考這篇文章Palindromic string迴文。而這題要我們找出在給定string中,找到最長的Palindrome。我們可以透過以每個單一字元(index i)以及倆個字元(index i,index i+1)為中心點，並擴展left,right找出他們的局部的最長Palindrome為多少，然後根據這個長度計算starting point i以及記錄長度len,最後以starting point和len得出字串中str[startingPoint,len]為解。
Solution: class Solution { public: string longestPalindrome(string s) { /* Using an easy solution "babad" finding all posible palindrome string starting at index i(mid point) odd case: i-1 i i+1 ? Palindrome i-2 i-1 i i+1 i+2 ?Palindrome what about even case.We're simply starting at index i and i+1 i-1 [i,i+1] i+2 ?Palindrome */ int n = s.length(); int len = 0; int startPoint = 0; //O(n * n(finding Palindrome)) for(int i = 0;i&lt;n;i++){ int cur = max(getLen(s,i,i,n),getLen(s,i,i+1,n)); // which one is longest? odd or even if(cur > len){ //update our len and starting point len = cur; startPoint = i - (len-1)/2; //(len-1) for even case //suppose the len is 3 and the index is 1 ,then the starting point will be 1 - (3-1)/2 => 0-> len str[0...2] //suppose the len is 4 and the index is 1 ,then the starting point will be 1 - (4-1)/2 => 0-> len str[0...2] } } return s.substr(startPoint,len); } //str[i..j] is our middle point of Palindrome int getLen(string&amp;str,int i,int j,int n){ //left(i) right(j) while(i>=0 &amp;&amp; j&lt;n &amp;&amp; str[i] == str[j]){ i--; j++; } //string at i+1 and getting //|y|x2|x1|x|x1|x2|y| => the length of this string is l - r + 1 -(out of bounds of both i and j => 2) => l-r-1 return j-i-1; //string at i+1(is decreased from the loop),total } };</content></entry><entry><title>Palindromic String(迴文字串)</title><url>https://ryantokmanmokmtm.github.io/notes/palindromicstring/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>string</tag><tag>dynamic programming</tag></tags><content type="html"> Introduction 什麼是Palindromic String 迴文字串 所謂的Palindromic String(迴文字串) 就是以一個字元為中間，而它的左邊以及右邊的組成字元相同。
例子:
abcdcba 以d為中心的左跟右的字元一樣。
cdc左跟右都為c
bcdcb 左跟右都為b
abcdcba 左跟右都為a
要怎麼知道String是否為什麼是palindrome(迴文) 要知道String是否palindrome，我們先得知道Palindromic的規則:
單一的字元都是Palindromic，例如: a,b,g&hellip; 某字元的左右字元相同,例如: xax,xbx,xgx&hellip; 某字元自己跟右邊或者左邊相同也是一個也使一個palindrome。例如aa,bb 如果某子串為palindrome,而左跟右字元相同，它也會是一個palindrome。例如palindromeaba,它的左右2邊都為字元x,xabax也使一個palindrome; 相反，左跟右字元不相同,則只有子字串為palindrome。 判斷是否palindrome string 我可以從子串的中心點(middle point)開始往外擴展i,j,如果i跟j位置的為相同字元,則繼續往外擴。如果過程中有i,j位置的字元不相同,我們就可以知道它不是一個palindrome。
在尋找Palindrome的時候，我們必要要考慮到odd和evencase。
odd case : 會以odd基數的方式擴展。 例如: a -> bab -> cbabc&hellip; even case: 會以even偶數的方式擴展 例如: aa -> baab -> cbaabc&hellip; 什麼時候會出現這種情況呢? 例如這個例子:baab。如果只使考慮到odd case,他會被認為不是一個Palindrome。baa,aab&hellip;都不是合法的Palindrom。所以,我們必須考慮到even case。aa,baab是合法的Palindrom。
Palindrome Template //O(n) bool isPalindrome(string str,int i,int j){ while(i>=0 &amp;&amp; j &lt; str.length()){ if(str[i] != str[j]) return false; i--; j++; } return true; } //中心點為Odd(i) isPalindrome(str,i,i); //中心點為even(i,i+1) isPalindrome(str,i,i+1);</content></entry><entry><title>Longest Common SubString(最長公共子序列)</title><url>https://ryantokmanmokmtm.github.io/notes/lcm/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>dynamic programming</tag></tags><content type="html"> Introduction 什麼是最長公共子序列? 給定2個字串string A和string B,2個字串中所共同擁有的最長的子字串。
例如:
StringA:leetcodeStringB:ecbod他們的最長公共子序列便是`ecod`解釋:StringA包含了__e_cod_=>ecodStringB包含了ec_od=>ecod要怎麼找到最長公共子序列LCM呢? 我們需要定義一個數組用於保存當前情況下的最優解,也就是使用DP的方式。我們需要以每個字符最為考量,並一一匹配，最後得出整體最優解。 LCM Code Template int longestCommonSubStr(string &amp;s1, string &amp;s2){ int n = s1.length(); int m = s2.length(); vector&lt;vector&lt;int>> dp(n+1,vector&lt;int>(m+1,0)); for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=m;j++){ if(s1[i-1] == s2[j-1]) dp[i][j] = 1 + dp[i-1][j-1]; //the LCM of previous size + current matched else dp[i][j] = max(dp[i-1][j],dp[i][j-1]); //strA[0..i-2] str[0...j-1] or strA[0..i-1] str[0...j-2] check which one have the longest LCM } } return dp[n][m]; } 參考資料 经典动态规划：最长公共子序列</content></entry><entry><title>MetaHuman虛擬數字人初探</title><url>https://ryantokmanmokmtm.github.io/post/Mataverse-MataHuman/</url><categories><category>mateverse</category><category>modeling</category></categories><tags><tag>matehuman</tag></tags><content type="html"> 因為元宇宙(Metaverse)這個概念火熱,所有我就趁著這個機會了解一下在元宇宙領域中本人覺得比較有趣的東西。也就是這篇文章所要分享給各位的MetaHuman(虛擬數字人/虛擬數位人)
什麼是MetaHuman(虛擬數字人/虛擬數位人)呢? 所謂的MetaHuman(虛擬數字人)是具有數字化形象的虛擬人物，並且具備特定的相貌、性格和性別等人物特征、具備語音，面部表情和肢體動作表達的能力以及擁有人類的思想會具有外界環境與人交流的互動能力。 這裡只是簡略的介紹一下。如果各位對虛擬數字人技術或者發展剛興趣的,可以參考這份虛擬數字人白皮書
簡單數字人實作 注:本實作之數字人透過輸入自定義音頻生成，並無溝通等能力
使用工具:
Reallusion Character Creator Reallusion IClone 實作步驟也十分的簡單:
我們將透過Reallusion Character Creator製作我們數字人的外觀,然後再將數字人傳入Reallusion IClone做動畫,也就是透過IClone的音頻生成數字人動畫的功能製作動畫。
Step 1:
進入Reallusion Character Creator製作角色(以博主自定義的角色為例)，如下圖: Step 2:
將剛才在CC(Character Creator) 製作的角色匯入到IClone中,如下圖:
Character Creator中: File->Export->Send to IClone 匯入音頻文件
Modify->Facial->Create Script->Audio File 預覽動畫結果，並渲染動畫 Demo展示 燈光一展示:
燈光二展示
結論 有沒有發現很簡單又很好玩呢!我們透過Reallusion工具讓我們能在很短的時間內就可以完成一個屬於自己的MetaHuman。除此之外Reallusion還提供很多很強大的功能，例如:圖片生成3D角色模型,手機臉部動作捕捉,與Unreal Engine 5的MetaHuman工具連動等等，有機會的話再跟大家分享。 最後給大家分享一張虛擬網美照>&lt; 參考資料:
Reallusion</content></entry><entry><title>[Leetcode] Combination Sum III(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode216/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag><tag>recursion</tag><tag>back-tracking</tag></tags><content type="html"> LeetCode 216 - Combination Sum III Find all valid combinations of k numbers that sum up to n such that the following conditions are true:
Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. example
Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination. How can we solve this problem? 這題主要關注的點是數字範圍為[1,9]，每個結果中，數字只能使用一次，而且數字必須是順序排列。例如:2,3,4,1,2,5。解決這題我們可以用back-traking大法。只要我們當前的Sum大於n我們就直接退回back track回上一步,因為數值只會越來越大，並不是我們想要的。如果Ans我們所需的k個就直接判斷是否等於n，如果是就直接加入到我們的result即可。
Solution: class Solution { vector&lt;vector&lt;int>> res; vector&lt;int> tmp; public: vector&lt;vector&lt;int>> combinationSum3(int k, int n) { solution(n,k,0,1); return res; } void solution(int n,int k,int sum,int start){ if(k==0){ if(sum == n) res.push_back(tmp); return; } if(sum > n) return; for(int i = start;i&lt;=9;i++){ tmp.push_back(i); solution(n,k-1,sum + i,i+1); tmp.pop_back(); } } };</content></entry><entry><title>[Leetcode] Letter Combinations of a Phone Number(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode17/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>recursion</tag><tag>back-tracking</tag></tags><content type="html"> LeetCode 17 - Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
example
Input: digits = "23" Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"] Input: digits = "" Output: [] Input: digits = "2" Output: ["a","b","c"] How can we solve this problem? 這題是要我們拿到Input的數字所能組合出所有字串。解法也很簡單，我們可以透過Map記錄每個數字代表來那些字符，然後再透過Back-tracking技巧來幫助我們組合字串。你有可能會問什麼是Back-tracking。簡單來說就是一個Recursive Function,但他會迴避一些不正常的數值。比如:&ldquo;abc&rdquo;,而"abc"可能不是我們要的。因此退回上一步的"ab",並嘗試其他數值/結果。
Solution: class Solution { unordered_map&lt;char,string> temp = { {'2',"abc"}, {'3',"def"}, {'4',"ghi"}, {'5',"jkl"}, {'6',"mno"}, {'7',"pqrs"}, {'8',"tuv"}, {'9',"wxyz"} }; public: vector&lt;string> letterCombinations(string digits) { vector&lt;string> res; if(digits.length() == 0) return res; solution(res,0,digits,""); return res; } void solution(vector&lt;string>&amp; res,int index,string &amp;digits,string phone){ if(index == digits.length()){ res.push_back(phone); return; } auto numList = temp[digits[index]]; for(int i = 0;i&lt;numList.length();i++){ phone += numList[i]; solution(res,index+1,digits,phone); phone.pop_back(); } } };</content></entry><entry><title>[Leetcode] Flatten Nested List Iterator(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode341/</url><categories><category>leetcode</category></categories><tags><tag>design</tag><tag>recursion</tag><tag>iteration</tag></tags><content type="html"> LeetCode 341 - Flatten Nested List Iterator You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.
Implement the NestedIterator class:
NestedIterator(List&lt;NestedInteger> nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. Your code will be tested with the following pseudocode:
initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res If res matches the expected flattened list, then your code will be judged as correct.
example
Input: nestedList = [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Input: nestedList = [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. How can we solve this problem? 這一題就是一題設計的題目,可以想象成是一個FileSystem，裡面可能存的是文件(Integer)或者是文件夾(List)。因此，我們可以發現他就是一顆Tree。所以，我們只要從左到右拿到Integer,並順序輸出即可。
如圖:
Solution(Recursion): 我們可以在initial透過Recursive Function來遍歷Input,並把所有Integer先Push到Array/List裡面。然後在定義一個pointer用於存取Next的值即可。
/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger> &amp;getList() const; * }; */ //calling hasNext -> next class NestedIterator { vector&lt;int> ans; // vector&lt;NestedInteger> list; int cur = 0; void getValue(vector&lt;NestedInteger>&amp; data){ for(int i = 0;i&lt;data.size();i++){ if(data[i].isInteger()) ans.push_back(data[i].getInteger()); else getValue(data[i].getList()); } } public: NestedIterator(vector&lt;NestedInteger> &amp;nestedList) { getValue(nestedList); } int next() { return ans[cur++]; } bool hasNext() { return cur &lt; ans.size() ? true:false; } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Solution(Iteration): 這個解法是透過在Calling hasNext()的時候將當前container的最前面的那個element展開來(如果是一個list)，並把展開來的element放到container最前面，從而確保來container的最前面的element是Integer,呼叫next()時，都會return Int。
/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger> &amp;getList() const; * }; */ //calling hasNext -> next class NestedIterator { // vector&lt;int> ans; vector&lt;NestedInteger> list; public: NestedIterator(vector&lt;NestedInteger> &amp;nestedList) { list = nestedList; } int next() { //here we always return the first one // cout &lt;&lt; storage.size() &lt;&lt; endl; int res = storage.begin()->getInteger(); // cout &lt;&lt; res &lt;&lt;endl; storage.erase(storage.begin()); return res; } bool hasNext() { //we check our storage here //if the first elements is not a integer ,we try to get the interget from the list and append to our storage while(!storage.empty() &amp;&amp; !storage.front().isInteger()){ //get the first one from the storage vector&lt;NestedInteger> data = storage.front().getList(); storage.erase(storage.begin()); //append to the front of the storage that retrieved from the list for(int i = data.size()-1;i>=0;i--) storage.insert(storage.begin(),data[i]); } // if(storage.front().isInteger()) cout &lt;&lt; storage.front().getInteger(); return !storage.empty(); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */</content></entry><entry><title>[Leetcode] 132 Pattern(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode456/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 456 - 132 Pattern Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].
Return true if there is a 132 pattern in nums, otherwise, return false. example
Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Input: nums = [3,1,4,2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2]. Input: nums = [-1,3,2,0] Output: true Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. How can we solve this problem? 這題就是要我們找出List有沒有符合132 Pattern。那怎麼才算是132 Pattern呢。從題目定義可以看出在List中任意的nums[i] &lt; nums[k] &lt; nums[j]，也就是說nums[k]為最大,nums[j]為第二大,nums[i]`為第三大。
那要怎麼找到是不是符合呢?
假設我們現在的位置是nums[j],我們是否能在找到[0 - j)這個範圍內找到nums[k]以及nums[i]且符合nums[i] &lt; nums[k] &lt; nums[j]就好了呢?
哪我們應該要怎麼做呢?
因為nums[i]都是會是132 pattern當中最小的的值。因此每當iterate時，記錄當前值的左邊的最小的值(當前這個值可能會是k，最小值可能會是i)。當我要判斷一個值是不是j時，我們只需要拿到比他大的值，然後再透過記錄在此值得最小值，跟j做比較是不是符合nums[i] &lt; nums[j]這個條件，我們就可知道當前的j是不是我們要找的。
解題步驟如下:
我們要記錄每個值的左手邊的最小值，用於判斷是不是nums[i] 我們要用定義一個pointer暫存目前的最小值 當我們要判斷當前的值是否會構成132 Pattern,就從先前的記錄中獲取比較當前值還要大的記錄，並且透過記錄中的最小值判斷是不是也小於j,從而得出結論。 Solution: class Solution { public: bool find132pattern(vector&lt;int>&amp; nums) { //i &lt; k &lt; j //if there exist one return true return solution(nums); } // bool burstForce(vector&lt;int>&amp; nums){ // int n = nums.size(); // for(int i = 0;i&lt;n;i++){ // for(int j = i+1;j&lt;n;j++){ // for(int k = j + 1;k&lt;n;k++) // if(nums[i] &lt; nums[j] &amp;&amp; nums[j] > nums[k] &amp;&amp; nums[i] &lt; nums[k]) return true; // } // } // return false; // } bool solution(vector&lt;int>&amp; nums){ //current k int curMin = nums[0]; stack&lt;pair&lt;int,int>> s; //&lt;num,minBeforeNum> for(int i = 1;i&lt;nums.size();i++){ //nums[i] repersent the j //and top will be our k and check min before k while(!s.empty() &amp;&amp; nums[i] >= s.top().first){ //finding the k before j s.pop(); } //checking the top elements of the stack if(!s.empty() &amp;&amp; s.top().second &lt; nums[i]) return true; //checking //push to stack s.push({nums[i],curMin}); curMin = min(nums[i],curMin); } return false; } };</content></entry><entry><title>[LeetCode] Remove All Adjacent Duplicates in String II(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1209/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>stack</tag></tags><content type="html"> LeetCode 1209 - Remove All Adjacent Duplicates in String II You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.
example
Input: s = "abcd", k = 2 Output: "abcd" Explanation: There's nothing to delete. Input: s = "deeedbbcccbdaa", k = 3 Output: "aa" Explanation: First delete "eee" and "ccc", get "ddbbbdaa" Then delete "bbb", get "dddaa" Finally delete "ddd", get "aa" Input: s = "pbbcggttciiippooaais", k = 2 Output: "ps" How can we solve this problem? 這題就是要我們刪除掉在String裡面某些相鄰且相同並重複了k次的Characters。例如: aeee,k=3，輸出a。如果我們要解決這個問題就要知道目前string裡面有哪些subString符合條件，但是這裡要注意一個問題就是有些Substring被移除後，會使前(刪除Str)後2個substring符合條件。例如:aeeeaa,但我們刪除eee後,aaa也會符合條件，因此會被移除。
哪我們要怎麼知道哪些characters符合條件呢?
這裡我們可以使用Stack/Array來幫組我們解題。為什麼是用Stack? 因為我們只需要關注當前str[i]是否與前一個str[i-1]一致,如果是一致的我們會加入到Stack.top的Counter裡面。只要Counter的值為k我們就知道是符合條件的String，移除即可。最後，把Stack/Array裡面剩餘的元素串接就可以得出最後答案(注:Stack元素串接需要Reverse結果)。
Solution: class Solution { public: string removeDuplicates(string s, int k) { if(s.length() &lt; k) return s; string res; vector&lt;pair&lt;char,int>> counter; //O(n) for(auto str : s){ //how many same character if(counter.empty() || counter.back().first != str) counter.push_back({str,1}); else{ counter.back().second++; } if(counter.back().second == k) counter.pop_back(); } // for(auto e:vc) cout &lt;&lt; e; //O(i*k &lt;= n ) => O(n); for(int i = 0;i&lt;counter.size();i++){ for(int j = 0;j&lt;counter[i].second;j++) res+=counter[i].first; } cout &lt;&lt; res &lt;&lt;endl; return res; } };</content></entry><entry><title>[Leetcode] Implement Stack using Queues(EASY)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode225/</url><categories><category>leetcode</category></categories><tags><tag>stack</tag><tag>queue</tag><tag>design</tag></tags><content type="html"> LeetCode 225 - Implement Stack using Queues Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes:
You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&rsquo;s standard operations. example
Input ["MyStack", "push", "push", "top", "pop", "empty"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False How can we solve this problem? 這題就是要我們用Queue來模擬Stack。做這題之前我們要先知道Queue和Stack的差異。
Queue是First In First Out, 也就是先進去的element會先被拿出來 Stack是First In Last Out, 也就是先進去的element最後才會被拿出來 push(int x):
如果要用Queue來模擬Stack就要注意在Queue中的最後一個元素會是Stack的第一個元素。所以，這題我們可以用比較簡單粗暴的方式來解決。因為我們已經知道後進(Last In)Stack的值會是第一個元素。因此,我們可以直接用一個variable保存最後插入進Queue的element即可。
pop()
如果我們要移除element，就必須要將Queue的最後一個元素搬到最前面，同時因為最前面的元素會被移除，所以我們用於保存最後插入進Queue的variable所記錄的值也必須被改變，變成Queue的倒數第二個element。因此我們要先將Queue中最後的2個element搬到最前面，第一個便是我們stack的top,而第二個是我們要pop的element。最後，我們記錄完top的值後，插入到Queue的尾巴，並返回要Queue的front即可。
clear(): 只需將空的Queue取代成當前不是空的Queue即可。
empty():
只需檢查Queue是否為empty()即可。
Solution: class MyStack { public: queue&lt;int> q; int t; // queue&lt;int> q2; MyStack() { } //O(N) void push(int x) { // q2.push(x); // while(!q.empty()){ // q2.push(q.front());q.pop(); // } // q = q2; // clear(q2); q.push(x); t = x; } //O(1) int pop() { // if(empty()) return -1; // int value = q.front();q.pop(); //get the last 2 elements int size = q.size(); while(size-- > 2) { q.push(q.front()); q.pop(); } //getting the 2th top value in stack t = q.front(); q.push(q.front()); //push it at the back of the queue q.pop(); //getting the 1th top value in stack int popVal = q.front(); q.pop(); return popVal; } void clear(queue&lt;int>&amp; q){ queue&lt;int> empty; swap(empty, q); } int top() { // if(empty()) return -1; // return q.front(); return t; } bool empty() { return q.empty() ? true : false; } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */</content></entry><entry><title>[Leetcode] Max Number of K-Sum Pairs(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1679/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>map</tag><tag>two-pointer</tag></tags><content type="html"> LeetCode 1679 - Max Number of K-Sum Pairs You are given an integer array nums and an integer k.
In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.
Return the maximum number of operations you can perform on the array.
example
Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. Input: nums = [3,1,3,4,3], k = 6 Output: 1 Explanation: Starting with nums = [3,1,3,4,3]: - Remove the first two 3's, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation. How can we solve this problem? 這題就是要移除Array中2個elements加起來等於k的操作有幾次。
第一個解法，我們可以使用sorting以及two-pointer approach來解決。先將array排序，然後設置i為0,j為n-1,直接使用iteration找出nums[i]+nums[j] = k的數，然後answer+1即可。
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { //sort sort(nums.begin(),nums.end()); //O n log n int ans = 0; int i = 0,j = nums.size()-1; while(i &lt; j){ if(nums[i] + nums[j] == k) { ans++; i++; j--; }else if(nums[i] + nums[j] > k)j--; else i++; } return ans; } }; 第二種解法是透過map來記錄。首先，會透過x = k - nums[i]得出一個數，如果這個數不存在map裡面或者map[x] &lt;= 0就代表沒有，就把目前的nums[i]加入到map。如果存在，就將answer+1並且從map中移除map[x]的數量(map[x]--)。
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { unordered_map&lt;int,int> temp; int ans = 0; for(int i = 0;i&lt;nums.size();i++){ int sum = k - nums[i]; if(temp[sum] > 0){ //exist this value; //for example:[3,1,3,4,3] //3,1,3(we are here) 6-3=3 and 3:1 and we found a pair(3,3)=6 ,and remove the existing value ans++; temp[sum]--; }else temp[nums[i]]++; } return ans; } };</content></entry><entry><title>[Leetcode] Shortest Unsorted Continuous Subarray(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode581/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 581 - Shortest Unsorted Continuous Subarray Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.
Return the shortest such subarray and output its length.
example:
Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Input: nums = [1,2,3,4] Output: 0 Input: nums = [1] Output: 0 How can we solve this problem? 這題比較難懂一點點，這裡先做一下題目的解釋。這題主要先問的是在輸入的Array裡面找到一個最小需要排序的Sub-array。
從例子[2,6,4,8,10,9,15]中，我們可以很明顯的看到[6,4,8,10,9]並不是ascending order(順序),而這個sub-array要進行排序的話，所有elements都需要進行排序，所以，他的length是5。
再舉另外一個例子[1,3,2,3,3]，這個Array我們可以看到[3,2,3,3]並不是順序的，但是在這個sub-array裡面,只有[3,2]需要排序,所以，他的結果會是2。
那我們應該要怎麼解呢? 一個最簡單的解法是定義一個額外的array，而這個array的element跟原來的一樣，但是已經被排序過的。因此，只要比較原本的array和排序過的array有幾個element的位置不一樣就知道結果了。但Time Complexity是是O(n log n) - 排序的時間，而Space Complexity則是O(n)
Solution: vector&lt;int> temp = nums; sort(temp.begin(),temp.end()); //n log n int start = nums.size() - 1; int end = 0; //finding the starting point which is not as same as the sorted array //finding the ending print which is not as same as the sorted array for(int i =0;i&lt;nums.size();i++){ if(nums[i] != temp[i]){ start = min(i,start); // end = max(end,i); } } return end - start >= 0 ? end - start + 1 : 0; 另外一種解法是通過Two-pointer approach來解。我們先要找到左手邊有問題的地方的最小值(1,4,7,5,3,6 最小值為3)以及右手邊有問題的地方的最大值(1,4,7,5,3,6 最大值為7)。然後,要找出左手邊第一個被影響的index(nums[index] > 最小值)。同理也要找出右手邊第一個被影響的最index(nums[index] &lt; 最大值)。這樣我們就能找出有問題的區間[left,right]，在根據left,right得出最終結果。 Solution: 解法二:
int start = INT_MAX; int end = INT_MIN; for(int i = 1;i&lt;nums.size();i++){ if(nums[i] &lt; nums[i-1]) start = min(nums[i],start); } for(int i = nums.size() - 2;i>=0;i--){ if(nums[i] > nums[i + 1]) end = max(nums[i],end); } int left,right; //scanning the value from the left to the right that is less than maximum value for(left = 0;left&lt;nums.size();left++){ //finding the descending point if(start &lt; nums[left]) break; } //scanning the value from the right to the left that is less than minimum value for(right = nums.size() - 1;right >= 0;right--){ if(end > nums[right]) break; } //we need to find out the right-most point return right - left >= 0 ? right - left + 1 : 0;</content></entry><entry><title>[Leetcode] Sort Array By Parity(EASY)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode905/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 905 - Sort Array By Parity Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
Return any array that satisfies this condition.
example:
Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Input: nums = [0] Output: [0] How can we solve this problem? 這個問題很簡單，就是把偶數移動到Array的前面，基數移動到後面。我們這裡可以使用Two-pointer approach, i為尋找前面的基數，而j 為尋找後面的偶數，只要nums[i]為基數,nums[j]為偶數就進行交換。
=j`就結束 -- Solution: class Solution { public: vector&lt;int> sortArrayByParity(vector&lt;int>&amp; nums) { int i = 0; int j = nums.size() - 1; //O(n) while(i &lt; j){ //i is even skip //j is odd skip //i is odd and j is even swap if(nums[i] % 2 == 0) i++; else if(nums[j] % 2 == 1) j--; else swap(nums[i++],nums[j--]); } return nums; } };</content></entry><entry><title>[Leetcode] Backspace String Compare(EASY)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode844/</url><categories><category>leetcode</category></categories><tags><tag>string</tag></tags><content type="html"> LeetCode 844 - Backspace String Compare Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
example:
Input: s = "ab#c", t = "ad#c" Output: true Explanation: Both s and t become "ac". Input: s = "ab##", t = "c#d#" Output: true Explanation: Both s and t become "". Input: s = "a#c", t = "b" Output: false Explanation: s becomes "c" while t becomes "b". How can we solve this problem? 這題主要要什麼比較2個String移除於#前的字符後是否為相同的String，就相當於Backspace(#) 字符。 這題有2種解法:
要使用到額外的空間，保存2個移除字符後的String再進行比較。 透過pointerr的方式來決定哪個位置是要被移除的，然後將之後的字符將其進行取代，最後在比較倆者在r長度內的字符是否相同，即可。可見下圖為例: Solution: class Solution { public: bool backspaceCompare(string s, string t) { int slen = s.length(); int tlen = t.length(); int i = 0; int rpSStrIndex = 0; while(i &lt; slen ){ if(s[i] == '#') { if(rpSStrIndex > 0) rpSStrIndex--; } else s[rpSStrIndex++] = s[i]; i++; } i = 0; int rpTStrIndex = 0; while(i &lt; tlen){ if(t[i] == '#' ){ if(rpTStrIndex > 0) rpTStrIndex--; } else t[rpTStrIndex++] = t[i]; i++; } cout &lt;&lt; rpSStrIndex &lt;&lt; rpTStrIndex; //there length is not same if(rpSStrIndex != rpTStrIndex) return false; //compare each string between replaced Index for(i = 0;i&lt;rpSStrIndex;i++){ if(s[i] != t[i]) return false; } return true; } };</content></entry><entry><title>[Leetcode] Trim a Binary Search Tree(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode669/</url><categories><category>leetcode</category></categories><tags><tag>binary Search Tree</tag><tag>binary Tree</tag><tag>recursion</tag></tags><content type="html"> LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.
Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.
example
Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] How can we solve this problem? 這題就是要我們將一顆BST的少於low的部分以及大於heigh的部分移除。這題打算使用遞歸來解決。我們只要將比low小的Node的右子樹接到他的父節點，並取代比low還小的Node，而比heigh大的Node的左子樹接到他的父節點，並取代比heigh還大的Node即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { //space : O(tree node size for all nodes value are between low and height) //time : O(tree node size for all nodes) return TrimBST(root,low,high); } TreeNode* TrimBST(TreeNode* root,int low,int height){ if(!root) return nullptr; //if the root value is less than height ,go right sub-tree //if the root value is greater than low ,go left sub-tree if(root->val &lt; low){ // root->left = nullptr; return TrimBST(root->right,low,height); }else if(root->val > height){ // root->right = nullptr; return TrimBST(root->left,low,height); } //left root->left = TrimBST(root->left,low,height); //right root->right = TrimBST(root->right,low,height); // cout &lt;&lt; root->val &lt;&lt; "\n"; return root; } };</content></entry><entry><title>[Leetcode] Search in a Binary Search Tree(EASY)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode700/</url><categories><category>leetcode</category></categories><tags><tag>binary search tree</tag><tag>recursion</tag><tag>binary Tree</tag></tags><content type="html"> LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
example
Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5 Output: [] How can we solve this problem? 在解決問題之前，我們需要知道什麼是Binary Search Tree。根據BST的定義:
Binary Search Tree 基於Binary Tree left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value Binary Search Tree的key/value都是unique的 現在我們知道什麼是BST了。這個問題是要在BST中找val，我們通過以下幾個條件以及遞歸幫我們求解:
left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value 如果val是小於root,就移動到左子樹(left sub-tree)，否者移動到右子樹(right sub-tree),直到找到val並返回root的pointer或者沒有找到返回null
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(root == nullptr) return root; //check val if(root->val > val){ //go to left return searchBST(root->left,val); // }else if(root->val &lt; val){ return searchBST(root->right,val); }else{ return root; } } };</content></entry><entry><title>[Leetcode] Shift 2D Grid(EASY)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1260/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag></tags><content type="html"> LeetCode 1260 - Shift 2D Grid Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times.
example
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] How can we solve this problem? 其實這個問題很簡單，我們只需要關心grid的最後得column，因為最後一個Column被right-shift到第一個Column的時候，最後一個element會被移動到0th。其餘的column只要right-shift by 1 step即可。 我們可以參考以下數學公式:
n是row size 以及 m 是 column size
left-shifting : currentColum + k % n, moving by k step shifting row : (j + k) / n), if it is in the last column, (j + k) / m will be 1. Otherwise will be 0 total row shifting step : (i + (j + k) / n)) % m. For example, suppose n = 3 , j = 2 , m = 3 and i = 2: (2 + ((2+1)/3)) % 3 = 0 so that it will move to [0][0] Solution: class Solution { public: vector&lt;vector&lt;int>> shiftGrid(vector&lt;vector&lt;int>>&amp; grid, int k) { //just be careful the last element on [m-1][n-1] //n - k int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); for(int i = 0 ;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ //here we need to know how many time does the colums j pass the col 0,then we need to movie the i of that time // (j + k) % m => total time walk passed int moveJ = (j + k) % m; //if current moving j is the last one int walkPassedZeorTimes = (j + k)/m; int moveI = (i + walkPassedZeorTimes) % n; res[moveI][moveJ] = grid[i][j]; } } return res; } };</content></entry><entry><title>[Leetcode] Spiral Matrix II(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode59/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 59 - Spiral Matrix II Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
example
Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Input: n = 1 Output: [[1]] How can we solve this problem? 這題跟Spiral Matrix做法差不多，我們不難發現他的移動模式就是(右→下↓左←上)，我們只需要通過幾個變數來限制移動的步數。另外，這題需要我們返回一個n2的array，所以，需要額外定義一個counter來記錄每次插入的數值為多少，因此，只要counter 到達n2的大小就知道是否完成插入所需的值。
YES! You Can! Let me explain how it works. According to the example, we can find out its moving pattern(`top-left to top-right`,`top-right to bottom-right`,`bottom-right to bottom-left` and `bottom-left to top left`), it always follows these 4 moving patterns, so that we can define a boundary of row and column to limit pointer moving to has inserted a number. Until reaching n2, it will break the loop and return the answer. -- Solution: 2, then return the answer -- class Solution { public: vector&lt;vector&lt;int>> generateMatrix(int n) { //total step n^2 vector&lt;vector&lt;int>> res(n,vector&lt;int>(n,0)); int c = 1; int upperRow = 0,lowerRow = n - 1; int upperCol = 0,lowerCol = n - 1; while(c &lt;= n*n){ //moving left if(upperCol &lt;= lowerCol){ //n step for(int i = upperCol;i&lt;=lowerCol;i++){ res[upperRow][i] = c++; } } upperRow ++; //moving down //moving down if(upperRow &lt;= lowerRow){ for(int i = upperRow;i&lt;=lowerRow;i++){ res[i][lowerCol] = c++; } } lowerCol--; //moving right if(lowerCol >= upperCol){ for(int i = lowerCol;i>=upperCol;i--){ res[lowerRow][i] = c++; } } lowerRow --; //moving up if(lowerRow >= upperRow){ for(int i = lowerRow;i>=upperRow;i--){ res[i][upperCol] = c++; } } upperCol ++; } return res; } };</content></entry><entry><title>[Leetcode] Game of Life(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode289/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 289 - Game of Life According to Wikipedia&rsquo;s article: &ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&rdquo;
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.
example
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] How can we solve this problem? 要解決這個，我們需要知道目前的cell的狀態(活/死)。要知道目前cell的狀態，我們可以用過條件判斷他身邊的cells(最多9個細胞)即可。
Solution: class Solution { public: void gameOfLife(vector&lt;vector&lt;int>>&amp; board) { int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); //O(N^2 for checking each cells) : time //O(N^2 for storing new cells states) : space for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ int total = checkState(board,i,j,n,m); if(board[i][j] == 1) res[i][j] = (total &lt; 2 || total > 3 ) ? 0 : 1; else res[i][j] = total == 3 ? 1 : 0; } } board = res; } int checkState(vector&lt;vector&lt;int>>&amp; board,int i,int j,int n,int m){ // //neighbors bounds // int rowStart = (i - i) &lt; 0 ? 0 : i - 1; // int rowEnd = (i + 1) > n - 1 ? n - 1 : i + 1; // int colStart = (j - 1) &lt; 0 ? 0 : j - 1; // int colEnd = (j + 1) > m - 1 ? m - 1 : j + 1; int livesCells = 0; //top left if(i - 1 >= 0 &amp;&amp; j -1 >= 0){ livesCells += board[i-1][j-1]; } //top if(i - 1 >= 0){ livesCells += board[i-1][j]; } //top right if(i - 1 >= 0 &amp;&amp; j + 1 &lt; m){ livesCells += board[i-1][j + 1]; } //left if(j - 1 >= 0){ livesCells += board[i][j - 1]; } //right if(j + 1 &lt; m){ livesCells += board[i][j + 1]; } //bottom left if(i + 1 &lt; n &amp;&amp; j - 1 >= 0){ livesCells += board[i+1][j-1]; } //bottom if(i + 1 &lt; n ){ livesCells += board[i+1][j]; } //bottom right if(i + 1 &lt; n &amp;&amp; j + 1 &lt; m){ livesCells += board[i+1][j+1]; } return livesCells; } };</content></entry><entry><title>[Leetcode] Baseball Game(EASY)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode682/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 682 - Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&rsquo; scores.
At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:
An integer x - Record a new score of x. &ldquo;+&rdquo; - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. &ldquo;D&rdquo; - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. &ldquo;C&rdquo; - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. example
Input: ops = ["5","2","C","D","+"] Output: 30 Explanation: "5" - Add 5 to the record, record is now [5]. "2" - Add 2 to the record, record is now [5, 2]. "C" - Invalidate and remove the previous score, record is now [5]. "D" - Add 2 * 5 = 10 to the record, record is now [5, 10]. "+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Input: ops = ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation: "5" - Add 5 to the record, record is now [5]. "-2" - Add -2 to the record, record is now [5, -2]. "4" - Add 4 to the record, record is now [5, -2, 4]. "C" - Invalidate and remove the previous score, record is now [5, -2]. "D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. "9" - Add 9 to the record, record is now [5, -2, -4, 9]. "+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. "+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. How can we solve this problem? 這題就是一個簡單的籃球比賽模擬。我們只要關心遊戲rule，並透過額外的container(array/stack)進行分數保存即可。
Solution: class Solution { public: int calPoints(vector&lt;string>&amp; ops) { //ops : + D C x // vector&lt;int> s; //or using a stack stack&lt;int> sk; //O(n) //O(n) for(auto i : ops) { if(i == "+"){ int a = sk.top(); sk.pop(); int b = sk.top(); sk.push(a); sk.push(a+b); }else if(i == "D"){ sk.push(sk.top() * 2); }else if(i == "C"){ sk.pop(); }else{ sk.push(stoi(i)); } } int res = 0; //O(n) while(!sk.empty()){ res += sk.top();sk.pop(); } return res; } };</content></entry><entry><title>[Note]Creational Singleton Pattern</title><url>https://ryantokmanmokmtm.github.io/post/creational-singleton-pattern/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Singleton Pattern(單例模式)呢? 定義:一個Class在系統中只會存在一個實例(instance),整個系統中只提供1個可使用的instance,以確保唯一性,並節省系統資源。
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
class的建構子(constructor)對外隱藏,外部無法通過constructor進行實例化，但會提供一個靜態(static)方法，以獲取這個class的唯一實例。 TaskManager
//Constructor 對外隱藏，並提供一個靜態Static 讓外部只透過這個存取 class TaskManager{ private: TaskManager(); void displayProcess(); void displayServices(); static TaskManager* taskManager = nullptr; //保存唯一Instance public: //外部只能透過靜態Static 方法存取 並new一個TaskManger的Instance 如果是null的 //此方法為工廠 static TaskManager* getInstance(){ if(taskManager == nullptr){ taskManager = new TaskManager(); } return TaskManager; } } LoadBalance
//LoadBalance 🌰 //用於計算服務器負載，所以必須使用單例 class LoadBalance{ public: static LoadBalance* getInstance(){ if(loadBalance == nullptr){ loadBalance = new LoadBalance(); } return LoadBalance; } private: static LoadBalance* loadBalance; LinkedList* serverList = nullptr; LoadBalance(); void addServer(std::string server){ serverList->add(server);//add a server } std::string getServer(){ int i = random()% serverList->length(); //random get server return serverList->get(i); } } int main(){ LoadBalance *balancer1,*balancer2,*balancer3,*balancer4; balancer1 = LoadBalance::getInstance(); //獲取LoadBalance，這裡會先new 再return balancer2 = LoadBalance::getInstance(); //獲取LoadBalance balancer3 = LoadBalance::getInstance(); //獲取LoadBalance balancer4 = LoadBalance::getInstance(); //獲取LoadBalance //以上4個balancer 都應該為同一記憶體 if(balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) printf("Balancer is nnique"); //add server balancer1->addServer("server1"); balancer1->addServer("server2"); balancer1->addServer("server3"); balancer1->addServer("server4"); for(int i = 0;i&lt;10;i++){ printf("server %d",balancer1->getServer()); } return; } Singleton的問題 因為外部不能實例化，哪應該什麼時候實例化它呢?
從上面例子可以觀察到，第一次使用到getInstance()的時候,會先判斷是否為空,是的話會先實例化並保存pointer,然後再返回Instance。
如果在多線程(Multi-threading)下，同時call getInstance() 會這樣呢?
沒錯!就會導致違反了Sington的目的，導致系統錯誤的嚴重後果。
假如TA和TB 2個Thead 同時call getInstance(),此時這個instance是為null，所以他們都會同時滿足if(instance == null),並進行new instance,導致系統記憶體中會有2個Instance.
哪要如何解決呢?
以下提供了2個方法來解決
餓漢式 在定義class的時候就先把static variable先給實例化，因此，在加載時候就已經被實例化了。 可以想象成不管要不要用(吃)，先實例化了再說(把食物買了再說) (就怕自己會餓死 xD 問題: 可能會浪費資源，因為有可能會出現不使用的情況出現。 懶漢式 要使用的時候，先檢測是否存在，再實例化(就是上面例子一樣) 問題 1: 在多線程的情況下，會變得不安全。為了確保線程安全，就必須要用到Mutex進行保護(會增加開銷) 問題 2: 雖然有加上鎖，但是有可能線程會一起進入if 判斷，等一個thread解鎖了，另外一個還是會重新new 新的一個。因此，要在裡面加多一個if來判斷是否為null。這個稱為double-Check Locking 能克服餓漢式 以及 懶漢式的方法:
在Class內部定義static class來進行實現
因為static Singleton* instance 並不是Class Singleton的成員(Member)，所以在加載時候，不會被實例化，只有呼叫了getInstance 的時候才會被實例化。
class Singleton { private: Singleton() {} static class HolderClass { private: static Singleton* instance = new Singleton(); } public: static Singleton getInstance() { return HolderClass::instance } } } 優點 為系統提供了唯一的Instance 因只有一個Instance,能節省系統資源 在Singleton 模式中，除了唯一的，也可以提供指定數量的Instance，以解決分享過多造成的性能問題 缺點 難以擴展，因為Singleton 不是由 Abstract Class實現 違背原則 有點違反單一職責原則(Single-responsibility Principe) 因又是工廠的角色(new instance),又是Product的角色(返回Static 獲取實例) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Leetcode] Top K Frequent Elements(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode347/</url><categories><category>leetcode</category></categories><tags><tag>map</tag><tag>priority queue</tag><tag>array</tag></tags><content type="html"> LeetCode 347 - Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
example
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] How can we solve this problem? 這一題需要我們返回K個數量最多的element。所以，我們可以使用map記錄我們array中element的個數，然後在把他們以&lt;frequency,element>存到priority queue/max queue，最後只要返回priority queue中的k個element即可。
Solution: class Solution { public: vector&lt;int> topKFrequent(vector&lt;int>&amp; nums, int k) { vector&lt;int> res; unordered_map&lt;int,int> map; priority_queue&lt;pair&lt;int,int>> q; for(auto i : nums) map[i]++; //counter numbers for(auto it : map) q.push({it.second,it.first}); //according to the second for priority while(k-- > 0) { res.push_back(q.top().second); q.pop(); } return res; } };</content></entry><entry><title>[Leetcode] Kth Largest Element in a Stream(EASY)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode703/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 703 - Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. example:
Input ["KthLargest", "add", "add", "add", "add", "add"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 How can we solve this problem? 首先，我們要知道這個問題在問什麼。很簡單，這個問題問的是array中k個大元素。舉例 [1,2,3,4,5 ] k=3，需要我們求出三個最大的element，所以會是[3,4,5]。因此。我們只需要關心最大的K的element即可，其他都可以拋棄掉。
th largest element in the array, so we just need to know what the largest kth elements are. For example `[1,2,3,4,5 ] k=3`, the largest 3 elements are `[3,4,5]` right?. Therefore, we just need to consider the top k elements in the array and the other elements will be discarded. -- Solution: class KthLargest { private: priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; int k; public: KthLargest(int k, vector&lt;int>&amp; nums) { for(auto e : nums) { q.push(e); if(q.size() > k) q.pop(); } this->k = k; } int add(int val) { q.push(val); if(q.size() > k) q.pop(); return q.top(); } };</content></entry><entry><title>長庚大學-畢業專題獎項</title><url>https://ryantokmanmokmtm.github.io/achievement/my-first-reward/</url><categories><category>CGU</category><category>Reward</category></categories><tags/><content type="html"> Reward 這是我跟組員們一起討論、辛苦了多個日夜，能一起做寫程式，分享知識的感覺真的很棒>&lt;。雖然不知道以後還沒有機會一起合作，但還是非常感謝他們願意陪我躲在實驗室裡面一整天(╥╯^╰╥)。希望他們能好好生活，好好學習！
My Teammates</content></entry><entry><title>[Note]Creational Abstract Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-abstract-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Abstract Factory(抽象工廠)呢? 定義: 又稱為Kit模式。提供一個創建系列相關或者互相依賴的Interface，而無需指定其具體的class
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過定義不同組件的Abstraction類,並把Abstraction類組合在一起。通過繼承抽象工廠的方式，定義不同的工廠類，生成不同的Product。 由以下例子可見，有2組不同的UI分別是Summary以及Spring，他們都分包實現了Abstraction 類，然後在透過實現各自的工廠類，生成Summary以及Spring的Product //🌰UI //Button TextField ComboBox //Abstract Class UI class Button{ public: virtual void display() = 0; } class TextField{ public: virtual void display() = 0; } class ComboBox{ public: virtual void display() = 0; } //Abstract Class Factory //用於把不同類型的UI/主題Group 在一起 class UIFactory { public: virtual Button* createButton() = 0; virtual TextField* createTextField() = 0; virtual ComboBox* createComboBox() = 0; } //Spring class SpringButton : public Button{ public: void Draw(){ //Draw Spring style Button } } class SpringTextField : public TextField{ public: void Draw(){ //Draw Spring stype TextField } } class SpringComboBox : public ComboBox{ public: void Draw(){ //Draw Spring stype ComboBox } } //Summer class SummerButton : public Button{ public: void Draw(){ //Draw Summer style Button } } class SummerTextField : public TextField{ public: void Draw(){ //Draw Summer style TextField } } class SummerComboBox : public ComboBox{ public: void Draw(){ //Draw Summer style ComboBox } } //Factory class SpringFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SpringButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SpringTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SpringComboBox(); return ComboBox; }; } //SummerFactory class SummerFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SummerButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SummerTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SummerComboBox(); return ComboBox; }; } int main(){ //就是透過工廠生成接口生成不同的工廠 //再透過不同的工廠調用其生產的product //Summer 工廠 UIFactory* factory = new SummerFactory(); Button* button = factory->createButton(); TextField* textField = factory->createTextField(); ComboBox* comboBox = factory->createComboBox(); button->draw(); //畫出Summer Style的Button textField->draw(); //畫出Summer Style的textField comboBox->draw(); //畫出Summer Style的comboBox return; } 優點 解決工廠模式中每個產品都使用一個工廠的生產的問題 新增產品很方便，擴展產品以及工廠即可(增加統一產品族) 擁有工廠模式的優點 缺點 如果要新增產品等級結構必須修過工廠抽象類，違反Open-Close 原則(增加產品等級結構) 唯一缺點就是開閉原則的傾斜性 何謂開閉原則的傾斜性呢? 就是在新增產品族(不同類型，相同產品)的時候可以符合開閉原則,但是在新增產品等級結構(同一類型，新增產品/不同的產品類型/等級)時候,必須修改抽象類。這個問題無法解決，只能透過設計避免。 例子 新增A的產品族，只需實現工程類以及實現產品類型，即可新增一個新的工廠用於生成新產品(符合Open-Close) 新增A的類型(如一個新的UI原件:IMG),這樣就必須要修改abstract class以及concrete class的內部(違反Open-Close) 抽象工廠模式跟工廠模式的區別 模式 區別 工廠模式(Factory Pattern) 每一組相關的Product都由同一個具體工廠生產 抽象工廠模式(Factory Pattern) 每個產品族(product)都由同一個具體工廠生產 例如:
電器(同牌子/同一產品族)/電器(同電器(如都是冰箱)/同一產品等級結構)
產品等級結構: 產品的繼承結構,例如:同一種類的產品(如:同一電器但不同牌子)產品族:同一工廠生產的，位於不用產品等級結構的一組產品,例如:同一族群的產品(如:同一牌子的不同電器) 抽象工廠模式(abstract factory pattern)使用場合 當一個工廠的可以創立出屬於不同產品的等級結構的一個產品族中的所有對象時,此時使用抽象工廠模式更有效率和簡單
系統不應該依賴具體的細節(如何創建,表達細節等&hellip;)，依賴於抽象(所有工廠模式都一樣) 系統中多於一個產品族時，而每次只會使用到某一個產品族。可通過配置文件動態修改產品族 約束:屬於同一產品族的產品將在一起使用(同一類)，而這些產品可以沒有任何關係，但有相同約束(同一工廠) 產品等級結構穩定，在設計完成後不會在系統更改/刪除產品等級結構(開閉原則的傾斜性) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Simple RateLimiter Example Based on IP</title><url>https://ryantokmanmokmtm.github.io/post/simple-rateLimiter-example-based-on-IP/</url><categories><category>golang</category><category>backend</category><category>note</category><category>system design</category></categories><tags><tag>gin</tag><tag>rate limiter</tag></tags><content type="html"> 基於Gin實作Rate Limiter 假設我們有2個APIs,而每個API都需要消耗1個Tokens
uri method desc /api/posts/{id} GET return a simple demo message /ping GET return pong 我們先設置一下rate limiter桶子的容量只能放下一個tokens,而tokens則會每秒生產5個。存取API時,若沒有Token可以用，就需要等待token下一次生產並放到桶子裡，才能繼續進行下去。
var ( Rate = rate.Every(time.Millisecond * 200) //1s x 10 token ReqLimiter = rate.NewLimiter(RateLimiterRate, 1) ) Post API Controller exapmle type PostCase struct { } func (p *PostUseCase) GetPost(ctx *gin.Context) { //get params id id := ctx.Param("id") //from the path //use a token if err := limiter.ReqLimiter.Wait(ctx); err != nil { ctx.JSON(http.StatusRequestTimeout, gin.H{}) return } //wait for a token is available or return ctx.JSON(http.StatusOK, gin.H{ "msg": "succeed:" + id, }) } Ping API Controller exapmle type HealthCheck struct { } func (hc *HealthCheck) Pong(ctx *gin.Context) { limiter.ReqLimiter.Wait(ctx) ctx.JSON(http.StatusOK, gin.H{ "msg": "Pong", }) } 基於ClientIP 的Rate limiter 由於上面的的例子都是所有人公用一個Rate Limiter，因此，我們這裡簡單實作一個基於IP的Rate Limiter,相同IP下會公用一個Rate Limiter。
實作思路如下:
定義Map用於保存不同IP下的Rate Limiter 定義Rate Limiter的結構 定義一個移除Rate Limiter的function 用於移除不在線的用戶(只會跑一次) 保存Limiter的結構 包含了2個成員(Member):
Limters: 主要是用於保存不同IP下的Limiter(storage) Lock : 因為有可能會有很多人同時存取這個Map,為了防止Race condition,因此需要使用Mutex進行保護 type Limiters struct { Limiters map[string]*Limiter Lock sync.Mutex } 定義Rate Limiter的結構 包含了3個成員(Member):
Limter : 一個rate limiter的實例 LastAccess : 上次存取這個limiter的時間 type Limiter struct { limiter *rate.Limiter lastAccess time.Time } 定義獲取Rate Limiter的Function 這個function主要做的事情是獲取Client IP的Rate limiter(如果存在)。如果不存在,會新建一個新的Rate Limiter，並保存到Map(storage)中。
func (ls *Limiters) GetLimiter(r rate.Limit, b int, key string) *Limiter { ls.Lock.Lock() defer ls.Lock.Unlock() if limiter, ok := ls.Limiters[key]; ok { return limiter } newLimiter := &amp;Limiter{ limiter: rate.NewLimiter(r, b), lastAccess: time.Now(), //key: key, } ls.Limiters[key] = newLimiter return newLimiter } 定義一個定期檢查Rate Limiter的function 這個function的主要作用的是在設定的時候到達時，會檢查是否有用戶的沒有存取/訪問的時間已超過設定的時間。如果已超過便會從Limiters的Map中移除，以免資源的浪費
func (ls *Limiters) ClearNotUseLimiter(sec time.Duration) { for { time.Sleep(sec) //for now just set 1-minutes for testing //for all limiter for key, l := range ls.Limiters { if time.Now().Sub(l.lastAccess) > sec { ls.Lock.Lock() delete(ls.Limiters, key) log.Printf("limiter for ip:%v is removed", key) ls.Lock.Unlock() } } } } 實作例子 因為每個Request被處理前，必須先確保此用戶(Client IP)沒有超過限制的Request的數目。所以,每個進來的Request都會先經過Middleware做預處理，獲得token後，才能進到處理的程序。
Limiter Middleware 這個Middleware中會透過Request Header(context)裡附帶的Client IP 獲得一個Limiter,並透過此Limiter檢查是否可以獲取Token，如果存取為False會直接response 一個錯誤訊息TooManyRequest
func RateLimiter() gin.HandlerFunc { return func(ctx *gin.Context) { clientIP := ctx.ClientIP() res := app.NewResponse(ctx) if clientIP == "" { res.ErrorResponse(errCode.ClientError.WithDetail("Client agent info not found or error")) ctx.Abort() } //log.Println(clientIP) //limiter : 10 request for each user and a token will generate after 1s l := newLimiters( //1s to generate a token rate.Every(global.AppSetting.LimiterTokenTime), global.AppSetting.LimiterBucketSize, //there are total 10 buckets clientIP) if !l.Allow() { res.ErrorResponse(errCode.TooManyRequest) ctx.Abort() } ctx.Next() } } 獲取Rate Limiter的function如下圖所示。細心的朋友可以發現這個包含了1個onceTask.Do的東西，其實他就是一個go語言內置允許function只跑一次的情況。透過onceTask.Do就可以實現一個Function只跑一次，無論呼叫了幾次同一個function,這個function也會只跑一次，直到程序結束。
這個onceTask.Do所做的事只有1件，也就是檢測是否有用戶不活躍，不活躍的用戶會被移除。它另外一條goroutine中進行，並不會堵塞主goroutin
func newLimiters(r rate.Limit, b int, key string) *limiter.Limiter { onceTask.Do(func() { log.Println("run once") go global.Limiters.ClearNotUseLimiter(global.AppSetting.LimterClearTime) }) return global.Limiters.GetLimiter(r, b, key) } 以上便是基於IP實作Rate Limiter的簡單方法
參考資料:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><url>https://ryantokmanmokmtm.github.io/post/token-bucket-intro/</url><categories><category>golang</category><category>backend</category><category>note</category><category>algorithm</category><category>system design</category></categories><tags><tag>golang package</tag><tag>rate limiter</tag></tags><content type="html"> Token Bucket(令牌桶算法) 什麼是Token Bucket 呢? 簡單來說就是運用Token Bucket的系統會以一個設定的速率往桶子(Bucket)裡面丟令牌(Token)。如果請求(Request)需要被處理時，就必需得Bucket裡的Token。當桶子裡面的沒有Token可以分配/獲取時，也就是說Bucket現在是空的(Token已經被其他令牌拿完了)，系統則會拒絕這個請求的服務。
根據算法(Algorithm)的定義:
A token is added to the bucket every 1/r seconds. 一個Token會以每1/r秒加入到Bucket裡面。 The bucket can hold at the most b tokens. If a token arrives when the bucket is full, it is discarded. Bucket可以保存最多b個tokens。如果在bucket以及滿了的情況下，有一個token被加入到bucket，這個token會被丟棄 例子: 假設一個n bytes的packet(封包)送達 假設目前最少有n個token在桶子裡面，這n個token就會被拿出來，然後packet就會被送到網絡上(剛好n bytes 封包有n個tokens) 假設目前桶子裡面可存取的tokens少於n個，就不會有tokens被拿出來(因為需要n個tokens 才能傳送n bytes的封包)，這個封包會被考慮為不符合的封包/不合規的封包 Go 實現/使用Token Bucket Go 的time/rate package 提供了Limiter的實作，而這個Limiter便是實作了Token Bucket的方式來達到限流的目的。
今天我們就來學習一下這麼使用go 提供Limiter來實作Rate Limiter
要如何新增一個Limiter呢? func NewLimiter(r Limit, b int) *Limiter
他有2個參數:
r: rate的type是Limit(一個float64的值)，表示著每秒會產生多少個Token,也就是每1/r秒生產1個token到bucket裡 b: Token Bucket 的桶子的Capacity(容量) //r 設置100表示每秒會產生100個tokens到桶子裡面 1/100 s(1個) //b 設置為1表示桶子最多有1個token limiter := rate.NewLimiter(100,1) Limiter的使用方式 Limiter提供了多個Function: Allow,Reserve,Wait,AllowN,ReserveN,WaitN
最主要使用為以下的3個種Function(都會消耗一個Tokens):
Allow func (lim *Limiter) Allow() bool 是 AllowN(time.Now(), 1)的縮寫 它會消耗掉一個Tokens 如果有token的話會return true 否者會token不足 return false Reserve func (lim *Limiter) Reserve() *Reservation 是 ReserveN(time.Now(), 1)的縮寫 每次會消耗掉一個token 他主要的作用是保存event的資訊預約下一次的服務 Wait(用最多的function) func (lim *Limiter) Wait(ctx context.Context) (err error) 是 WaitN(ctx, 1)的縮寫 每次會消耗掉一個token 主要的作用就是等待直到被取消或者有足夠的Tokens Wait 會堵塞(block)直到有足夠的tokens才會往下執行 Allow func (lim *Limiter) Allow() bool func (lim *Limiter) AllowN(now time.Time, n int) bool Allow() 等價於(equivalent to) AllowN(time.Now(),1)
AllowN主要的作用
AllowN 表示的是在目前的時間點，是否能消耗n個token,如bucket存在n個token則 return true 否則 return false
是想要Drop或者Skip超過rate limit的events時使用 否則使用 Reserve 或者Wait取代 Use this method if you intend to drop / skip events that exceed the rate limit. Otherwise use Reserve or Wait.
//AllowN的例子: func AllowDemo() { //each token generated every 100ms with 5 bucket limiter := rate.NewLimiter(rate.Every(time.Microsecond * 100), 5) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ //each time we need 2 tokens if isAllowed := limiter.AllowN(time.Now(), 2); isAllowed { //bucket have enough tokens fmt.Println("Welcome!!!") fmt.Printf("user:%v is allowed in %v\n", counter, time.Now().Format(time.RFC3339)) } else { fmt.Printf("user:%v is not allowed.Please wait for 100ms and try again later\n", counter) //wait for 100ms time.Sleep(100 * time.Microsecond) } } } Reserve func (lim *Limiter) Reserve() *Reservation func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation Reserve() 等價於(equivalent to) ReserveN(time.Now(),1)
ReserveN的主要作用
ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
回傳一個Reservation 表面在event執行前需要等待多久，這個Reservation被limiter納入考量內
如果Reservation 的所需的token n超過bucket 的size時,Reservation 的OK()會return false
//Reserve例子: func ReserveDemo() { //each token generated every 200ms and each second will put at most 5 tokens to bucket limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 3) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ tokensNeeds := 2 reserve := limiter.ReserveN(time.Now(), tokensNeeds) if !reserve.OK() { //this event won't be completed due to the tokens its needs fmt.Printf("needed tokens %v is greater than the bucket size %v\n", tokensNeeds, limiter.Burst()) return } //wait for the reversing time fmt.Printf("Wait for %v ms...\n", reserve.Delay()) //if dely is 0 that means no need to wait~ time.Sleep(reserve.Delay()) //at least to wait for 200ms fmt.Printf("waiting is done and now is allowed to deal with some tasks...\n") fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC3339)) } } Wait func (lim *Limiter) Wait(ctx context.Context) (err error) func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) Wait(ctx) 等價於(equivalent to) wait(time.Now(),1)
waitN的主要作用
WaitN 每次需要消耗N個Tokens，如果Bucket沒有足夠的Bucket會堵塞，直到有足夠的Tokens(n)才會繼續往下只需。除非以下條件成立才會回傳錯誤:
所需消耗tokens n大於bucket的size Context 被取消 Context 已經超過設定的Deal line(等待時間超過了Deal line) //例子 func WaitDemo() { //at most 5 tokens will generate in a sec 200/1000=5 ctx := context.Background() limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 2) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ if err := limiter.WaitN(ctx, 2); err != nil { fmt.Println("error", err) return } //wait for 2 tokens. At most wait for 400ms fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC1123)) } } 設定Bucket 和 Rate 可透過func (lim *Limiter) SetBurst(newBurst int)設定 Bucket size
可透過func (lim *Limiter) SetLimit(newLimit Limit)設定 Limit/Rate
參考資料:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Creational-Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Factory(工廠)呢? 定義:建立一個接口,讓子類自己決定實現哪一個Factory,其重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
可透過子類繼承Factory的抽象類自主決定生產什麼樣的Product。 生產的Product在透過里氏替換原則(Lisko Subsititution princeple)替換成繼承與Logger的子類，即可換成的需要的Logger。 class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc... Logger* logger = new DatabaseLogger(); //init this logger etc... return logger } } //Client to use int main(){ Factory *factory = new FileLoggerFactory(); Logger *logger = factory->createLogger(); //return the Product that it is initialized Logger->wirteLog(); return; //如果想讓系統有更多靈活性和課擴展性，可以透過xml來進行配置，不需透過修過client的代碼 //只需更新xml中的設置，在代碼中新增新的Product 以及新增的Factory 並重新編譯便可 //除了默認的設置方法外，還想透過傳入String的方法來自定義設計，例如連接要DB，文件的路徑等等 //可以透過Override Abstruct class 的func來進行設置 /* class Factory{ public: virtual Logger* createLogger() = 0; virtual Logger* createLogger(string config) = 0; virtual Logger* createLogger(Object obj) = 0;//通過Obj裡面的成員進行設置等 } */ } 優點 Client無需知道Object的設置的細節，也無需知道實質Object的名稱，只需通過工廠即可 工廠(Factory)以及產品(Product)都是透過Polymorphism(多態)來實現，也是工廠模式的關鍵，工廠可以自主的決定要生產什麼產品，在內部進行設置產品(封裝在內部) 加入新的Product時無需修改Abstract class 以及 具體的工廠和產品的類，只要擴展新增即可，符合Open-Close principle 透過繼承抽象類使系統更容易擴展 缺點 新增產品時，要加入新的產品類以及工廠類，增加了系統的複雜度，而且需要從新編譯，增加了開銷 為了擴展性,加入了抽象類，Client都使用Abstract class 進行編程，增加了系統的抽象性和理解難度 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Creational-Simple Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-simple-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Simple Factory(簡單工廠)呢? 簡單而言就是: 由一個工廠來生產全部產品 定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過Factory 類的Static 方法調用方法，傳入參數生成相關的Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == "A"){ return new ProductA(); } else if(type == "B"){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct("A"); //get ProductA instance Product* B = Factory::getProduct("B"); //get ProductB instance } 優點 Client可以自行決定生產哪個Product Client免除直接建立Product的責任，只僅僅消費產品 Client無需關心具體的類名與相關設置參數 缺點 Factory 的職責太重。所有的Product 都由一個Object 生產，一旦不能正常工作，便會影響整個系統的運作 如有不同的Product會增加系統中的class的數目，增加了系統複雜度以及理解難度 擴展十分困難，添加需要修改Factory的邏輯。如果生存的Product較多時，可能會使其邏輯過於複雜，不利於系統的擴展與維護 違背原則 違背了Open-Close Principe 如果有新的Product 需要生成，就必修要修改Factory類 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Design Pattern Princeple</title><url>https://ryantokmanmokmtm.github.io/post/design-pattern-princeple/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>learning</tag><tag>note</tag></tags><content type="html"> 什麼是Design Pattern(設計模式)呢? 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，如何解決問題的一種方案
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。 設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
Design Pattern 有什麼原則呢? 原則(Princeple) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) Design Pattern 分成哪幾種呢? 主要分成3大類，一共23個
創建型模式(6個) 結構型模式(7個) 行為型模式(11個) 創建型模式(6個) 簡單工廠模式(Simple Factory Pattern) 工廠模式(Factory Pattern) 抽象工廠模式(Abstract Factory Pattern) 單例模式(Singleton Pattern) 原形模式(Prototype Pattern) 建立者模式(Builder Pattern) 結構型模式(7個) 適配器模式(Adapter Pattern) 橋接模式(Bridge Pattern) 組合模式(Composite Pattern) 裝飾模式(Decorator Pattern) 外觀模式(Facade Pattern) 享元模式(FlayWeight Pattern) 代理模式(Proxy Pattern) 行為型模式(11個) 職責鏈模式(Chain of Responsibility Pattern) 命令模式(Command Pattern) 解釋器模式(Interpreter Pattern) 迭代器模式(Iterator Pattern) 中介者模式(Mediator Pattern) 備忘錄模式(Memento Pattern) 觀察者模式(Observer Pattern) 狀態模式(State Pattern) 策略模式(Strategy Pattern) 板塊模式(Template Method Pattern) 訪問者模式(Visitor Pattern) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]What Is JWT(Json Web Token)-EN</title><url>https://ryantokmanmokmtm.github.io/post/jwt-note/</url><categories><category>backend</category><category>development</category><category>web develpment</category><category>note</category><category>english</category></categories><tags><tag>web develpment</tag><tag>token</tag></tags><content type="html"> What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:
Header Payload Signature JWT Header Header typically consists of two parts
type : what&rsquo;s the type of the token algorithm : what algorithm does this token use to sign/encrypt. such as SHA256,RAS or HMAC { "typ" : "jwt", "alg" : "HS256" } This information will be encoded by base64Url algorithm in order to generate the JWT Header
JWT payload In payload is typically saving some users information and other useful information.
Be carefulthat payload must not include any secret information due to base64Url algorithm is easy to be decrypted.
JWT Payload standard claims
{ "sub" :"",//subject "aud" :"",//audience "jti" :"",//jwt id "iat" :"",//Issued at "iss" :"",//Issuer - who is the publisher of the jwt "nbf" :"",//Not Before - JWT is not available before the time jwt set. // other user information that developer set //for example: "user_name" : "jackson_tmm", "email" : "admin@admin.com" } This information will be encoded by base64Url algorithm in order to generate the JWT Payload
Signature The Signature is used to authenticate whether information has been modified during transmission and authenticate the sender that sent this JWT.
To Generate JWT Token Following this function
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), your-256-bit-secret) And these three partes will be combined by a . as following format: xxx.yyy.zzz
//exmaple eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ How it work between Client and server sequenceDiagram Client-Server:POST /authentication {username:xxx..} Note over Client,Server: User logs in alt is authenticated Server-Client:HTTP Status:200 {"token":eyxxx.xx.x} Note over Server,Client: Loged in Succeed else Unauthorized Server-Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Loged in Failed end Client-Server: POST /user/profile {"Authorization":"Bear token"} Note over Server,Client: Get User Profile with token alt succeed Server--Client: HTTP Status:200 {"profile":eyxxx.xx.x} Note over Server,Client: Succeed and response a profile else Unauthorized Server--Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Unauthorized(token error) end</content></entry><entry><title>[CGU]Graduation Project</title><url>https://ryantokmanmokmtm.github.io/project/final-project/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> OTT Movies recommender system-IOS Client
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database Demo Video
Updated Video</content></entry><entry><title>About me</title><url>https://ryantokmanmokmtm.github.io/about.html</url><categories/><tags/><content type="html"> 個人簡歷 Introduction 你好~ 歡迎來到我的網站!
我是Jackson.tmm, 是一個從香港來到台灣讀大學的四年級學生。目前就讀於長庚大學-資訊工程學系(Computer Science And Information Engineering)。目前已經畢業了。我目前主要是研究學習後端開發的技術。
感興趣的領域如下:
電影動畫 3D建模技術 後端開發 UI設計 圖形學 第一次學習IOS開發的Demo 基於IOS的Netfilx UI Clone 基於IOS的微博UI Clone 第一次學遊戲開發的作品 第一次學建模的作品 送給自己20歲的生日禮物的一顆排球模型 模擬水還是很好玩的(渲染了12小時 (◑‿◐) ) 燈籠魚(Lophiiformes)作品 第一次網絡課學習建模的作業 第一次網絡課學習建模的結課作品(還沒上貼圖>&lt;,有空就上) Interest 跑步，打球，說唱，唱歌，看電影，看動漫 遊戲設計，遊戲美術，3D建模 搞設計，寫程式 跟朋友分享、交流 特別喜歡宇宙/人類起源相關的奇怪知識 Current Plan 學更多有關後端開發，系統設計相關的技術 學好英文(看電影不要看字幕，能更外國人交流的程度) 考好雅思 跑去考多益了 哈哈哈 (目前660 目標800+) 做好自己,不比較,但一起學習一起進步 Contact Me: Email @Jacksontmm in Telegram</content></entry></search>