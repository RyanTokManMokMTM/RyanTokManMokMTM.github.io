<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>[LeetCode] Remove All Adjacent Duplicates in String II(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode1209/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>stack</tag></tags><content type="html"> LeetCode 1209 - Remove All Adjacent Duplicates in String II You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.
example
Input: s = "abcd", k = 2 Output: "abcd" Explanation: There's nothing to delete. Input: s = "deeedbbcccbdaa", k = 3 Output: "aa" Explanation: First delete "eee" and "ccc", get "ddbbbdaa" Then delete "bbb", get "dddaa" Finally delete "ddd", get "aa" Input: s = "pbbcggttciiippooaais", k = 2 Output: "ps" How can we solve this problem? é€™é¡Œå°±æ˜¯è¦æˆ‘å€‘åˆªé™¤æ‰åœ¨Stringè£¡é¢æŸäº›ç›¸é„°ä¸”ç›¸åŒä¸¦é‡è¤‡äº†kæ¬¡çš„Charactersã€‚ä¾‹å¦‚: aeee,k=3ï¼Œè¼¸å‡ºaã€‚å¦‚æœæˆ‘å€‘è¦è§£æ±ºé€™å€‹å•é¡Œå°±è¦çŸ¥é“ç›®å‰stringè£¡é¢æœ‰å“ªäº›subStringç¬¦åˆæ¢ä»¶ï¼Œä½†æ˜¯é€™è£¡è¦æ³¨æ„ä¸€å€‹å•é¡Œå°±æ˜¯æœ‰äº›Substringè¢«ç§»é™¤å¾Œï¼Œæœƒä½¿å‰(åˆªé™¤Str)å¾Œ2å€‹substringç¬¦åˆæ¢ä»¶ã€‚ä¾‹å¦‚:aeeeaa,ä½†æˆ‘å€‘åˆªé™¤eeeå¾Œ,aaaä¹Ÿæœƒç¬¦åˆæ¢ä»¶ï¼Œå› æ­¤æœƒè¢«ç§»é™¤ã€‚
å“ªæˆ‘å€‘è¦æ€éº¼çŸ¥é“å“ªäº›charactersç¬¦åˆæ¢ä»¶å‘¢?
é€™è£¡æˆ‘å€‘å¯ä»¥ä½¿ç”¨Stack/Arrayä¾†å¹«çµ„æˆ‘å€‘è§£é¡Œã€‚ç‚ºä»€éº¼æ˜¯ç”¨Stack? å› ç‚ºæˆ‘å€‘åªéœ€è¦é—œæ³¨ç•¶å‰str[i]æ˜¯å¦èˆ‡å‰ä¸€å€‹str[i-1]ä¸€è‡´,å¦‚æœæ˜¯ä¸€è‡´çš„æˆ‘å€‘æœƒåŠ å…¥åˆ°Stack.topçš„Counterè£¡é¢ã€‚åªè¦Counterçš„å€¼ç‚ºkæˆ‘å€‘å°±çŸ¥é“æ˜¯ç¬¦åˆæ¢ä»¶çš„Stringï¼Œç§»é™¤å³å¯ã€‚æœ€å¾Œï¼ŒæŠŠStack/Arrayè£¡é¢å‰©é¤˜çš„å…ƒç´ ä¸²æ¥å°±å¯ä»¥å¾—å‡ºæœ€å¾Œç­”æ¡ˆ(æ³¨:Stackå…ƒç´ ä¸²æ¥éœ€è¦Reverseçµæœ)ã€‚
Solution: class Solution { public: string removeDuplicates(string s, int k) { if(s.length() &lt; k) return s; string res; vector&lt;pair&lt;char,int>> counter; //O(n) for(auto str : s){ //how many same character if(counter.empty() || counter.back().first != str) counter.push_back({str,1}); else{ counter.back().second++; } if(counter.back().second == k) counter.pop_back(); } // for(auto e:vc) cout &lt;&lt; e; //O(i*k &lt;= n ) => O(n); for(int i = 0;i&lt;counter.size();i++){ for(int j = 0;j&lt;counter[i].second;j++) res+=counter[i].first; } cout &lt;&lt; res &lt;&lt;endl; return res; } };</content></entry><entry><title>[Leetcode] Implement Stack using Queues(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode225/</url><categories><category>leetcode</category></categories><tags><tag>stack</tag><tag>queue</tag><tag>design</tag></tags><content type="html"> LeetCode 225 - Implement Stack using Queues Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes:
You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&rsquo;s standard operations. example
Input ["MyStack", "push", "push", "top", "pop", "empty"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False How can we solve this problem? é€™é¡Œå°±æ˜¯è¦æˆ‘å€‘ç”¨Queueä¾†æ¨¡æ“¬Stackã€‚åšé€™é¡Œä¹‹å‰æˆ‘å€‘è¦å…ˆçŸ¥é“Queueå’ŒStackçš„å·®ç•°ã€‚
Queueæ˜¯First In First Out, ä¹Ÿå°±æ˜¯å…ˆé€²å»çš„elementæœƒå…ˆè¢«æ‹¿å‡ºä¾† Stackæ˜¯First In Last Out, ä¹Ÿå°±æ˜¯å…ˆé€²å»çš„elementæœ€å¾Œæ‰æœƒè¢«æ‹¿å‡ºä¾† push(int x):
å¦‚æœè¦ç”¨Queueä¾†æ¨¡æ“¬Stackå°±è¦æ³¨æ„åœ¨Queueä¸­çš„æœ€å¾Œä¸€å€‹å…ƒç´ æœƒæ˜¯Stackçš„ç¬¬ä¸€å€‹å…ƒç´ ã€‚æ‰€ä»¥ï¼Œé€™é¡Œæˆ‘å€‘å¯ä»¥ç”¨æ¯”è¼ƒç°¡å–®ç²—æš´çš„æ–¹å¼ä¾†è§£æ±ºã€‚å› ç‚ºæˆ‘å€‘å·²ç¶“çŸ¥é“å¾Œé€²(Last In)Stackçš„å€¼æœƒæ˜¯ç¬¬ä¸€å€‹å…ƒç´ ã€‚å› æ­¤,æˆ‘å€‘å¯ä»¥ç›´æ¥ç”¨ä¸€å€‹variableä¿å­˜æœ€å¾Œæ’å…¥é€²Queueçš„elementå³å¯ã€‚
pop()
å¦‚æœæˆ‘å€‘è¦ç§»é™¤elementï¼Œå°±å¿…é ˆè¦å°‡Queueçš„æœ€å¾Œä¸€å€‹å…ƒç´ æ¬åˆ°æœ€å‰é¢ï¼ŒåŒæ™‚å› ç‚ºæœ€å‰é¢çš„å…ƒç´ æœƒè¢«ç§»é™¤ï¼Œæ‰€ä»¥æˆ‘å€‘ç”¨æ–¼ä¿å­˜æœ€å¾Œæ’å…¥é€²Queueçš„variableæ‰€è¨˜éŒ„çš„å€¼ä¹Ÿå¿…é ˆè¢«æ”¹è®Šï¼Œè®ŠæˆQueueçš„å€’æ•¸ç¬¬äºŒå€‹elementã€‚å› æ­¤æˆ‘å€‘è¦å…ˆå°‡Queueä¸­æœ€å¾Œçš„2å€‹elementæ¬åˆ°æœ€å‰é¢ï¼Œç¬¬ä¸€å€‹ä¾¿æ˜¯æˆ‘å€‘stackçš„top,è€Œç¬¬äºŒå€‹æ˜¯æˆ‘å€‘è¦popçš„elementã€‚æœ€å¾Œï¼Œæˆ‘å€‘è¨˜éŒ„å®Œtopçš„å€¼å¾Œï¼Œæ’å…¥åˆ°Queueçš„å°¾å·´ï¼Œä¸¦è¿”å›è¦Queueçš„frontå³å¯ã€‚
clear(): åªéœ€å°‡ç©ºçš„Queueå–ä»£æˆç•¶å‰ä¸æ˜¯ç©ºçš„Queueå³å¯ã€‚
empty():
åªéœ€æª¢æŸ¥Queueæ˜¯å¦ç‚ºempty()å³å¯ã€‚
Solution: class MyStack { public: queue&lt;int> q; int t; // queue&lt;int> q2; MyStack() { } //O(N) void push(int x) { // q2.push(x); // while(!q.empty()){ // q2.push(q.front());q.pop(); // } // q = q2; // clear(q2); q.push(x); t = x; } //O(1) int pop() { // if(empty()) return -1; // int value = q.front();q.pop(); //get the last 2 elements int size = q.size(); while(size-- > 2) { q.push(q.front()); q.pop(); } //getting the 2th top value in stack t = q.front(); q.push(q.front()); //push it at the back of the queue q.pop(); //getting the 1th top value in stack int popVal = q.front(); q.pop(); return popVal; } void clear(queue&lt;int>&amp; q){ queue&lt;int> empty; swap(empty, q); } int top() { // if(empty()) return -1; // return q.front(); return t; } bool empty() { return q.empty() ? true : false; } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */</content></entry><entry><title>[Leetcode] Max Number of K-Sum Pairs(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode1679/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>map</tag><tag>two-pointer</tag></tags><content type="html"> LeetCode 1679 - Max Number of K-Sum Pairs You are given an integer array nums and an integer k.
In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.
Return the maximum number of operations you can perform on the array.
example
Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. Input: nums = [3,1,3,4,3], k = 6 Output: 1 Explanation: Starting with nums = [3,1,3,4,3]: - Remove the first two 3's, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation. How can we solve this problem? é€™é¡Œå°±æ˜¯è¦ç§»é™¤Arrayä¸­2å€‹elementsåŠ èµ·ä¾†ç­‰æ–¼kçš„æ“ä½œæœ‰å¹¾æ¬¡ã€‚
ç¬¬ä¸€å€‹è§£æ³•ï¼Œæˆ‘å€‘å¯ä»¥ä½¿ç”¨sortingä»¥åŠtwo-pointer approachä¾†è§£æ±ºã€‚å…ˆå°‡arrayæ’åºï¼Œç„¶å¾Œè¨­ç½®iç‚º0,jç‚ºn-1,ç›´æ¥ä½¿ç”¨iterationæ‰¾å‡ºnums[i]+nums[j] = kçš„æ•¸ï¼Œç„¶å¾Œanswer+1å³å¯ã€‚
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { //sort sort(nums.begin(),nums.end()); //O n log n int ans = 0; int i = 0,j = nums.size()-1; while(i &lt; j){ if(nums[i] + nums[j] == k) { ans++; i++; j--; }else if(nums[i] + nums[j] > k)j--; else i++; } return ans; } }; ç¬¬äºŒç¨®è§£æ³•æ˜¯é€émapä¾†è¨˜éŒ„ã€‚é¦–å…ˆï¼Œæœƒé€éx = k - nums[i]å¾—å‡ºä¸€å€‹æ•¸ï¼Œå¦‚æœé€™å€‹æ•¸ä¸å­˜åœ¨mapè£¡é¢æˆ–è€…map[x] &lt;= 0å°±ä»£è¡¨æ²’æœ‰ï¼Œå°±æŠŠç›®å‰çš„nums[i]åŠ å…¥åˆ°mapã€‚å¦‚æœå­˜åœ¨ï¼Œå°±å°‡answer+1ä¸¦ä¸”å¾mapä¸­ç§»é™¤map[x]çš„æ•¸é‡(map[x]--)ã€‚
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { unordered_map&lt;int,int> temp; int ans = 0; for(int i = 0;i&lt;nums.size();i++){ int sum = k - nums[i]; if(temp[sum] > 0){ //exist this value; //for example:[3,1,3,4,3] //3,1,3(we are here) 6-3=3 and 3:1 and we found a pair(3,3)=6 ,and remove the existing value ans++; temp[sum]--; }else temp[nums[i]]++; } return ans; } };</content></entry><entry><title>[Leetcode] Shortest Unsorted Continuous Subarray(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode581/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 581 - Shortest Unsorted Continuous Subarray Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.
Return the shortest such subarray and output its length.
example:
Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Input: nums = [1,2,3,4] Output: 0 Input: nums = [1] Output: 0 How can we solve this problem? é€™é¡Œæ¯”è¼ƒé›£æ‡‚ä¸€é»é»ï¼Œé€™è£¡å…ˆåšä¸€ä¸‹é¡Œç›®çš„è§£é‡‹ã€‚é€™é¡Œä¸»è¦å…ˆå•çš„æ˜¯åœ¨è¼¸å…¥çš„Arrayè£¡é¢æ‰¾åˆ°ä¸€å€‹æœ€å°éœ€è¦æ’åºçš„Sub-arrayã€‚
å¾ä¾‹å­[2,6,4,8,10,9,15]ä¸­ï¼Œæˆ‘å€‘å¯ä»¥å¾ˆæ˜é¡¯çš„çœ‹åˆ°[6,4,8,10,9]ä¸¦ä¸æ˜¯ascending order(é †åº),è€Œé€™å€‹sub-arrayè¦é€²è¡Œæ’åºçš„è©±ï¼Œæ‰€æœ‰elementséƒ½éœ€è¦é€²è¡Œæ’åºï¼Œæ‰€ä»¥ï¼Œä»–çš„lengthæ˜¯5ã€‚
å†èˆ‰å¦å¤–ä¸€å€‹ä¾‹å­[1,3,2,3,3]ï¼Œé€™å€‹Arrayæˆ‘å€‘å¯ä»¥çœ‹åˆ°[3,2,3,3]ä¸¦ä¸æ˜¯é †åºçš„ï¼Œä½†æ˜¯åœ¨é€™å€‹sub-arrayè£¡é¢,åªæœ‰[3,2]éœ€è¦æ’åº,æ‰€ä»¥ï¼Œä»–çš„çµæœæœƒæ˜¯2ã€‚
é‚£æˆ‘å€‘æ‡‰è©²è¦æ€éº¼è§£å‘¢? ä¸€å€‹æœ€ç°¡å–®çš„è§£æ³•æ˜¯å®šç¾©ä¸€å€‹é¡å¤–çš„arrayï¼Œè€Œé€™å€‹arrayçš„elementè·ŸåŸä¾†çš„ä¸€æ¨£ï¼Œä½†æ˜¯å·²ç¶“è¢«æ’åºéçš„ã€‚å› æ­¤ï¼Œåªè¦æ¯”è¼ƒåŸæœ¬çš„arrayå’Œæ’åºéçš„arrayæœ‰å¹¾å€‹elementçš„ä½ç½®ä¸ä¸€æ¨£å°±çŸ¥é“çµæœäº†ã€‚ä½†Time Complexityæ˜¯æ˜¯O(n log n) - æ’åºçš„æ™‚é–“ï¼Œè€ŒSpace Complexityå‰‡æ˜¯O(n)
Solution: vector&lt;int> temp = nums; sort(temp.begin(),temp.end()); //n log n int start = nums.size() - 1; int end = 0; //finding the starting point which is not as same as the sorted array //finding the ending print which is not as same as the sorted array for(int i =0;i&lt;nums.size();i++){ if(nums[i] != temp[i]){ start = min(i,start); // end = max(end,i); } } return end - start >= 0 ? end - start + 1 : 0; å¦å¤–ä¸€ç¨®è§£æ³•æ˜¯é€šéTwo-pointer approachä¾†è§£ã€‚æˆ‘å€‘å…ˆè¦æ‰¾åˆ°å·¦æ‰‹é‚Šæœ‰å•é¡Œçš„åœ°æ–¹çš„æœ€å°å€¼(1,4,7,5,3,6 æœ€å°å€¼ç‚º3)ä»¥åŠå³æ‰‹é‚Šæœ‰å•é¡Œçš„åœ°æ–¹çš„æœ€å¤§å€¼(1,4,7,5,3,6 æœ€å¤§å€¼ç‚º7)ã€‚ç„¶å¾Œ,è¦æ‰¾å‡ºå·¦æ‰‹é‚Šç¬¬ä¸€å€‹è¢«å½±éŸ¿çš„index(nums[index] > æœ€å°å€¼)ã€‚åŒç†ä¹Ÿè¦æ‰¾å‡ºå³æ‰‹é‚Šç¬¬ä¸€å€‹è¢«å½±éŸ¿çš„æœ€index(nums[index] &lt; æœ€å¤§å€¼)ã€‚é€™æ¨£æˆ‘å€‘å°±èƒ½æ‰¾å‡ºæœ‰å•é¡Œçš„å€é–“[left,right]ï¼Œåœ¨æ ¹æ“šleft,rightå¾—å‡ºæœ€çµ‚çµæœã€‚ Solution: è§£æ³•äºŒ:
int start = INT_MAX; int end = INT_MIN; for(int i = 1;i&lt;nums.size();i++){ if(nums[i] &lt; nums[i-1]) start = min(nums[i],start); } for(int i = nums.size() - 2;i>=0;i--){ if(nums[i] > nums[i + 1]) end = max(nums[i],end); } int left,right; //scanning the value from the left to the right that is less than maximum value for(left = 0;left&lt;nums.size();left++){ //finding the descending point if(start &lt; nums[left]) break; } //scanning the value from the right to the left that is less than minimum value for(right = nums.size() - 1;right >= 0;right--){ if(end > nums[right]) break; } //we need to find out the right-most point return right - left >= 0 ? right - left + 1 : 0;</content></entry><entry><title>[Leetcode] Sort Array By Parity(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode905/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 905 - Sort Array By Parity Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
Return any array that satisfies this condition.
example:
Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Input: nums = [0] Output: [0] How can we solve this problem? é€™å€‹å•é¡Œå¾ˆç°¡å–®ï¼Œå°±æ˜¯æŠŠå¶æ•¸ç§»å‹•åˆ°Arrayçš„å‰é¢ï¼ŒåŸºæ•¸ç§»å‹•åˆ°å¾Œé¢ã€‚æˆ‘å€‘é€™è£¡å¯ä»¥ä½¿ç”¨Two-pointer approach, iç‚ºå°‹æ‰¾å‰é¢çš„åŸºæ•¸ï¼Œè€Œj ç‚ºå°‹æ‰¾å¾Œé¢çš„å¶æ•¸ï¼Œåªè¦nums[i]ç‚ºåŸºæ•¸,nums[j]ç‚ºå¶æ•¸å°±é€²è¡Œäº¤æ›ã€‚
=j`å°±çµæŸ -- Solution: class Solution { public: vector&lt;int> sortArrayByParity(vector&lt;int>&amp; nums) { int i = 0; int j = nums.size() - 1; //O(n) while(i &lt; j){ //i is even skip //j is odd skip //i is odd and j is even swap if(nums[i] % 2 == 0) i++; else if(nums[j] % 2 == 1) j--; else swap(nums[i++],nums[j--]); } return nums; } };</content></entry><entry><title>[Leetcode] Backspace String Compare(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode844/</url><categories><category>leetcode</category></categories><tags><tag>string</tag></tags><content type="html"> LeetCode 844 - Backspace String Compare Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
example:
Input: s = "ab#c", t = "ad#c" Output: true Explanation: Both s and t become "ac". Input: s = "ab##", t = "c#d#" Output: true Explanation: Both s and t become "". Input: s = "a#c", t = "b" Output: false Explanation: s becomes "c" while t becomes "b". How can we solve this problem? é€™é¡Œä¸»è¦è¦ä»€éº¼æ¯”è¼ƒ2å€‹Stringç§»é™¤æ–¼#å‰çš„å­—ç¬¦å¾Œæ˜¯å¦ç‚ºç›¸åŒçš„Stringï¼Œå°±ç›¸ç•¶æ–¼Backspace(#) å­—ç¬¦ã€‚ é€™é¡Œæœ‰2ç¨®è§£æ³•:
è¦ä½¿ç”¨åˆ°é¡å¤–çš„ç©ºé–“ï¼Œä¿å­˜2å€‹ç§»é™¤å­—ç¬¦å¾Œçš„Stringå†é€²è¡Œæ¯”è¼ƒã€‚ é€épointerrçš„æ–¹å¼ä¾†æ±ºå®šå“ªå€‹ä½ç½®æ˜¯è¦è¢«ç§»é™¤çš„ï¼Œç„¶å¾Œå°‡ä¹‹å¾Œçš„å­—ç¬¦å°‡å…¶é€²è¡Œå–ä»£ï¼Œæœ€å¾Œåœ¨æ¯”è¼ƒå€†è€…åœ¨ré•·åº¦å…§çš„å­—ç¬¦æ˜¯å¦ç›¸åŒï¼Œå³å¯ã€‚å¯è¦‹ä¸‹åœ–ç‚ºä¾‹: Solution: class Solution { public: bool backspaceCompare(string s, string t) { int slen = s.length(); int tlen = t.length(); int i = 0; int rpSStrIndex = 0; while(i &lt; slen ){ if(s[i] == '#') { if(rpSStrIndex > 0) rpSStrIndex--; } else s[rpSStrIndex++] = s[i]; i++; } i = 0; int rpTStrIndex = 0; while(i &lt; tlen){ if(t[i] == '#' ){ if(rpTStrIndex > 0) rpTStrIndex--; } else t[rpTStrIndex++] = t[i]; i++; } cout &lt;&lt; rpSStrIndex &lt;&lt; rpTStrIndex; //there length is not same if(rpSStrIndex != rpTStrIndex) return false; //compare each string between replaced Index for(i = 0;i&lt;rpSStrIndex;i++){ if(s[i] != t[i]) return false; } return true; } };</content></entry><entry><title>[Leetcode] Trim a Binary Search Tree(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode669/</url><categories><category>leetcode</category></categories><tags><tag>binary Search Tree</tag><tag>binary Tree</tag><tag>recursion</tag></tags><content type="html"> LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.
Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.
example
Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] How can we solve this problem? é€™é¡Œå°±æ˜¯è¦æˆ‘å€‘å°‡ä¸€é¡†BSTçš„å°‘æ–¼lowçš„éƒ¨åˆ†ä»¥åŠå¤§æ–¼heighçš„éƒ¨åˆ†ç§»é™¤ã€‚é€™é¡Œæ‰“ç®—ä½¿ç”¨éæ­¸ä¾†è§£æ±ºã€‚æˆ‘å€‘åªè¦å°‡æ¯”lowå°çš„Nodeçš„å³å­æ¨¹æ¥åˆ°ä»–çš„çˆ¶ç¯€é»ï¼Œä¸¦å–ä»£æ¯”lowé‚„å°çš„Nodeï¼Œè€Œæ¯”heighå¤§çš„Nodeçš„å·¦å­æ¨¹æ¥åˆ°ä»–çš„çˆ¶ç¯€é»ï¼Œä¸¦å–ä»£æ¯”heighé‚„å¤§çš„Nodeå³å¯ã€‚
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { //space : O(tree node size for all nodes value are between low and height) //time : O(tree node size for all nodes) return TrimBST(root,low,high); } TreeNode* TrimBST(TreeNode* root,int low,int height){ if(!root) return nullptr; //if the root value is less than height ,go right sub-tree //if the root value is greater than low ,go left sub-tree if(root->val &lt; low){ // root->left = nullptr; return TrimBST(root->right,low,height); }else if(root->val > height){ // root->right = nullptr; return TrimBST(root->left,low,height); } //left root->left = TrimBST(root->left,low,height); //right root->right = TrimBST(root->right,low,height); // cout &lt;&lt; root->val &lt;&lt; "\n"; return root; } };</content></entry><entry><title>[Leetcode] Search in a Binary Search Tree(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode700/</url><categories><category>leetcode</category></categories><tags><tag>binary search tree</tag><tag>recursion</tag><tag>binary Tree</tag></tags><content type="html"> LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
example
Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5 Output: [] How can we solve this problem? åœ¨è§£æ±ºå•é¡Œä¹‹å‰ï¼Œæˆ‘å€‘éœ€è¦çŸ¥é“ä»€éº¼æ˜¯Binary Search Treeã€‚æ ¹æ“šBSTçš„å®šç¾©:
Binary Search Tree åŸºæ–¼Binary Tree left sub-treeçš„æ‰€æœ‰Node value éƒ½å°æ–¼root value right sub-treeçš„æ‰€æœ‰Node value éƒ½å¤§æ–¼root value Binary Search Treeçš„key/valueéƒ½æ˜¯uniqueçš„ ç¾åœ¨æˆ‘å€‘çŸ¥é“ä»€éº¼æ˜¯BSTäº†ã€‚é€™å€‹å•é¡Œæ˜¯è¦åœ¨BSTä¸­æ‰¾valï¼Œæˆ‘å€‘é€šéä»¥ä¸‹å¹¾å€‹æ¢ä»¶ä»¥åŠéæ­¸å¹«æˆ‘å€‘æ±‚è§£:
left sub-treeçš„æ‰€æœ‰Node value éƒ½å°æ–¼root value right sub-treeçš„æ‰€æœ‰Node value éƒ½å¤§æ–¼root value å¦‚æœvalæ˜¯å°æ–¼root,å°±ç§»å‹•åˆ°å·¦å­æ¨¹(left sub-tree)ï¼Œå¦è€…ç§»å‹•åˆ°å³å­æ¨¹(right sub-tree),ç›´åˆ°æ‰¾åˆ°valä¸¦è¿”å›rootçš„pointeræˆ–è€…æ²’æœ‰æ‰¾åˆ°è¿”å›null
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(root == nullptr) return root; //check val if(root->val > val){ //go to left return searchBST(root->left,val); // }else if(root->val &lt; val){ return searchBST(root->right,val); }else{ return root; } } };</content></entry><entry><title>[Leetcode] Shift 2D Grid(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode1260/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag></tags><content type="html"> LeetCode 1260 - Shift 2D Grid Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times.
example
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] How can we solve this problem? å…¶å¯¦é€™å€‹å•é¡Œå¾ˆç°¡å–®ï¼Œæˆ‘å€‘åªéœ€è¦é—œå¿ƒgridçš„æœ€å¾Œå¾—columnï¼Œå› ç‚ºæœ€å¾Œä¸€å€‹Columnè¢«right-shiftåˆ°ç¬¬ä¸€å€‹Columnçš„æ™‚å€™ï¼Œæœ€å¾Œä¸€å€‹elementæœƒè¢«ç§»å‹•åˆ°0thã€‚å…¶é¤˜çš„columnåªè¦right-shift by 1 stepå³å¯ã€‚ æˆ‘å€‘å¯ä»¥åƒè€ƒä»¥ä¸‹æ•¸å­¸å…¬å¼:
næ˜¯row size ä»¥åŠ m æ˜¯ column size
left-shifting : currentColum + k % n, moving by k step shifting row : (j + k) / n), if it is in the last column, (j + k) / m will be 1. Otherwise will be 0 total row shifting step : (i + (j + k) / n)) % m. For example, suppose n = 3 , j = 2 , m = 3 and i = 2: (2 + ((2+1)/3)) % 3 = 0 so that it will move to [0][0] Solution: class Solution { public: vector&lt;vector&lt;int>> shiftGrid(vector&lt;vector&lt;int>>&amp; grid, int k) { //just be careful the last element on [m-1][n-1] //n - k int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); for(int i = 0 ;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ //here we need to know how many time does the colums j pass the col 0,then we need to movie the i of that time // (j + k) % m => total time walk passed int moveJ = (j + k) % m; //if current moving j is the last one int walkPassedZeorTimes = (j + k)/m; int moveI = (i + walkPassedZeorTimes) % n; res[moveI][moveJ] = grid[i][j]; } } return res; } };</content></entry><entry><title>[Leetcode] Spiral Matrix II(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode59/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 59 - Spiral Matrix II Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
example
Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Input: n = 1 Output: [[1]] How can we solve this problem? é€™é¡Œè·ŸSpiral Matrixåšæ³•å·®ä¸å¤šï¼Œæˆ‘å€‘ä¸é›£ç™¼ç¾ä»–çš„ç§»å‹•æ¨¡å¼å°±æ˜¯(å³â†’ä¸‹â†“å·¦â†ä¸Š)ï¼Œæˆ‘å€‘åªéœ€è¦é€šéå¹¾å€‹è®Šæ•¸ä¾†é™åˆ¶ç§»å‹•çš„æ­¥æ•¸ã€‚å¦å¤–ï¼Œé€™é¡Œéœ€è¦æˆ‘å€‘è¿”å›ä¸€å€‹n*nçš„arrayï¼Œæ‰€ä»¥ï¼Œéœ€è¦é¡å¤–å®šç¾©ä¸€å€‹counterä¾†è¨˜éŒ„æ¯æ¬¡æ’å…¥çš„æ•¸å€¼ç‚ºå¤šå°‘ï¼Œå› æ­¤ï¼Œåªè¦counter åˆ°é”n*nçš„å¤§å°å°±çŸ¥é“æ˜¯å¦å®Œæˆæ’å…¥æ‰€éœ€çš„å€¼ã€‚
YES! You Can! Let me explain how it works. According to the example, we can find out its moving pattern(`top-left to top-right`,`top-right to bottom-right`,`bottom-right to bottom-left` and `bottom-left to top left`), it always follows these 4 moving patterns, so that we can define a boundary of row and column to limit pointer moving to has inserted a number. Until reaching n2, it will break the loop and return the answer. -- Solution: 2, then return the answer -- class Solution { public: vector&lt;vector&lt;int>> generateMatrix(int n) { //total step n^2 vector&lt;vector&lt;int>> res(n,vector&lt;int>(n,0)); int c = 1; int upperRow = 0,lowerRow = n - 1; int upperCol = 0,lowerCol = n - 1; while(c &lt;= n*n){ //moving left if(upperCol &lt;= lowerCol){ //n step for(int i = upperCol;i&lt;=lowerCol;i++){ res[upperRow][i] = c++; } } upperRow ++; //moving down //moving down if(upperRow &lt;= lowerRow){ for(int i = upperRow;i&lt;=lowerRow;i++){ res[i][lowerCol] = c++; } } lowerCol--; //moving right if(lowerCol >= upperCol){ for(int i = lowerCol;i>=upperCol;i--){ res[lowerRow][i] = c++; } } lowerRow --; //moving up if(lowerRow >= upperRow){ for(int i = lowerRow;i>=upperRow;i--){ res[i][upperCol] = c++; } } upperCol ++; } return res; } };</content></entry><entry><title>[Leetcode] Game of Life(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode289/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 289 - Game of Life According to Wikipedia&rsquo;s article: &ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&rdquo;
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.
example
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] How can we solve this problem? è¦è§£æ±ºé€™å€‹ï¼Œæˆ‘å€‘éœ€è¦çŸ¥é“ç›®å‰çš„cellçš„ç‹€æ…‹(æ´»/æ­»)ã€‚è¦çŸ¥é“ç›®å‰cellçš„ç‹€æ…‹ï¼Œæˆ‘å€‘å¯ä»¥ç”¨éæ¢ä»¶åˆ¤æ–·ä»–èº«é‚Šçš„cells(æœ€å¤š9å€‹ç´°èƒ)å³å¯ã€‚
Solution: class Solution { public: void gameOfLife(vector&lt;vector&lt;int>>&amp; board) { int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); //O(N^2 for checking each cells) : time //O(N^2 for storing new cells states) : space for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ int total = checkState(board,i,j,n,m); if(board[i][j] == 1) res[i][j] = (total &lt; 2 || total > 3 ) ? 0 : 1; else res[i][j] = total == 3 ? 1 : 0; } } board = res; } int checkState(vector&lt;vector&lt;int>>&amp; board,int i,int j,int n,int m){ // //neighbors bounds // int rowStart = (i - i) &lt; 0 ? 0 : i - 1; // int rowEnd = (i + 1) > n - 1 ? n - 1 : i + 1; // int colStart = (j - 1) &lt; 0 ? 0 : j - 1; // int colEnd = (j + 1) > m - 1 ? m - 1 : j + 1; int livesCells = 0; //top left if(i - 1 >= 0 &amp;&amp; j -1 >= 0){ livesCells += board[i-1][j-1]; } //top if(i - 1 >= 0){ livesCells += board[i-1][j]; } //top right if(i - 1 >= 0 &amp;&amp; j + 1 &lt; m){ livesCells += board[i-1][j + 1]; } //left if(j - 1 >= 0){ livesCells += board[i][j - 1]; } //right if(j + 1 &lt; m){ livesCells += board[i][j + 1]; } //bottom left if(i + 1 &lt; n &amp;&amp; j - 1 >= 0){ livesCells += board[i+1][j-1]; } //bottom if(i + 1 &lt; n ){ livesCells += board[i+1][j]; } //bottom right if(i + 1 &lt; n &amp;&amp; j + 1 &lt; m){ livesCells += board[i+1][j+1]; } return livesCells; } };</content></entry><entry><title>[Leetcode] Baseball Game(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode682/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 682 - Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&rsquo; scores.
At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:
An integer x - Record a new score of x. &ldquo;+&rdquo; - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. &ldquo;D&rdquo; - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. &ldquo;C&rdquo; - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. example
Input: ops = ["5","2","C","D","+"] Output: 30 Explanation: "5" - Add 5 to the record, record is now [5]. "2" - Add 2 to the record, record is now [5, 2]. "C" - Invalidate and remove the previous score, record is now [5]. "D" - Add 2 * 5 = 10 to the record, record is now [5, 10]. "+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Input: ops = ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation: "5" - Add 5 to the record, record is now [5]. "-2" - Add -2 to the record, record is now [5, -2]. "4" - Add 4 to the record, record is now [5, -2, 4]. "C" - Invalidate and remove the previous score, record is now [5, -2]. "D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. "9" - Add 9 to the record, record is now [5, -2, -4, 9]. "+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. "+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. How can we solve this problem? é€™é¡Œå°±æ˜¯ä¸€å€‹ç°¡å–®çš„ç±ƒçƒæ¯”è³½æ¨¡æ“¬ã€‚æˆ‘å€‘åªè¦é—œå¿ƒéŠæˆ²ruleï¼Œä¸¦é€éé¡å¤–çš„container(array/stack)é€²è¡Œåˆ†æ•¸ä¿å­˜å³å¯ã€‚
Solution: class Solution { public: int calPoints(vector&lt;string>&amp; ops) { //ops : + D C x // vector&lt;int> s; //or using a stack stack&lt;int> sk; //O(n) //O(n) for(auto i : ops) { if(i == "+"){ int a = sk.top(); sk.pop(); int b = sk.top(); sk.push(a); sk.push(a+b); }else if(i == "D"){ sk.push(sk.top() * 2); }else if(i == "C"){ sk.pop(); }else{ sk.push(stoi(i)); } } int res = 0; //O(n) while(!sk.empty()){ res += sk.top();sk.pop(); } return res; } };</content></entry><entry><title>[Note]Creational Singleton Pattern</title><url>https://ryantokmanmokmtm.github.io/post/creational-singleton-pattern/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> ä»€éº¼æ˜¯Singleton Pattern(å–®ä¾‹æ¨¡å¼)å‘¢? å®šç¾©:ä¸€å€‹Classåœ¨ç³»çµ±ä¸­åªæœƒå­˜åœ¨ä¸€å€‹å¯¦ä¾‹(instance),æ•´å€‹ç³»çµ±ä¸­åªæä¾›1å€‹å¯ä½¿ç”¨çš„instance,ä»¥ç¢ºä¿å”¯ä¸€æ€§,ä¸¦ç¯€çœç³»çµ±è³‡æºã€‚
ç°¡å–®ä¾‹å­ æ³¨: ä»¥ä¸‹ç¨‹å¼å–®ç´”ç”¨æ–¼è§£é‡‹ï¼Œä¸¦ä¸èƒ½å¯¦éš›åŸ·è¡Œ
classçš„å»ºæ§‹å­(constructor)å°å¤–éš±è—,å¤–éƒ¨ç„¡æ³•é€šéconstructoré€²è¡Œå¯¦ä¾‹åŒ–ï¼Œä½†æœƒæä¾›ä¸€å€‹éœæ…‹(static)æ–¹æ³•ï¼Œä»¥ç²å–é€™å€‹classçš„å”¯ä¸€å¯¦ä¾‹ã€‚ TaskManager
//Constructor å°å¤–éš±è—ï¼Œä¸¦æä¾›ä¸€å€‹éœæ…‹Static è®“å¤–éƒ¨åªé€éé€™å€‹å­˜å– class TaskManager{ private: TaskManager(); void displayProcess(); void displayServices(); static TaskManager* taskManager = nullptr; //ä¿å­˜å”¯ä¸€Instance public: //å¤–éƒ¨åªèƒ½é€ééœæ…‹Static æ–¹æ³•å­˜å– ä¸¦newä¸€å€‹TaskMangerçš„Instance å¦‚æœæ˜¯nullçš„ //æ­¤æ–¹æ³•ç‚ºå·¥å»  static TaskManager* getInstance(){ if(taskManager == nullptr){ taskManager = new TaskManager(); } return TaskManager; } } LoadBalance
//LoadBalance ğŸŒ° //ç”¨æ–¼è¨ˆç®—æœå‹™å™¨è² è¼‰ï¼Œæ‰€ä»¥å¿…é ˆä½¿ç”¨å–®ä¾‹ class LoadBalance{ public: static LoadBalance* getInstance(){ if(loadBalance == nullptr){ loadBalance = new LoadBalance(); } return LoadBalance; } private: static LoadBalance* loadBalance; LinkedList* serverList = nullptr; LoadBalance(); void addServer(std::string server){ serverList->add(server);//add a server } std::string getServer(){ int i = random()% serverList->length(); //random get server return serverList->get(i); } } int main(){ LoadBalance *balancer1,*balancer2,*balancer3,*balancer4; balancer1 = LoadBalance::getInstance(); //ç²å–LoadBalanceï¼Œé€™è£¡æœƒå…ˆnew å†return balancer2 = LoadBalance::getInstance(); //ç²å–LoadBalance balancer3 = LoadBalance::getInstance(); //ç²å–LoadBalance balancer4 = LoadBalance::getInstance(); //ç²å–LoadBalance //ä»¥ä¸Š4å€‹balancer éƒ½æ‡‰è©²ç‚ºåŒä¸€è¨˜æ†¶é«” if(balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) printf("Balancer is nnique"); //add server balancer1->addServer("server1"); balancer1->addServer("server2"); balancer1->addServer("server3"); balancer1->addServer("server4"); for(int i = 0;i&lt;10;i++){ printf("server %d",balancer1->getServer()); } return; } Singletonçš„å•é¡Œ å› ç‚ºå¤–éƒ¨ä¸èƒ½å¯¦ä¾‹åŒ–ï¼Œå“ªæ‡‰è©²ä»€éº¼æ™‚å€™å¯¦ä¾‹åŒ–å®ƒå‘¢?
å¾ä¸Šé¢ä¾‹å­å¯ä»¥è§€å¯Ÿåˆ°ï¼Œç¬¬ä¸€æ¬¡ä½¿ç”¨åˆ°getInstance()çš„æ™‚å€™,æœƒå…ˆåˆ¤æ–·æ˜¯å¦ç‚ºç©º,æ˜¯çš„è©±æœƒå…ˆå¯¦ä¾‹åŒ–ä¸¦ä¿å­˜pointer,ç„¶å¾Œå†è¿”å›Instanceã€‚
å¦‚æœåœ¨å¤šç·šç¨‹(Multi-threading)ä¸‹ï¼ŒåŒæ™‚call getInstance() æœƒé€™æ¨£å‘¢?
æ²’éŒ¯!å°±æœƒå°è‡´é•åäº†Singtonçš„ç›®çš„ï¼Œå°è‡´ç³»çµ±éŒ¯èª¤çš„åš´é‡å¾Œæœã€‚
å‡å¦‚TAå’ŒTB 2å€‹Thead åŒæ™‚call getInstance(),æ­¤æ™‚é€™å€‹instanceæ˜¯ç‚ºnullï¼Œæ‰€ä»¥ä»–å€‘éƒ½æœƒåŒæ™‚æ»¿è¶³if(instance == null),ä¸¦é€²è¡Œnew instance,å°è‡´ç³»çµ±è¨˜æ†¶é«”ä¸­æœƒæœ‰2å€‹Instance.
å“ªè¦å¦‚ä½•è§£æ±ºå‘¢?
ä»¥ä¸‹æä¾›äº†2å€‹æ–¹æ³•ä¾†è§£æ±º
é¤“æ¼¢å¼ åœ¨å®šç¾©classçš„æ™‚å€™å°±å…ˆæŠŠstatic variableå…ˆçµ¦å¯¦ä¾‹åŒ–ï¼Œå› æ­¤ï¼Œåœ¨åŠ è¼‰æ™‚å€™å°±å·²ç¶“è¢«å¯¦ä¾‹åŒ–äº†ã€‚ å¯ä»¥æƒ³è±¡æˆä¸ç®¡è¦ä¸è¦ç”¨(åƒ)ï¼Œå…ˆå¯¦ä¾‹åŒ–äº†å†èªª(æŠŠé£Ÿç‰©è²·äº†å†èªª) (å°±æ€•è‡ªå·±æœƒé¤“æ­» xD å•é¡Œ: å¯èƒ½æœƒæµªè²»è³‡æºï¼Œå› ç‚ºæœ‰å¯èƒ½æœƒå‡ºç¾ä¸ä½¿ç”¨çš„æƒ…æ³å‡ºç¾ã€‚ æ‡¶æ¼¢å¼ è¦ä½¿ç”¨çš„æ™‚å€™ï¼Œå…ˆæª¢æ¸¬æ˜¯å¦å­˜åœ¨ï¼Œå†å¯¦ä¾‹åŒ–(å°±æ˜¯ä¸Šé¢ä¾‹å­ä¸€æ¨£) å•é¡Œ 1: åœ¨å¤šç·šç¨‹çš„æƒ…æ³ä¸‹ï¼Œæœƒè®Šå¾—ä¸å®‰å…¨ã€‚ç‚ºäº†ç¢ºä¿ç·šç¨‹å®‰å…¨ï¼Œå°±å¿…é ˆè¦ç”¨åˆ°Mutexé€²è¡Œä¿è­·(æœƒå¢åŠ é–‹éŠ·) å•é¡Œ 2: é›–ç„¶æœ‰åŠ ä¸Šé–ï¼Œä½†æ˜¯æœ‰å¯èƒ½ç·šç¨‹æœƒä¸€èµ·é€²å…¥if åˆ¤æ–·ï¼Œç­‰ä¸€å€‹threadè§£é–äº†ï¼Œå¦å¤–ä¸€å€‹é‚„æ˜¯æœƒé‡æ–°new æ–°çš„ä¸€å€‹ã€‚å› æ­¤ï¼Œè¦åœ¨è£¡é¢åŠ å¤šä¸€å€‹ifä¾†åˆ¤æ–·æ˜¯å¦ç‚ºnullã€‚é€™å€‹ç¨±ç‚ºdouble-Check Locking èƒ½å…‹æœé¤“æ¼¢å¼ ä»¥åŠ æ‡¶æ¼¢å¼çš„æ–¹æ³•:
åœ¨Classå…§éƒ¨å®šç¾©static classä¾†é€²è¡Œå¯¦ç¾
å› ç‚ºstatic Singleton* instance ä¸¦ä¸æ˜¯Class Singletonçš„æˆå“¡(Member)ï¼Œæ‰€ä»¥åœ¨åŠ è¼‰æ™‚å€™ï¼Œä¸æœƒè¢«å¯¦ä¾‹åŒ–ï¼Œåªæœ‰å‘¼å«äº†getInstance çš„æ™‚å€™æ‰æœƒè¢«å¯¦ä¾‹åŒ–ã€‚
class Singleton { private: Singleton() {} static class HolderClass { private: static Singleton* instance = new Singleton(); } public: static Singleton getInstance() { return HolderClass::instance } } } å„ªé» ç‚ºç³»çµ±æä¾›äº†å”¯ä¸€çš„Instance å› åªæœ‰ä¸€å€‹Instance,èƒ½ç¯€çœç³»çµ±è³‡æº åœ¨Singleton æ¨¡å¼ä¸­ï¼Œé™¤äº†å”¯ä¸€çš„ï¼Œä¹Ÿå¯ä»¥æä¾›æŒ‡å®šæ•¸é‡çš„Instanceï¼Œä»¥è§£æ±ºåˆ†äº«éå¤šé€ æˆçš„æ€§èƒ½å•é¡Œ ç¼ºé» é›£ä»¥æ“´å±•ï¼Œå› ç‚ºSingleton ä¸æ˜¯ç”± Abstract Classå¯¦ç¾ é•èƒŒåŸå‰‡ æœ‰é»é•åå–®ä¸€è·è²¬åŸå‰‡(Single-responsibility Principe) å› åˆæ˜¯å·¥å» çš„è§’è‰²(new instance),åˆæ˜¯Productçš„è§’è‰²(è¿”å›Static ç²å–å¯¦ä¾‹) åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Leetcode] Top K Frequent Elements(MEDIUM)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode347/</url><categories><category>leetcode</category></categories><tags><tag>map</tag><tag>priority queue</tag><tag>array</tag></tags><content type="html"> LeetCode 347 - Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
example
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] How can we solve this problem? é€™ä¸€é¡Œéœ€è¦æˆ‘å€‘è¿”å›Kå€‹æ•¸é‡æœ€å¤šçš„elementã€‚æ‰€ä»¥ï¼Œæˆ‘å€‘å¯ä»¥ä½¿ç”¨mapè¨˜éŒ„æˆ‘å€‘arrayä¸­elementçš„å€‹æ•¸ï¼Œç„¶å¾Œåœ¨æŠŠä»–å€‘ä»¥&lt;frequency,element>å­˜åˆ°priority queue/max queueï¼Œæœ€å¾Œåªè¦è¿”å›priority queueä¸­çš„kå€‹elementå³å¯ã€‚
Solution: class Solution { public: vector&lt;int> topKFrequent(vector&lt;int>&amp; nums, int k) { vector&lt;int> res; unordered_map&lt;int,int> map; priority_queue&lt;pair&lt;int,int>> q; for(auto i : nums) map[i]++; //counter numbers for(auto it : map) q.push({it.second,it.first}); //according to the second for priority while(k-- > 0) { res.push_back(q.top().second); q.pop(); } return res; } };</content></entry><entry><title>[Leetcode] Kth Largest Element in a Stream(EASY)</title><url>https://ryantokmanmokmtm.github.io/post/leetcode703/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 703 - Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. example:
Input ["KthLargest", "add", "add", "add", "add", "add"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 How can we solve this problem? é¦–å…ˆï¼Œæˆ‘å€‘è¦çŸ¥é“é€™å€‹å•é¡Œåœ¨å•ä»€éº¼ã€‚å¾ˆç°¡å–®ï¼Œé€™å€‹å•é¡Œå•çš„æ˜¯arrayä¸­kå€‹å¤§å…ƒç´ ã€‚èˆ‰ä¾‹ [1,2,3,4,5 ] k=3ï¼Œéœ€è¦æˆ‘å€‘æ±‚å‡ºä¸‰å€‹æœ€å¤§çš„elementï¼Œæ‰€ä»¥æœƒæ˜¯[3,4,5]ã€‚å› æ­¤ã€‚æˆ‘å€‘åªéœ€è¦é—œå¿ƒæœ€å¤§çš„Kçš„elementå³å¯ï¼Œå…¶ä»–éƒ½å¯ä»¥æ‹‹æ£„æ‰ã€‚
th largest element in the array, so we just need to know what the largest kth elements are. For example `[1,2,3,4,5 ] k=3`, the largest 3 elements are `[3,4,5]` right?. Therefore, we just need to consider the top k elements in the array and the other elements will be discarded. -- Solution: class KthLargest { private: priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; int k; public: KthLargest(int k, vector&lt;int>&amp; nums) { for(auto e : nums) { q.push(e); if(q.size() > k) q.pop(); } this->k = k; } int add(int val) { q.push(val); if(q.size() > k) q.pop(); return q.top(); } };</content></entry><entry><title>é•·åºšå¤§å­¸-ç•¢æ¥­å°ˆé¡Œçé …</title><url>https://ryantokmanmokmtm.github.io/achievement/my-first-reward/</url><categories><category>CGU</category><category>Reward</category></categories><tags/><content type="html"> Reward é€™æ˜¯æˆ‘è·Ÿçµ„å“¡å€‘ä¸€èµ·è¨è«–ã€è¾›è‹¦äº†å¤šå€‹æ—¥å¤œï¼Œèƒ½ä¸€èµ·åšå¯«ç¨‹å¼ï¼Œåˆ†äº«çŸ¥è­˜çš„æ„Ÿè¦ºçœŸçš„å¾ˆæ£’>&lt;ã€‚é›–ç„¶ä¸çŸ¥é“ä»¥å¾Œé‚„æ²’æœ‰æ©Ÿæœƒä¸€èµ·åˆä½œï¼Œä½†é‚„æ˜¯éå¸¸æ„Ÿè¬ä»–å€‘é¡˜æ„é™ªæˆ‘èº²åœ¨å¯¦é©—å®¤è£¡é¢ä¸€æ•´å¤©(â•¥â•¯^â•°â•¥)ã€‚å¸Œæœ›ä»–å€‘èƒ½å¥½å¥½ç”Ÿæ´»ï¼Œå¥½å¥½å­¸ç¿’ï¼
My Teammates</content></entry><entry><title>[Note]Creational Abstract Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-abstract-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> ä»€éº¼æ˜¯Abstract Factory(æŠ½è±¡å·¥å» )å‘¢? å®šç¾©: åˆç¨±ç‚ºKitæ¨¡å¼ã€‚æä¾›ä¸€å€‹å‰µå»ºç³»åˆ—ç›¸é—œæˆ–è€…äº’ç›¸ä¾è³´çš„Interfaceï¼Œè€Œç„¡éœ€æŒ‡å®šå…¶å…·é«”çš„class
ç°¡å–®ä¾‹å­ æ³¨: ä»¥ä¸‹ç¨‹å¼å–®ç´”ç”¨æ–¼è§£é‡‹ï¼Œä¸¦ä¸èƒ½å¯¦éš›åŸ·è¡Œ
é€éå®šç¾©ä¸åŒçµ„ä»¶çš„Abstractioné¡,ä¸¦æŠŠAbstractioné¡çµ„åˆåœ¨ä¸€èµ·ã€‚é€šéç¹¼æ‰¿æŠ½è±¡å·¥å» çš„æ–¹å¼ï¼Œå®šç¾©ä¸åŒçš„å·¥å» é¡ï¼Œç”Ÿæˆä¸åŒçš„Productã€‚ ç”±ä»¥ä¸‹ä¾‹å­å¯è¦‹ï¼Œæœ‰2çµ„ä¸åŒçš„UIåˆ†åˆ¥æ˜¯Summaryä»¥åŠSpringï¼Œä»–å€‘éƒ½åˆ†åŒ…å¯¦ç¾äº†Abstraction é¡ï¼Œç„¶å¾Œåœ¨é€éå¯¦ç¾å„è‡ªçš„å·¥å» é¡ï¼Œç”ŸæˆSummaryä»¥åŠSpringçš„Product //ğŸŒ°UI //Button TextField ComboBox //Abstract Class UI class Button{ public: virtual void display() = 0; } class TextField{ public: virtual void display() = 0; } class ComboBox{ public: virtual void display() = 0; } //Abstract Class Factory //ç”¨æ–¼æŠŠä¸åŒé¡å‹çš„UI/ä¸»é¡ŒGroup åœ¨ä¸€èµ· class UIFactory { public: virtual Button* createButton() = 0; virtual TextField* createTextField() = 0; virtual ComboBox* createComboBox() = 0; } //Spring class SpringButton : public Button{ public: void Draw(){ //Draw Spring style Button } } class SpringTextField : public TextField{ public: void Draw(){ //Draw Spring stype TextField } } class SpringComboBox : public ComboBox{ public: void Draw(){ //Draw Spring stype ComboBox } } //Summer class SummerButton : public Button{ public: void Draw(){ //Draw Summer style Button } } class SummerTextField : public TextField{ public: void Draw(){ //Draw Summer style TextField } } class SummerComboBox : public ComboBox{ public: void Draw(){ //Draw Summer style ComboBox } } //Factory class SpringFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SpringButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SpringTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SpringComboBox(); return ComboBox; }; } //SummerFactory class SummerFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SummerButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SummerTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SummerComboBox(); return ComboBox; }; } int main(){ //å°±æ˜¯é€éå·¥å» ç”Ÿæˆæ¥å£ç”Ÿæˆä¸åŒçš„å·¥å»  //å†é€éä¸åŒçš„å·¥å» èª¿ç”¨å…¶ç”Ÿç”¢çš„product //Summer å·¥å»  UIFactory* factory = new SummerFactory(); Button* button = factory->createButton(); TextField* textField = factory->createTextField(); ComboBox* comboBox = factory->createComboBox(); button->draw(); //ç•«å‡ºSummer Styleçš„Button textField->draw(); //ç•«å‡ºSummer Styleçš„textField comboBox->draw(); //ç•«å‡ºSummer Styleçš„comboBox return; } å„ªé» è§£æ±ºå·¥å» æ¨¡å¼ä¸­æ¯å€‹ç”¢å“éƒ½ä½¿ç”¨ä¸€å€‹å·¥å» çš„ç”Ÿç”¢çš„å•é¡Œ æ–°å¢ç”¢å“å¾ˆæ–¹ä¾¿ï¼Œæ“´å±•ç”¢å“ä»¥åŠå·¥å» å³å¯(å¢åŠ çµ±ä¸€ç”¢å“æ—) æ“æœ‰å·¥å» æ¨¡å¼çš„å„ªé» ç¼ºé» å¦‚æœè¦æ–°å¢ç”¢å“ç­‰ç´šçµæ§‹å¿…é ˆä¿®éå·¥å» æŠ½è±¡é¡ï¼Œé•åOpen-Close åŸå‰‡(å¢åŠ ç”¢å“ç­‰ç´šçµæ§‹) å”¯ä¸€ç¼ºé»å°±æ˜¯é–‹é–‰åŸå‰‡çš„å‚¾æ–œæ€§ ä½•è¬‚é–‹é–‰åŸå‰‡çš„å‚¾æ–œæ€§å‘¢? å°±æ˜¯åœ¨æ–°å¢ç”¢å“æ—(ä¸åŒé¡å‹ï¼Œç›¸åŒç”¢å“)çš„æ™‚å€™å¯ä»¥ç¬¦åˆé–‹é–‰åŸå‰‡,ä½†æ˜¯åœ¨æ–°å¢ç”¢å“ç­‰ç´šçµæ§‹(åŒä¸€é¡å‹ï¼Œæ–°å¢ç”¢å“/ä¸åŒçš„ç”¢å“é¡å‹/ç­‰ç´š)æ™‚å€™,å¿…é ˆä¿®æ”¹æŠ½è±¡é¡ã€‚é€™å€‹å•é¡Œç„¡æ³•è§£æ±ºï¼Œåªèƒ½é€éè¨­è¨ˆé¿å…ã€‚ ä¾‹å­ æ–°å¢Açš„ç”¢å“æ—ï¼Œåªéœ€å¯¦ç¾å·¥ç¨‹é¡ä»¥åŠå¯¦ç¾ç”¢å“é¡å‹ï¼Œå³å¯æ–°å¢ä¸€å€‹æ–°çš„å·¥å» ç”¨æ–¼ç”Ÿæˆæ–°ç”¢å“(ç¬¦åˆOpen-Close) æ–°å¢Açš„é¡å‹(å¦‚ä¸€å€‹æ–°çš„UIåŸä»¶:IMG),é€™æ¨£å°±å¿…é ˆè¦ä¿®æ”¹abstract classä»¥åŠconcrete classçš„å…§éƒ¨(é•åOpen-Close) æŠ½è±¡å·¥å» æ¨¡å¼è·Ÿå·¥å» æ¨¡å¼çš„å€åˆ¥ æ¨¡å¼ å€åˆ¥ å·¥å» æ¨¡å¼(Factory Pattern) æ¯ä¸€çµ„ç›¸é—œçš„Productéƒ½ç”±åŒä¸€å€‹å…·é«”å·¥å» ç”Ÿç”¢ æŠ½è±¡å·¥å» æ¨¡å¼(Factory Pattern) æ¯å€‹ç”¢å“æ—(product)éƒ½ç”±åŒä¸€å€‹å…·é«”å·¥å» ç”Ÿç”¢ ä¾‹å¦‚:
é›»å™¨(åŒç‰Œå­/åŒä¸€ç”¢å“æ—)/é›»å™¨(åŒé›»å™¨(å¦‚éƒ½æ˜¯å†°ç®±)/åŒä¸€ç”¢å“ç­‰ç´šçµæ§‹)
ç”¢å“ç­‰ç´šçµæ§‹: ç”¢å“çš„ç¹¼æ‰¿çµæ§‹,ä¾‹å¦‚:åŒä¸€ç¨®é¡çš„ç”¢å“(å¦‚:åŒä¸€é›»å™¨ä½†ä¸åŒç‰Œå­)ç”¢å“æ—:åŒä¸€å·¥å» ç”Ÿç”¢çš„ï¼Œä½æ–¼ä¸ç”¨ç”¢å“ç­‰ç´šçµæ§‹çš„ä¸€çµ„ç”¢å“,ä¾‹å¦‚:åŒä¸€æ—ç¾¤çš„ç”¢å“(å¦‚:åŒä¸€ç‰Œå­çš„ä¸åŒé›»å™¨) æŠ½è±¡å·¥å» æ¨¡å¼(abstract factory pattern)ä½¿ç”¨å ´åˆ ç•¶ä¸€å€‹å·¥å» çš„å¯ä»¥å‰µç«‹å‡ºå±¬æ–¼ä¸åŒç”¢å“çš„ç­‰ç´šçµæ§‹çš„ä¸€å€‹ç”¢å“æ—ä¸­çš„æ‰€æœ‰å°è±¡æ™‚,æ­¤æ™‚ä½¿ç”¨æŠ½è±¡å·¥å» æ¨¡å¼æ›´æœ‰æ•ˆç‡å’Œç°¡å–®
ç³»çµ±ä¸æ‡‰è©²ä¾è³´å…·é«”çš„ç´°ç¯€(å¦‚ä½•å‰µå»º,è¡¨é”ç´°ç¯€ç­‰&hellip;)ï¼Œä¾è³´æ–¼æŠ½è±¡(æ‰€æœ‰å·¥å» æ¨¡å¼éƒ½ä¸€æ¨£) ç³»çµ±ä¸­å¤šæ–¼ä¸€å€‹ç”¢å“æ—æ™‚ï¼Œè€Œæ¯æ¬¡åªæœƒä½¿ç”¨åˆ°æŸä¸€å€‹ç”¢å“æ—ã€‚å¯é€šéé…ç½®æ–‡ä»¶å‹•æ…‹ä¿®æ”¹ç”¢å“æ— ç´„æŸ:å±¬æ–¼åŒä¸€ç”¢å“æ—çš„ç”¢å“å°‡åœ¨ä¸€èµ·ä½¿ç”¨(åŒä¸€é¡)ï¼Œè€Œé€™äº›ç”¢å“å¯ä»¥æ²’æœ‰ä»»ä½•é—œä¿‚ï¼Œä½†æœ‰ç›¸åŒç´„æŸ(åŒä¸€å·¥å» ) ç”¢å“ç­‰ç´šçµæ§‹ç©©å®šï¼Œåœ¨è¨­è¨ˆå®Œæˆå¾Œä¸æœƒåœ¨ç³»çµ±æ›´æ”¹/åˆªé™¤ç”¢å“ç­‰ç´šçµæ§‹(é–‹é–‰åŸå‰‡çš„å‚¾æ–œæ€§) åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Note]Simple RateLimiter Example Based on IP</title><url>https://ryantokmanmokmtm.github.io/post/simple-rateLimiter-example-based-on-IP/</url><categories><category>golang</category><category>backend</category><category>note</category><category>system design</category></categories><tags><tag>gin</tag><tag>rate limiter</tag></tags><content type="html"> åŸºæ–¼Ginå¯¦ä½œRate Limiter å‡è¨­æˆ‘å€‘æœ‰2å€‹APIs,è€Œæ¯å€‹APIéƒ½éœ€è¦æ¶ˆè€—1å€‹Tokens
uri method desc /api/posts/{id} GET return a simple demo message /ping GET return pong æˆ‘å€‘å…ˆè¨­ç½®ä¸€ä¸‹rate limiteræ¡¶å­çš„å®¹é‡åªèƒ½æ”¾ä¸‹ä¸€å€‹tokens,è€Œtokenså‰‡æœƒæ¯ç§’ç”Ÿç”¢5å€‹ã€‚å­˜å–APIæ™‚,è‹¥æ²’æœ‰Tokenå¯ä»¥ç”¨ï¼Œå°±éœ€è¦ç­‰å¾…tokenä¸‹ä¸€æ¬¡ç”Ÿç”¢ä¸¦æ”¾åˆ°æ¡¶å­è£¡ï¼Œæ‰èƒ½ç¹¼çºŒé€²è¡Œä¸‹å»ã€‚
var ( Rate = rate.Every(time.Millisecond * 200) //1s x 10 token ReqLimiter = rate.NewLimiter(RateLimiterRate, 1) ) Post API Controller exapmle type PostCase struct { } func (p *PostUseCase) GetPost(ctx *gin.Context) { //get params id id := ctx.Param("id") //from the path //use a token if err := limiter.ReqLimiter.Wait(ctx); err != nil { ctx.JSON(http.StatusRequestTimeout, gin.H{}) return } //wait for a token is available or return ctx.JSON(http.StatusOK, gin.H{ "msg": "succeed:" + id, }) } Ping API Controller exapmle type HealthCheck struct { } func (hc *HealthCheck) Pong(ctx *gin.Context) { limiter.ReqLimiter.Wait(ctx) ctx.JSON(http.StatusOK, gin.H{ "msg": "Pong", }) } åŸºæ–¼ClientIP çš„Rate limiter ç”±æ–¼ä¸Šé¢çš„çš„ä¾‹å­éƒ½æ˜¯æ‰€æœ‰äººå…¬ç”¨ä¸€å€‹Rate Limiterï¼Œå› æ­¤ï¼Œæˆ‘å€‘é€™è£¡ç°¡å–®å¯¦ä½œä¸€å€‹åŸºæ–¼IPçš„Rate Limiter,ç›¸åŒIPä¸‹æœƒå…¬ç”¨ä¸€å€‹Rate Limiterã€‚
å¯¦ä½œæ€è·¯å¦‚ä¸‹:
å®šç¾©Mapç”¨æ–¼ä¿å­˜ä¸åŒIPä¸‹çš„Rate Limiter å®šç¾©Rate Limiterçš„çµæ§‹ å®šç¾©ä¸€å€‹ç§»é™¤Rate Limiterçš„function ç”¨æ–¼ç§»é™¤ä¸åœ¨ç·šçš„ç”¨æˆ¶(åªæœƒè·‘ä¸€æ¬¡) ä¿å­˜Limiterçš„çµæ§‹ åŒ…å«äº†2å€‹æˆå“¡(Member):
Limters: ä¸»è¦æ˜¯ç”¨æ–¼ä¿å­˜ä¸åŒIPä¸‹çš„Limiter(storage) Lock : å› ç‚ºæœ‰å¯èƒ½æœƒæœ‰å¾ˆå¤šäººåŒæ™‚å­˜å–é€™å€‹Map,ç‚ºäº†é˜²æ­¢Race condition,å› æ­¤éœ€è¦ä½¿ç”¨Mutexé€²è¡Œä¿è­· type Limiters struct { Limiters map[string]*Limiter Lock sync.Mutex } å®šç¾©Rate Limiterçš„çµæ§‹ åŒ…å«äº†3å€‹æˆå“¡(Member):
Limter : ä¸€å€‹rate limiterçš„å¯¦ä¾‹ LastAccess : ä¸Šæ¬¡å­˜å–é€™å€‹limiterçš„æ™‚é–“ type Limiter struct { limiter *rate.Limiter lastAccess time.Time } å®šç¾©ç²å–Rate Limiterçš„Function é€™å€‹functionä¸»è¦åšçš„äº‹æƒ…æ˜¯ç²å–Client IPçš„Rate limiter(å¦‚æœå­˜åœ¨)ã€‚å¦‚æœä¸å­˜åœ¨,æœƒæ–°å»ºä¸€å€‹æ–°çš„Rate Limiterï¼Œä¸¦ä¿å­˜åˆ°Map(storage)ä¸­ã€‚
func (ls *Limiters) GetLimiter(r rate.Limit, b int, key string) *Limiter { ls.Lock.Lock() defer ls.Lock.Unlock() if limiter, ok := ls.Limiters[key]; ok { return limiter } newLimiter := &amp;Limiter{ limiter: rate.NewLimiter(r, b), lastAccess: time.Now(), //key: key, } ls.Limiters[key] = newLimiter return newLimiter } å®šç¾©ä¸€å€‹å®šæœŸæª¢æŸ¥Rate Limiterçš„function é€™å€‹functionçš„ä¸»è¦ä½œç”¨çš„æ˜¯åœ¨è¨­å®šçš„æ™‚å€™åˆ°é”æ™‚ï¼Œæœƒæª¢æŸ¥æ˜¯å¦æœ‰ç”¨æˆ¶çš„æ²’æœ‰å­˜å–/è¨ªå•çš„æ™‚é–“å·²è¶…éè¨­å®šçš„æ™‚é–“ã€‚å¦‚æœå·²è¶…éä¾¿æœƒå¾Limitersçš„Mapä¸­ç§»é™¤ï¼Œä»¥å…è³‡æºçš„æµªè²»
func (ls *Limiters) ClearNotUseLimiter(sec time.Duration) { for { time.Sleep(sec) //for now just set 1-minutes for testing //for all limiter for key, l := range ls.Limiters { if time.Now().Sub(l.lastAccess) > sec { ls.Lock.Lock() delete(ls.Limiters, key) log.Printf("limiter for ip:%v is removed", key) ls.Lock.Unlock() } } } } å¯¦ä½œä¾‹å­ å› ç‚ºæ¯å€‹Requestè¢«è™•ç†å‰ï¼Œå¿…é ˆå…ˆç¢ºä¿æ­¤ç”¨æˆ¶(Client IP)æ²’æœ‰è¶…éé™åˆ¶çš„Requestçš„æ•¸ç›®ã€‚æ‰€ä»¥,æ¯å€‹é€²ä¾†çš„Requestéƒ½æœƒå…ˆç¶“éMiddlewareåšé è™•ç†ï¼Œç²å¾—tokenå¾Œï¼Œæ‰èƒ½é€²åˆ°è™•ç†çš„ç¨‹åºã€‚
Limiter Middleware é€™å€‹Middlewareä¸­æœƒé€éRequest Header(context)è£¡é™„å¸¶çš„Client IP ç²å¾—ä¸€å€‹Limiter,ä¸¦é€éæ­¤Limiteræª¢æŸ¥æ˜¯å¦å¯ä»¥ç²å–Tokenï¼Œå¦‚æœå­˜å–ç‚ºFalseæœƒç›´æ¥response ä¸€å€‹éŒ¯èª¤è¨Šæ¯TooManyRequest
func RateLimiter() gin.HandlerFunc { return func(ctx *gin.Context) { clientIP := ctx.ClientIP() res := app.NewResponse(ctx) if clientIP == "" { res.ErrorResponse(errCode.ClientError.WithDetail("Client agent info not found or error")) ctx.Abort() } //log.Println(clientIP) //limiter : 10 request for each user and a token will generate after 1s l := newLimiters( //1s to generate a token rate.Every(global.AppSetting.LimiterTokenTime), global.AppSetting.LimiterBucketSize, //there are total 10 buckets clientIP) if !l.Allow() { res.ErrorResponse(errCode.TooManyRequest) ctx.Abort() } ctx.Next() } } ç²å–Rate Limiterçš„functionå¦‚ä¸‹åœ–æ‰€ç¤ºã€‚ç´°å¿ƒçš„æœ‹å‹å¯ä»¥ç™¼ç¾é€™å€‹åŒ…å«äº†1å€‹onceTask.Doçš„æ±è¥¿ï¼Œå…¶å¯¦ä»–å°±æ˜¯ä¸€å€‹goèªè¨€å…§ç½®å…è¨±functionåªè·‘ä¸€æ¬¡çš„æƒ…æ³ã€‚é€éonceTask.Doå°±å¯ä»¥å¯¦ç¾ä¸€å€‹Functionåªè·‘ä¸€æ¬¡ï¼Œç„¡è«–å‘¼å«äº†å¹¾æ¬¡åŒä¸€å€‹function,é€™å€‹functionä¹Ÿæœƒåªè·‘ä¸€æ¬¡ï¼Œç›´åˆ°ç¨‹åºçµæŸã€‚
é€™å€‹onceTask.Doæ‰€åšçš„äº‹åªæœ‰1ä»¶ï¼Œä¹Ÿå°±æ˜¯æª¢æ¸¬æ˜¯å¦æœ‰ç”¨æˆ¶ä¸æ´»èºï¼Œä¸æ´»èºçš„ç”¨æˆ¶æœƒè¢«ç§»é™¤ã€‚å®ƒå¦å¤–ä¸€æ¢goroutineä¸­é€²è¡Œï¼Œä¸¦ä¸æœƒå µå¡ä¸»goroutin
func newLimiters(r rate.Limit, b int, key string) *limiter.Limiter { onceTask.Do(func() { log.Println("run once") go global.Limiters.ClearNotUseLimiter(global.AppSetting.LimterClearTime) }) return global.Limiters.GetLimiter(r, b, key) } ä»¥ä¸Šä¾¿æ˜¯åŸºæ–¼IPå¯¦ä½œRate Limiterçš„ç°¡å–®æ–¹æ³•
åƒè€ƒè³‡æ–™:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><url>https://ryantokmanmokmtm.github.io/post/token-bucket-intro/</url><categories><category>golang</category><category>backend</category><category>note</category><category>algorithm</category><category>system design</category></categories><tags><tag>golang package</tag><tag>rate limiter</tag></tags><content type="html"> Token Bucket(ä»¤ç‰Œæ¡¶ç®—æ³•) ä»€éº¼æ˜¯Token Bucket å‘¢? ç°¡å–®ä¾†èªªå°±æ˜¯é‹ç”¨Token Bucketçš„ç³»çµ±æœƒä»¥ä¸€å€‹è¨­å®šçš„é€Ÿç‡å¾€æ¡¶å­(Bucket)è£¡é¢ä¸Ÿä»¤ç‰Œ(Token)ã€‚å¦‚æœè«‹æ±‚(Request)éœ€è¦è¢«è™•ç†æ™‚ï¼Œå°±å¿…éœ€å¾—Bucketè£¡çš„Tokenã€‚ç•¶æ¡¶å­è£¡é¢çš„æ²’æœ‰Tokenå¯ä»¥åˆ†é…/ç²å–æ™‚ï¼Œä¹Ÿå°±æ˜¯èªªBucketç¾åœ¨æ˜¯ç©ºçš„(Tokenå·²ç¶“è¢«å…¶ä»–ä»¤ç‰Œæ‹¿å®Œäº†)ï¼Œç³»çµ±å‰‡æœƒæ‹’çµ•é€™å€‹è«‹æ±‚çš„æœå‹™ã€‚
æ ¹æ“šç®—æ³•(Algorithm)çš„å®šç¾©:
A token is added to the bucket every 1/r seconds. ä¸€å€‹Tokenæœƒä»¥æ¯1/rç§’åŠ å…¥åˆ°Bucketè£¡é¢ã€‚ The bucket can hold at the most b tokens. If a token arrives when the bucket is full, it is discarded. Bucketå¯ä»¥ä¿å­˜æœ€å¤šbå€‹tokensã€‚å¦‚æœåœ¨bucketä»¥åŠæ»¿äº†çš„æƒ…æ³ä¸‹ï¼Œæœ‰ä¸€å€‹tokenè¢«åŠ å…¥åˆ°bucketï¼Œé€™å€‹tokenæœƒè¢«ä¸Ÿæ£„ ä¾‹å­: å‡è¨­ä¸€å€‹n bytesçš„packet(å°åŒ…)é€é” å‡è¨­ç›®å‰æœ€å°‘æœ‰nå€‹tokenåœ¨æ¡¶å­è£¡é¢ï¼Œé€™nå€‹tokenå°±æœƒè¢«æ‹¿å‡ºä¾†ï¼Œç„¶å¾Œpacketå°±æœƒè¢«é€åˆ°ç¶²çµ¡ä¸Š(å‰›å¥½n bytes å°åŒ…æœ‰nå€‹tokens) å‡è¨­ç›®å‰æ¡¶å­è£¡é¢å¯å­˜å–çš„tokenså°‘æ–¼nå€‹ï¼Œå°±ä¸æœƒæœ‰tokensè¢«æ‹¿å‡ºä¾†(å› ç‚ºéœ€è¦nå€‹tokens æ‰èƒ½å‚³é€n bytesçš„å°åŒ…)ï¼Œé€™å€‹å°åŒ…æœƒè¢«è€ƒæ…®ç‚ºä¸ç¬¦åˆçš„å°åŒ…/ä¸åˆè¦çš„å°åŒ… Go å¯¦ç¾/ä½¿ç”¨Token Bucket Go çš„time/rate package æä¾›äº†Limiterçš„å¯¦ä½œï¼Œè€Œé€™å€‹Limiterä¾¿æ˜¯å¯¦ä½œäº†Token Bucketçš„æ–¹å¼ä¾†é”åˆ°é™æµçš„ç›®çš„ã€‚
ä»Šå¤©æˆ‘å€‘å°±ä¾†å­¸ç¿’ä¸€ä¸‹é€™éº¼ä½¿ç”¨go æä¾›Limiterä¾†å¯¦ä½œRate Limiter
è¦å¦‚ä½•æ–°å¢ä¸€å€‹Limiterå‘¢? func NewLimiter(r Limit, b int) *Limiter
ä»–æœ‰2å€‹åƒæ•¸:
r: rateçš„typeæ˜¯Limit(ä¸€å€‹float64çš„å€¼)ï¼Œè¡¨ç¤ºè‘—æ¯ç§’æœƒç”¢ç”Ÿå¤šå°‘å€‹Token,ä¹Ÿå°±æ˜¯æ¯1/rç§’ç”Ÿç”¢1å€‹tokenåˆ°bucketè£¡ b: Token Bucket çš„æ¡¶å­çš„Capacity(å®¹é‡) //r è¨­ç½®100è¡¨ç¤ºæ¯ç§’æœƒç”¢ç”Ÿ100å€‹tokensåˆ°æ¡¶å­è£¡é¢ 1/100 s(1å€‹) //b è¨­ç½®ç‚º1è¡¨ç¤ºæ¡¶å­æœ€å¤šæœ‰1å€‹token limiter := rate.NewLimiter(100,1) Limiterçš„ä½¿ç”¨æ–¹å¼ Limiteræä¾›äº†å¤šå€‹Function: Allow,Reserve,Wait,AllowN,ReserveN,WaitN
æœ€ä¸»è¦ä½¿ç”¨ç‚ºä»¥ä¸‹çš„3å€‹ç¨®Function(éƒ½æœƒæ¶ˆè€—ä¸€å€‹Tokens):
Allow func (lim *Limiter) Allow() bool æ˜¯ AllowN(time.Now(), 1)çš„ç¸®å¯« å®ƒæœƒæ¶ˆè€—æ‰ä¸€å€‹Tokens å¦‚æœæœ‰tokençš„è©±æœƒreturn true å¦è€…æœƒtokenä¸è¶³ return false Reserve func (lim *Limiter) Reserve() *Reservation æ˜¯ ReserveN(time.Now(), 1)çš„ç¸®å¯« æ¯æ¬¡æœƒæ¶ˆè€—æ‰ä¸€å€‹token ä»–ä¸»è¦çš„ä½œç”¨æ˜¯ä¿å­˜eventçš„è³‡è¨Šé ç´„ä¸‹ä¸€æ¬¡çš„æœå‹™ Wait(ç”¨æœ€å¤šçš„function) func (lim *Limiter) Wait(ctx context.Context) (err error) æ˜¯ WaitN(ctx, 1)çš„ç¸®å¯« æ¯æ¬¡æœƒæ¶ˆè€—æ‰ä¸€å€‹token ä¸»è¦çš„ä½œç”¨å°±æ˜¯ç­‰å¾…ç›´åˆ°è¢«å–æ¶ˆæˆ–è€…æœ‰è¶³å¤ çš„Tokens Wait æœƒå µå¡(block)ç›´åˆ°æœ‰è¶³å¤ çš„tokensæ‰æœƒå¾€ä¸‹åŸ·è¡Œ Allow func (lim *Limiter) Allow() bool func (lim *Limiter) AllowN(now time.Time, n int) bool Allow() ç­‰åƒ¹æ–¼(equivalent to) AllowN(time.Now(),1)
AllowNä¸»è¦çš„ä½œç”¨
AllowN è¡¨ç¤ºçš„æ˜¯åœ¨ç›®å‰çš„æ™‚é–“é»ï¼Œæ˜¯å¦èƒ½æ¶ˆè€—nå€‹token,å¦‚bucketå­˜åœ¨nå€‹tokenå‰‡ return true å¦å‰‡ return false
æ˜¯æƒ³è¦Dropæˆ–è€…Skipè¶…érate limitçš„eventsæ™‚ä½¿ç”¨ å¦å‰‡ä½¿ç”¨ Reserve æˆ–è€…Waitå–ä»£ Use this method if you intend to drop / skip events that exceed the rate limit. Otherwise use Reserve or Wait.
//AllowNçš„ä¾‹å­: func AllowDemo() { //each token generated every 100ms with 5 bucket limiter := rate.NewLimiter(rate.Every(time.Microsecond * 100), 5) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ //each time we need 2 tokens if isAllowed := limiter.AllowN(time.Now(), 2); isAllowed { //bucket have enough tokens fmt.Println("Welcome!!!") fmt.Printf("user:%v is allowed in %v\n", counter, time.Now().Format(time.RFC3339)) } else { fmt.Printf("user:%v is not allowed.Please wait for 100ms and try again later\n", counter) //wait for 100ms time.Sleep(100 * time.Microsecond) } } } Reserve func (lim *Limiter) Reserve() *Reservation func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation Reserve() ç­‰åƒ¹æ–¼(equivalent to) ReserveN(time.Now(),1)
ReserveNçš„ä¸»è¦ä½œç”¨
ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
å›å‚³ä¸€å€‹Reservation è¡¨é¢åœ¨eventåŸ·è¡Œå‰éœ€è¦ç­‰å¾…å¤šä¹…ï¼Œé€™å€‹Reservationè¢«limiterç´å…¥è€ƒé‡å…§
å¦‚æœReservation çš„æ‰€éœ€çš„token nè¶…ébucket çš„sizeæ™‚,Reservation çš„OK()æœƒreturn false
//Reserveä¾‹å­: func ReserveDemo() { //each token generated every 200ms and each second will put at most 5 tokens to bucket limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 3) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ tokensNeeds := 2 reserve := limiter.ReserveN(time.Now(), tokensNeeds) if !reserve.OK() { //this event won't be completed due to the tokens its needs fmt.Printf("needed tokens %v is greater than the bucket size %v\n", tokensNeeds, limiter.Burst()) return } //wait for the reversing time fmt.Printf("Wait for %v ms...\n", reserve.Delay()) //if dely is 0 that means no need to wait~ time.Sleep(reserve.Delay()) //at least to wait for 200ms fmt.Printf("waiting is done and now is allowed to deal with some tasks...\n") fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC3339)) } } Wait func (lim *Limiter) Wait(ctx context.Context) (err error) func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) Wait(ctx) ç­‰åƒ¹æ–¼(equivalent to) wait(time.Now(),1)
waitNçš„ä¸»è¦ä½œç”¨
WaitN æ¯æ¬¡éœ€è¦æ¶ˆè€—Nå€‹Tokensï¼Œå¦‚æœBucketæ²’æœ‰è¶³å¤ çš„Bucketæœƒå µå¡ï¼Œç›´åˆ°æœ‰è¶³å¤ çš„Tokens(n)æ‰æœƒç¹¼çºŒå¾€ä¸‹åªéœ€ã€‚é™¤éä»¥ä¸‹æ¢ä»¶æˆç«‹æ‰æœƒå›å‚³éŒ¯èª¤:
æ‰€éœ€æ¶ˆè€—tokens nå¤§æ–¼bucketçš„size Context è¢«å–æ¶ˆ Context å·²ç¶“è¶…éè¨­å®šçš„Deal line(ç­‰å¾…æ™‚é–“è¶…éäº†Deal line) //ä¾‹å­ func WaitDemo() { //at most 5 tokens will generate in a sec 200/1000=5 ctx := context.Background() limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 2) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ if err := limiter.WaitN(ctx, 2); err != nil { fmt.Println("error", err) return } //wait for 2 tokens. At most wait for 400ms fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC1123)) } } è¨­å®šBucket å’Œ Rate å¯é€éfunc (lim *Limiter) SetBurst(newBurst int)è¨­å®š Bucket size
å¯é€éfunc (lim *Limiter) SetLimit(newLimit Limit)è¨­å®š Limit/Rate
åƒè€ƒè³‡æ–™:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Creational-Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> ä»€éº¼æ˜¯Factory(å·¥å» )å‘¢? å®šç¾©:å»ºç«‹ä¸€å€‹æ¥å£,è®“å­é¡è‡ªå·±æ±ºå®šå¯¦ç¾å“ªä¸€å€‹Factory,å…¶é‡é»æ˜¯ç¹¼æ‰¿äº†Simple Factory Patternsçš„å„ªé»,åŒæ™‚è§£æ±ºäº†å®ƒçš„å•é¡Œ
ç°¡å–®ä¾‹å­ æ³¨: ä»¥ä¸‹ç¨‹å¼å–®ç´”ç”¨æ–¼è§£é‡‹ï¼Œä¸¦ä¸èƒ½å¯¦éš›åŸ·è¡Œ
å¯é€éå­é¡ç¹¼æ‰¿Factoryçš„æŠ½è±¡é¡è‡ªä¸»æ±ºå®šç”Ÿç”¢ä»€éº¼æ¨£çš„Productã€‚ ç”Ÿç”¢çš„Productåœ¨é€éé‡Œæ°æ›¿æ›åŸå‰‡(Lisko Subsititution princeple)æ›¿æ›æˆç¹¼æ‰¿èˆ‡Loggerçš„å­é¡ï¼Œå³å¯æ›æˆçš„éœ€è¦çš„Loggerã€‚ class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //ä¸å¯ä»¥æ˜¯Staticéœæ…‹ï¼Œå› ç‚ºå­é¡æ˜¯å‹•æ…‹å¯¦ç¾çˆ¶é¡çš„å‡½æ•¸(static æ²’æœ‰thisæŒ‡æ¨™) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc... Logger* logger = new DatabaseLogger(); //init this logger etc... return logger } } //Client to use int main(){ Factory *factory = new FileLoggerFactory(); Logger *logger = factory->createLogger(); //return the Product that it is initialized Logger->wirteLog(); return; //å¦‚æœæƒ³è®“ç³»çµ±æœ‰æ›´å¤šéˆæ´»æ€§å’Œèª²æ“´å±•æ€§ï¼Œå¯ä»¥é€éxmlä¾†é€²è¡Œé…ç½®ï¼Œä¸éœ€é€éä¿®éclientçš„ä»£ç¢¼ //åªéœ€æ›´æ–°xmlä¸­çš„è¨­ç½®ï¼Œåœ¨ä»£ç¢¼ä¸­æ–°å¢æ–°çš„Product ä»¥åŠæ–°å¢çš„Factory ä¸¦é‡æ–°ç·¨è­¯ä¾¿å¯ //é™¤äº†é»˜èªçš„è¨­ç½®æ–¹æ³•å¤–ï¼Œé‚„æƒ³é€éå‚³å…¥Stringçš„æ–¹æ³•ä¾†è‡ªå®šç¾©è¨­è¨ˆï¼Œä¾‹å¦‚é€£æ¥è¦DBï¼Œæ–‡ä»¶çš„è·¯å¾‘ç­‰ç­‰ //å¯ä»¥é€éOverride Abstruct class çš„funcä¾†é€²è¡Œè¨­ç½® /* class Factory{ public: virtual Logger* createLogger() = 0; virtual Logger* createLogger(string config) = 0; virtual Logger* createLogger(Object obj) = 0;//é€šéObjè£¡é¢çš„æˆå“¡é€²è¡Œè¨­ç½®ç­‰ } */ } å„ªé» Clientç„¡éœ€çŸ¥é“Objectçš„è¨­ç½®çš„ç´°ç¯€ï¼Œä¹Ÿç„¡éœ€çŸ¥é“å¯¦è³ªObjectçš„åç¨±ï¼Œåªéœ€é€šéå·¥å» å³å¯ å·¥å» (Factory)ä»¥åŠç”¢å“(Product)éƒ½æ˜¯é€éPolymorphism(å¤šæ…‹)ä¾†å¯¦ç¾ï¼Œä¹Ÿæ˜¯å·¥å» æ¨¡å¼çš„é—œéµï¼Œå·¥å» å¯ä»¥è‡ªä¸»çš„æ±ºå®šè¦ç”Ÿç”¢ä»€éº¼ç”¢å“ï¼Œåœ¨å…§éƒ¨é€²è¡Œè¨­ç½®ç”¢å“(å°è£åœ¨å…§éƒ¨) åŠ å…¥æ–°çš„Productæ™‚ç„¡éœ€ä¿®æ”¹Abstract class ä»¥åŠ å…·é«”çš„å·¥å» å’Œç”¢å“çš„é¡ï¼Œåªè¦æ“´å±•æ–°å¢å³å¯ï¼Œç¬¦åˆOpen-Close principle é€éç¹¼æ‰¿æŠ½è±¡é¡ä½¿ç³»çµ±æ›´å®¹æ˜“æ“´å±• ç¼ºé» æ–°å¢ç”¢å“æ™‚ï¼Œè¦åŠ å…¥æ–°çš„ç”¢å“é¡ä»¥åŠå·¥å» é¡ï¼Œå¢åŠ äº†ç³»çµ±çš„è¤‡é›œåº¦ï¼Œè€Œä¸”éœ€è¦å¾æ–°ç·¨è­¯ï¼Œå¢åŠ äº†é–‹éŠ· ç‚ºäº†æ“´å±•æ€§,åŠ å…¥äº†æŠ½è±¡é¡ï¼ŒClientéƒ½ä½¿ç”¨Abstract class é€²è¡Œç·¨ç¨‹ï¼Œå¢åŠ äº†ç³»çµ±çš„æŠ½è±¡æ€§å’Œç†è§£é›£åº¦ åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Note]Creational-Simple Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-simple-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> ä»€éº¼æ˜¯Simple Factory(ç°¡å–®å·¥å» )å‘¢? ç°¡å–®è€Œè¨€å°±æ˜¯: ç”±ä¸€å€‹å·¥å» ä¾†ç”Ÿç”¢å…¨éƒ¨ç”¢å“ å®šç¾©:å»ºç«‹ä¸€å€‹æ¥å£,è®“å­é¡è‡ªå·±æ±ºå®šå¯¦ç¾å“ªä¸€å€‹Factory,é‡é»åœ¨æ–¼å·¥å» ï¼Œé€éå·¥å» çš„Static method é€²è¡Œç”Ÿæˆçš„Object
ç°¡å–®ä¾‹å­ æ³¨: ä»¥ä¸‹ç¨‹å¼å–®ç´”ç”¨æ–¼è§£é‡‹ï¼Œä¸¦ä¸èƒ½å¯¦éš›åŸ·è¡Œ
é€éFactory é¡çš„Static æ–¹æ³•èª¿ç”¨æ–¹æ³•ï¼Œå‚³å…¥åƒæ•¸ç”Ÿæˆç›¸é—œçš„Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == "A"){ return new ProductA(); } else if(type == "B"){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct("A"); //get ProductA instance Product* B = Factory::getProduct("B"); //get ProductB instance } å„ªé» Clientå¯ä»¥è‡ªè¡Œæ±ºå®šç”Ÿç”¢å“ªå€‹Product Clientå…é™¤ç›´æ¥å»ºç«‹Productçš„è²¬ä»»ï¼Œåªåƒ…åƒ…æ¶ˆè²»ç”¢å“ Clientç„¡éœ€é—œå¿ƒå…·é«”çš„é¡åèˆ‡ç›¸é—œè¨­ç½®åƒæ•¸ ç¼ºé» Factory çš„è·è²¬å¤ªé‡ã€‚æ‰€æœ‰çš„Product éƒ½ç”±ä¸€å€‹Object ç”Ÿç”¢ï¼Œä¸€æ—¦ä¸èƒ½æ­£å¸¸å·¥ä½œï¼Œä¾¿æœƒå½±éŸ¿æ•´å€‹ç³»çµ±çš„é‹ä½œ å¦‚æœ‰ä¸åŒçš„Productæœƒå¢åŠ ç³»çµ±ä¸­çš„classçš„æ•¸ç›®ï¼Œå¢åŠ äº†ç³»çµ±è¤‡é›œåº¦ä»¥åŠç†è§£é›£åº¦ æ“´å±•ååˆ†å›°é›£ï¼Œæ·»åŠ éœ€è¦ä¿®æ”¹Factoryçš„é‚è¼¯ã€‚å¦‚æœç”Ÿå­˜çš„Productè¼ƒå¤šæ™‚ï¼Œå¯èƒ½æœƒä½¿å…¶é‚è¼¯éæ–¼è¤‡é›œï¼Œä¸åˆ©æ–¼ç³»çµ±çš„æ“´å±•èˆ‡ç¶­è­· é•èƒŒåŸå‰‡ é•èƒŒäº†Open-Close Principe å¦‚æœæœ‰æ–°çš„Product éœ€è¦ç”Ÿæˆï¼Œå°±å¿…ä¿®è¦ä¿®æ”¹Factoryé¡ åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Note]Design Pattern Princeple</title><url>https://ryantokmanmokmtm.github.io/post/design-pattern-princeple/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>learning</tag><tag>note</tag></tags><content type="html"> ä»€éº¼æ˜¯Design Pattern(è¨­è¨ˆæ¨¡å¼)å‘¢? è¨­è¨ˆæ¨¡å¼(Design Pattern) æ˜¯å°è»Ÿé«”è¨­è¨ˆä¸­æ™®éå­˜åœ¨ï¼ˆåè¦†å‡ºç¾ï¼‰çš„å„ç¨®å•é¡Œï¼Œæ‰€æå‡ºçš„è§£æ±ºæ–¹æ¡ˆã€‚ç”¨æ–¼æè¿°åœ¨å„ç¨®ä¸åŒçš„æƒ…æ³ä¸‹ï¼Œå¦‚ä½•è§£æ±ºå•é¡Œçš„ä¸€ç¨®æ–¹æ¡ˆ
OOPè¨­è¨ˆæ¨¡å¼é€šå¸¸ä»¥é¡åˆ¥æˆ–è€…ç‰©ä»¶ä¾†æè¿°é—œä¿‚å’Œç›¸äº’çš„ä½œç”¨(ä¸æ¶‰åŠå®Œæˆæ‡‰ç”¨çš„ç‰¹å®šobject)ã€‚ è¨­è¨ˆæ¨¡å¼èƒ½ä½¿ä¸ç©©å®šä¾è³´æ–¼ç›¸å°ç©©å®šã€å…·é«”ä¾è³´æ–¼ç›¸å°æŠ½è±¡ï¼Œé¿å…æœƒå¼•èµ·éº»ç…©çš„ç·Šè€¦åˆã€‚
Design Pattern æœ‰ä»€éº¼åŸå‰‡å‘¢? åŸå‰‡(Princeple) å®šç¾©(Def) å–®ä¸€è·è²¬åŸå‰‡(Single Responsibility Principle) ä¸€å€‹é¡åªè² è²¬ä¸€å€‹åŠŸèƒ½é ˜åŸŸä¸­çš„ç›¸æ‡‰çš„åŸå‰‡ é–‹é–‰åŸå‰‡(Open-Closed Principle) å°æ“´å±•é–‹ç™¼(å¯ä»¥ç¹¼æ‰¿æ“´å±•)ï¼Œå°ä¿®æ”¹é—œé–‰(ä¸èƒ½ä¿®æ”¹BaseClass) é‡Œæ°æ›¿æ›åŸå‰‡(Liskov Substitution Principe) æ‰€æœ‰å¼•ç”¨æ–¼Base Class çš„åœ°æ–¹ éƒ½èƒ½å¤ é€æ˜çš„ä½¿ç”¨å…¶å­é¡çš„å°è±¡(ä»¥å­é¡ä¾†æ›¿æ›çˆ¶é¡) ä¾è³´å€’è½‰åŸå‰‡(Dependencie Inversion Principe ç´°ç¯€æ‡‰ä¾è³´æ–¼æŠ½è±¡(Abstract),æŠ½è±¡(Abstract)ä¸æ‡‰è©²ä¾è³´èˆ‡ç´°ç¯€ã€‚(ä¹Ÿå°±æ˜¯ç´°ç¯€ç”±å­é¡ä¾†å¯¦ç¾ï¼Œçˆ¶é¡è² è²¬å®šç¾©) æ¥å£éš”é›¢åŸå‰‡(Interface Segregation Principle) ä½¿ç”¨å¤šå€‹å°ˆç”¨çš„æ¥å£(Interface),è€Œä¸æ˜¯ä½¿ç”¨å–®ä¸€çš„ç¸½æ¥å£.(èƒ½é¿å…Clientå¯¦ç¾ä¸€äº›æ²’å¿…è¦çš„åŠŸèƒ½) åˆæˆè¤‡ç”¨åŸå‰‡(Composition Reuse Principle) ç›¡é‡ä½¿ç”¨Object Composition(åœ¨è¦ä½¿ç”¨çš„Objectçš„åœ°æ–¹æŠŠç”¨åˆ°çš„Objectæ³¨å…¥),è€Œä¸æ˜¯ç¹¼æ‰¿èƒ½é”åˆ°ç›®çš„.(æ¸›å°‘ä¾è³´) è¿ªç±³ç‰¹æ³•å‰‡(Law of Demeter) ä¸€å€‹è»Ÿä»¶å¯¦é«”æ‡‰ç›¡å¯èƒ½åœ°èˆ‡å…¶ä»–å¯¦é«”ç™¼ç”Ÿäº’ç›¸ä½œç”¨.(å°±æ˜¯ä¸ç”¨è·Ÿä¸æ˜¯æœ‹å‹(æ³¨å…¥)çš„Object ç›´æ¥é€šè¨Š) Design Pattern åˆ†æˆå“ªå¹¾ç¨®å‘¢? ä¸»è¦åˆ†æˆ3å¤§é¡ï¼Œä¸€å…±23å€‹
å‰µå»ºå‹æ¨¡å¼(6å€‹) çµæ§‹å‹æ¨¡å¼(7å€‹) è¡Œç‚ºå‹æ¨¡å¼(11å€‹) å‰µå»ºå‹æ¨¡å¼(6å€‹) ç°¡å–®å·¥å» æ¨¡å¼(Simple Factory Pattern) å·¥å» æ¨¡å¼(Factory Pattern) æŠ½è±¡å·¥å» æ¨¡å¼(Abstract Factory Pattern) å–®ä¾‹æ¨¡å¼(Singleton Pattern) åŸå½¢æ¨¡å¼(Prototype Pattern) å»ºç«‹è€…æ¨¡å¼(Builder Pattern) çµæ§‹å‹æ¨¡å¼(7å€‹) é©é…å™¨æ¨¡å¼(Adapter Pattern) æ©‹æ¥æ¨¡å¼(Bridge Pattern) çµ„åˆæ¨¡å¼(Composite Pattern) è£é£¾æ¨¡å¼(Decorator Pattern) å¤–è§€æ¨¡å¼(Facade Pattern) äº«å…ƒæ¨¡å¼(FlayWeight Pattern) ä»£ç†æ¨¡å¼(Proxy Pattern) è¡Œç‚ºå‹æ¨¡å¼(11å€‹) è·è²¬éˆæ¨¡å¼(Chain of Responsibility Pattern) å‘½ä»¤æ¨¡å¼(Command Pattern) è§£é‡‹å™¨æ¨¡å¼(Interpreter Pattern) è¿­ä»£å™¨æ¨¡å¼(Iterator Pattern) ä¸­ä»‹è€…æ¨¡å¼(Mediator Pattern) å‚™å¿˜éŒ„æ¨¡å¼(Memento Pattern) è§€å¯Ÿè€…æ¨¡å¼(Observer Pattern) ç‹€æ…‹æ¨¡å¼(State Pattern) ç­–ç•¥æ¨¡å¼(Strategy Pattern) æ¿å¡Šæ¨¡å¼(Template Method Pattern) è¨ªå•è€…æ¨¡å¼(Visitor Pattern) åƒè€ƒè³‡æ–™:
å²ä¸Šæœ€å…¨è®¾è®¡æ¨¡å¼å¯¼å­¦ç›®å½•ï¼ˆå®Œæ•´ç‰ˆï¼‰</content></entry><entry><title>[Note]What Is JWT(Json Web Token)-EN</title><url>https://ryantokmanmokmtm.github.io/post/jwt-note/</url><categories><category>backend</category><category>development</category><category>web develpment</category><category>note</category><category>english</category></categories><tags><tag>web develpment</tag><tag>token</tag></tags><content type="html"> What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:
Header Payload Signature JWT Header Header typically consists of two parts
type : what&rsquo;s the type of the token algorithm : what algorithm does this token use to sign/encrypt. such as SHA256,RAS or HMAC { "typ" : "jwt", "alg" : "HS256" } This information will be encoded by base64Url algorithm in order to generate the JWT Header
JWT payload In payload is typically saving some users information and other useful information.
Be carefulthat payload must not include any secret information due to base64Url algorithm is easy to be decrypted.
JWT Payload standard claims
{ "sub" :"",//subject "aud" :"",//audience "jti" :"",//jwt id "iat" :"",//Issued at "iss" :"",//Issuer - who is the publisher of the jwt "nbf" :"",//Not Before - JWT is not available before the time jwt set. // other user information that developer set //for example: "user_name" : "jackson_tmm", "email" : "admin@admin.com" } This information will be encoded by base64Url algorithm in order to generate the JWT Payload
Signature The Signature is used to authenticate whether information has been modified during transmission and authenticate the sender that sent this JWT.
To Generate JWT Token Following this function
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), your-256-bit-secret) And these three partes will be combined by a . as following format: xxx.yyy.zzz
//exmaple eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ How it work between Client and server sequenceDiagram Client-Server:POST /authentication {username:xxx..} Note over Client,Server: User logs in alt is authenticated Server-Client:HTTP Status:200 {"token":eyxxx.xx.x} Note over Server,Client: Loged in Succeed else Unauthorized Server-Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Loged in Failed end Client-Server: POST /user/profile {"Authorization":"Bear token"} Note over Server,Client: Get User Profile with token alt succeed Server--Client: HTTP Status:200 {"profile":eyxxx.xx.x} Note over Server,Client: Succeed and response a profile else Unauthorized Server--Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Unauthorized(token error) end</content></entry><entry><title>[CGU]Graduation Project</title><url>https://ryantokmanmokmtm.github.io/project/final-project/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> OTT Movies recommender system-IOS Client
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database Demo Video
In Progress User chatting UI User profile Demo(åƒè€ƒå°ç´…æ›¸)</content></entry><entry><title>About me</title><url>https://ryantokmanmokmtm.github.io/about.html</url><categories/><tags/><content type="html"> å€‹äººç°¡æ­· Introduction ä½ å¥½~ æ­¡è¿ä¾†åˆ°æˆ‘çš„ç¶²ç«™!
æˆ‘æ˜¯Jackson.tmm, æ˜¯ä¸€å€‹å¾é¦™æ¸¯ä¾†åˆ°å°ç£è®€å¤§å­¸çš„å››å¹´ç´šå­¸ç”Ÿã€‚ç›®å‰å°±è®€æ–¼é•·åºšå¤§å­¸-è³‡è¨Šå·¥ç¨‹å­¸ç³»(Computer Science And Information Engineering)ã€‚
More About me æˆ‘è¶…å–œæ­¡TFBoyçš„ï¼Œæ˜¯TFBoysçš„å¿ å¯¦ç²‰çµ²,ç‰¹åˆ¥æ˜¯æ˜“çƒŠåƒç’½(Jackson yee)ï¼ï¼ï¼æˆ‘å«Jacksonä¹Ÿæ˜¯é€™å€‹åŸå› ï¼Œæƒ³è·Ÿåƒç’½ä¸€æ¨£å¼·ï¼å“ˆå“ˆå“ˆã€‚å¾ä»–å€‘å‡ºé“é–‹å§‹å°±é–‹å§‹å–œæ­¡ä»–å€‘äº†(æ‡‰è©²å¿«9å¹´äº†)ã€‚
é™¤äº†å¯«ç¨‹å¼ä»¥å¤–ï¼Œæˆ‘ä¹Ÿå–œæ­¡è¨­è¨ˆè·ŸéŸ³æ¨‚ï¼ä½ æ²’çœ‹éŒ¯ï¼Œæˆ‘ä¸€å€‹å¾Œç«¯å–œæ­¡è¨­è¨ˆï¼Œå“ˆå“ˆå“ˆå“ˆ(ä¸è¦å•æˆ‘ç‚ºä»€éº¼ä¸é¸å‰ç«¯ï¼Œå“ˆå“ˆå“ˆ)
Why i choose Computer Science? è¦å¾æˆ‘å°æ™‚å€™ç²å¾—äº†ä¸€å°å–®æ ¸å¿ƒCPU,512MB RAM,é‚„æ²’æœ‰DisplayCardçš„é›»è…¦é–‹å§‹èªªèµ·(é›–ç„¶å¾ˆçˆ›)ã€‚å“ªå€‹æ™‚å€™å› ç‚ºå–œæ­¡ç©éŠæˆ²ï¼Œæ‰€ä»¥,å°æ–¼éŠæˆ²è£½ä½œé€™ä»¶äº‹æ˜¯å“ªæ™‚å€™çš„å¤¢æƒ³ã€‚ç›´åˆ°äº†ä¸­å­¸(å¤§æ¦‚æ˜¯åœ‹ä¸€æˆ–åœ‹äºŒ)ï¼Œå› æŸæŸç¶²çµ¡éŠæˆ²é—œæœï¼Œä½†å»å°æ­¤å¿ƒæœ‰ä¸ç”˜ã€‚æ‰€ä»¥ï¼Œä¾¿èˆ‡ç¶²çµ¡ä¸Šèªè­˜çš„å°å¤¥ä¼´ä¸€èµ·ç ”ç©¶æ”¾å‡ºä¾†çš„æºä»£ç¢¼(é›–ç„¶çœ‹ä¸å¤ªæ‡‚)ï¼Œé€™ä¹Ÿæ˜¯æˆ‘æ¥è§¸ç¨‹å¼çš„é–‹å§‹ã€‚åˆ°äº†é«˜ä¸­æˆ‘ä¾¿ä¸€å¿ƒæƒ³è¦å¾€Computer Scienceæ–¹å‘å‰é€²ï¼Œä¹Ÿå› æ­¤é¸æ“‡äº†Information Computer Technology(ICT)ç§‘ç›®ã€‚é›–ç„¶æˆ‘å…¶ä»–ç§‘ç›®çš„æˆç¸¾æ²’æœ‰å¾ˆå¥½ï¼Œä½†æ˜¯åœ¨ICTçš„é€™é–€ç§‘ä¸­ï¼Œé€£çºŒæ‹¿äº†3å¹´çš„ç¬¬ä¸€åã€‚ä½†æ˜¯å› ç‚ºé«˜è€ƒå¤±åˆ©ï¼Œä½†åˆå¸Œæœ›è‡ªå·±èƒ½å­¸ç¿’åˆ°CSç›¸é—œçš„ç§‘ç›®ï¼Œå› æ­¤ä¾†åˆ°äº†å°ç£å°±è®€CSç§‘ç³»ã€‚
A special and meaningful experience during my university ä¸Šå¤§å­¸ä»¥å¾Œï¼Œä¹Ÿæ˜¯æ­£å¼é–‹å§‹å­¸ç¿’ç¨‹å¼è¨­è¨ˆçš„é–‹å§‹ã€‚å¯èƒ½æ˜¯ä»¥å‰æœ‰è‡ªå­¸éä¸€æ®µæ™‚é–“C++ï¼Œå­¸èµ·ä¾†æ¯”è¼ƒè¼•é¬†ä¸€é»ã€‚å¤§äºŒä¸‹çš„æ™‚å€™ï¼Œå¾ˆä¸è¾›COVIN-19ç–«æƒ…çˆ†ç™¼ï¼Œä¸èƒ½æœƒå°ç£åªèƒ½ç•™åœ¨é¦™æ¸¯ä¸Šç¶²çµ¡èª²ç¨‹ï¼Œå› æ­¤ï¼Œä¾¿é–‹å§‹äº†æˆ‘çš„è‡ªå­¸ä¹‹è·¯ã€‚ç”±æ–¼æœ‰äº†å­¸ç¿’C++çš„ç¶“é©—ä»¥åŠç¨‹å¼èªè¨€çš„åŸºç¤ï¼Œä¾¿é–‹å§‹è‡ªæˆ‘æ¢ç´¢æ¨¡å¼ï¼Œå˜—è©¦æ¥è§¸ä¸åŒçš„é ˜åŸŸã€‚äº†è§£éç¶²é è¨­è¨ˆ,å¾Œç«¯é–‹ç™¼,æ•¸æ“šåº«è¨­è¨ˆ,Apple Appé–‹ç™¼,ML/TensorFlowåŸºç¤,ç”šè‡³æ˜¯å…¶ä»–é ˜åŸŸçš„æ¢ç´¢å¦‚éŠæˆ²é–‹ç™¼ï¼Œç¾è¡“è¨­è¨ˆï¼Œ3Då»ºæ¨¡ç­‰ç­‰&hellip;é€™æ®µè‡ªå­¸æ¢ç´¢çš„æ—…ç¨‹,è²Œä¼¼çœ‹ä¸Šå»æ¯«ç„¡æ„ç¾©(ä¹Ÿå°±æ˜¯å•¥éƒ½å­¸ï¼Œæ²’æœ‰ä¸€å€‹æ˜¯ç²¾çš„)ã€‚ä½†æ˜¯ï¼Œå°æˆ‘ä¾†èªªæœ‰å·¨å¤§çš„æ„ç¾©ï¼Œèƒ½å¤ è®“æˆ‘æ›´èªè­˜è‡ªå·±ï¼ŒçŸ¥é“è‡ªå·±å–œæ­¡çš„æ±è¥¿ï¼Œä¸å–œæ­¡çš„æ±è¥¿ï¼Œç”šè‡³æ˜¯çŸ¥é“å“ªäº›å­¸ç¿’æ–¹æ³•æ˜¯é©åˆè‡ªå·±ã€‚é›–ç„¶å¾ˆæƒ³ä»€éº¼éƒ½æƒ³è¦æœƒï¼Œä½†æ˜¯ä¹Ÿæ±ºå®šäº†åªåšè‡ªå·±æ„Ÿèˆˆè¶£çš„äº‹æƒ…ã€‚ä»¥ä¸‹æ˜¯æˆ‘åœ¨é€™æ®µæ™‚é–“æ‰€åšçš„æ±è¥¿(ä½ å€‘æ‡‰è©²ä¸æœƒå«Œæ£„å§>&lt;)
ç¬¬ä¸€æ¬¡å­¸ç¿’IOSé–‹ç™¼çš„Demo åŸºæ–¼IOSçš„Netfilx UI Clone åŸºæ–¼IOSçš„å¾®åšUI Clone ç¬¬ä¸€æ¬¡å­¸éŠæˆ²é–‹ç™¼çš„ä½œå“ ç¬¬ä¸€æ¬¡å­¸å»ºæ¨¡çš„ä½œå“ é€çµ¦è‡ªå·±20æ­²çš„ç”Ÿæ—¥ç¦®ç‰©çš„ä¸€é¡†æ’çƒæ¨¡å‹ æ¨¡æ“¬æ°´é‚„æ˜¯å¾ˆå¥½ç©çš„(æ¸²æŸ“äº†12å°æ™‚ (â—‘â€¿â—) ) ç‡ˆç± é­š(Lophiiformes)ä½œå“ ç¬¬ä¸€æ¬¡ç¶²çµ¡èª²å­¸ç¿’å»ºæ¨¡çš„ä½œæ¥­ ç¬¬ä¸€æ¬¡ç¶²çµ¡èª²å­¸ç¿’å»ºæ¨¡çš„çµèª²ä½œå“(é‚„æ²’ä¸Šè²¼åœ–>&lt;,æœ‰ç©ºå°±ä¸Š) Interest è·‘æ­¥ï¼Œæ‰“çƒï¼Œèªªå”±ï¼Œå”±æ­Œï¼Œçœ‹é›»å½±ï¼Œçœ‹å‹•æ¼« éŠæˆ²è¨­è¨ˆï¼ŒéŠæˆ²ç¾è¡“ï¼Œ3Då»ºæ¨¡ æè¨­è¨ˆï¼Œå¯«ç¨‹å¼ è·Ÿæœ‹å‹åˆ†äº«ã€äº¤æµ ç‰¹åˆ¥å–œæ­¡å®‡å®™/äººé¡èµ·æºç›¸é—œçš„å¥‡æ€ªçŸ¥è­˜ Current Plan å­¸æ›´å¤šæœ‰é—œå¾Œç«¯é–‹ç™¼ï¼Œç³»çµ±è¨­è¨ˆç›¸é—œçš„æŠ€è¡“ å­¸å¥½è‹±æ–‡(çœ‹é›»å½±ä¸è¦çœ‹å­—å¹•ï¼Œèƒ½æ›´å¤–åœ‹äººäº¤æµçš„ç¨‹åº¦) è€ƒå¥½é›…æ€ åšå¥½è‡ªå·±,ä¸æ¯”è¼ƒ,ä½†ä¸€èµ·å­¸ç¿’ä¸€èµ·é€²æ­¥ Contact Me: Email @Jacksontmm in Telegram</content></entry></search>