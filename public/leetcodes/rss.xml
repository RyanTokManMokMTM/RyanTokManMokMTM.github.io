<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcodes on Jackson.tmm</title><link>http://localhost:1313/leetcodes/</link><description>Recent content in Leetcodes on Jackson.tmm</description><generator>Hugo</generator><language>zh-tw</language><lastBuildDate>Thu, 18 May 2023 15:44:17 +0800</lastBuildDate><atom:link href="http://localhost:1313/leetcodes/rss.xml" rel="self" type="application/rss+xml"/><item><title>[Leetcode] Maximum Twin Sum of a Linked List(M)</title><link>http://localhost:1313/leetcodes/leetcode2130/</link><pubDate>Thu, 18 May 2023 15:44:17 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode2130/</guid><description>&lt;h2 id="leetcode-2130---maximum-twin-sum-of-a-linked-list"&gt;LeetCode 2130 - Maximum Twin Sum of a Linked List
&lt;a class="header-anchor" href="#leetcode-2130---maximum-twin-sum-of-a-linked-list"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &amp;lt;= i &amp;lt;= (n / 2) - 1.&lt;/p&gt;
&lt;p&gt;For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.
The twin sum is defined as the sum of a node and its twin.
Given the head of a linked list with even length, return the maximum twin sum of the linked list.&lt;/p&gt;</description></item><item><title>[Leetcode] Maximum Length of Repeated Subarray(Medium)</title><link>http://localhost:1313/leetcodes/leetcode718/</link><pubDate>Tue, 20 Sep 2022 14:47:44 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode718/</guid><description>&lt;h2 id="leetcode-718---maximum-length-of-repeated-subarray"&gt;LeetCode 718 - Maximum Length of Repeated Subarray
&lt;a class="header-anchor" href="#leetcode-718---maximum-length-of-repeated-subarray"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given two integer arrays ``nums1&lt;code&gt;and&lt;/code&gt;nums2`, return the maximum length of a subarray that appears in both arrays.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 3
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: The repeated subarray with maximum length is [3,2,1].&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 5&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題要我們找出2個&lt;code&gt;array&lt;/code&gt;中最長的相同&lt;code&gt;subarray&lt;/code&gt;。這題有點類似於
&lt;a href="http://localhost:1313/notes/lcm" title="最長公共子序列" &gt;
 最長公共子序列
 
&lt;/a&gt;,但是不同的是&lt;code&gt;子序列&lt;/code&gt;不一樣的&lt;strong&gt;連續的&lt;/strong&gt;,而&lt;code&gt;subarray&lt;/code&gt;是必須要&lt;strong&gt;連續的&lt;/strong&gt;。哪我們只需要改寫一下&lt;code&gt;最長公共子序列&lt;/code&gt;,我們只需要更新&lt;strong&gt;相等&lt;/strong&gt;的元素即可。其餘的都不需要關心。&lt;/p&gt;</description></item><item><title>[Leetcode] Find Duplicate File in System(Medium)</title><link>http://localhost:1313/leetcodes/leetcode609/</link><pubDate>Mon, 19 Sep 2022 14:41:56 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode609/</guid><description>&lt;h2 id="leetcode-42---trapping-rain-water"&gt;LeetCode 42 - Trapping Rain Water
&lt;a class="header-anchor" href="#leetcode-42---trapping-rain-water"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given a list &lt;code&gt;paths&lt;/code&gt; of directory info, including the directory path, and all the files with contents in this directory, return &lt;em&gt;all the duplicate files in the file system in terms of their paths&lt;/em&gt;. You may return the answer in &lt;strong&gt;any order&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A group of duplicate files consists of at least two files that have the same content.&lt;/p&gt;
&lt;p&gt;A single directory info string in the input list has the following format:&lt;/p&gt;</description></item><item><title>[Leetcode] Trapping Rain Water(Hard)</title><link>http://localhost:1313/leetcodes/leetcode42/</link><pubDate>Sun, 18 Sep 2022 14:29:08 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode42/</guid><description>&lt;h2 id="leetcode-42---trapping-rain-water"&gt;LeetCode 42 - Trapping Rain Water
&lt;a class="header-anchor" href="#leetcode-42---trapping-rain-water"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given &lt;code&gt;n&lt;/code&gt; non-negative integers representing an elevation map where the width of each bar is &lt;code&gt;1&lt;/code&gt;, compute how much water it can trap after raining.
example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 6
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: height = [4,2,0,3,2,5]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 9&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題是給定一個&lt;code&gt;array&lt;/code&gt;代表著&lt;strong&gt;高度&lt;/strong&gt;，問我們一共可以裝多少水。這題的解題思路，假設當前是&lt;code&gt;i&lt;/code&gt;,那我當前這個&lt;code&gt;i&lt;/code&gt;是否可以裝水呢？我們是是不是要知道&lt;code&gt;i&lt;/code&gt;的左手邊的最高的柱子(&lt;code&gt;x&lt;/code&gt;)和最右手邊的最高的柱子(&lt;code&gt;y&lt;/code&gt;)，那跟柱子比較矮而且是不是大於現在這個&lt;code&gt;i&lt;/code&gt;。假設&lt;code&gt;IFF x &amp;lt; y &amp;amp;&amp;amp; x &amp;gt; i&lt;/code&gt;,哪&lt;code&gt;i&lt;/code&gt;可以裝的水就會是&lt;code&gt;x - i&lt;/code&gt;那麼多。所以說，我們必須要知道當前&lt;code&gt;i&lt;/code&gt;的左邊最高和&lt;code&gt;i&lt;/code&gt;的右邊最高是多少。哪要怎麼做呢？我們可以透過預處理的方式，預先計算左手邊(&lt;code&gt;i之前&lt;/code&gt;)最大值以及右手邊(&lt;code&gt;i之後&lt;/code&gt;)的最大值，然後在根據以上的方法即可解出答案。&lt;/p&gt;</description></item><item><title>[Leetcode] Palindrome Pairs(Hard)</title><link>http://localhost:1313/leetcodes/leetcode336/</link><pubDate>Sat, 17 Sep 2022 20:41:48 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode336/</guid><description>&lt;h2 id="leetcode-336---palindrome-pairs"&gt;LeetCode 336 - Palindrome Pairs
&lt;a class="header-anchor" href="#leetcode-336---palindrome-pairs"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given a list of &lt;strong&gt;unique&lt;/strong&gt; words, return all the pairs of the &lt;em&gt;&lt;strong&gt;distinct&lt;/strong&gt;&lt;/em&gt; indices &lt;code&gt;(i, j)&lt;/code&gt; in the given list, so that the concatenation of the two words &lt;code&gt;words[i] + words[j]&lt;/code&gt; is a palindrome.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: words = [&amp;#34;abcd&amp;#34;,&amp;#34;dcba&amp;#34;,&amp;#34;lls&amp;#34;,&amp;#34;s&amp;#34;,&amp;#34;sssll&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [[0,1],[1,0],[3,2],[2,4]]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: The palindromes are [&amp;#34;dcbaabcd&amp;#34;,&amp;#34;abcddcba&amp;#34;,&amp;#34;slls&amp;#34;,&amp;#34;llssssll&amp;#34;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: words = [&amp;#34;bat&amp;#34;,&amp;#34;tab&amp;#34;,&amp;#34;cat&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [[0,1],[1,0]]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: The palindromes are [&amp;#34;battab&amp;#34;,&amp;#34;tabbat&amp;#34;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;在解這題之前我們先要知道有哪些情況是成立Palindrome。&lt;/p&gt;</description></item><item><title>[Leetcode] Maximum Score from Performing Multiplication Operations(Medium)</title><link>http://localhost:1313/leetcodes/leetcode1770/</link><pubDate>Fri, 16 Sep 2022 20:42:00 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode1770/</guid><description>&lt;h2 id="leetcode-1770---maximum-score-from-performing-multiplication-operations"&gt;LeetCode 1770 - Maximum Score from Performing Multiplication Operations
&lt;a class="header-anchor" href="#leetcode-1770---maximum-score-from-performing-multiplication-operations"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are given two integer arrays &lt;code&gt;nums&lt;/code&gt; and &lt;code&gt;multipliers&lt;/code&gt; of size &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; respectively, where &lt;code&gt;n &amp;gt;= m&lt;/code&gt;. The arrays are &lt;strong&gt;1-indexed&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;You begin with a score of &lt;code&gt;0&lt;/code&gt;. You want to perform &lt;strong&gt;exactly&lt;/strong&gt; &lt;code&gt;m&lt;/code&gt; operations. On the &lt;code&gt;ith&lt;/code&gt; operation (&lt;strong&gt;1-indexed&lt;/strong&gt;), you will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Choose one integer &lt;code&gt;x&lt;/code&gt; from &lt;strong&gt;either the start or the end&lt;/strong&gt; of the array &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add &lt;code&gt;multipliers[i] * &lt;/code&gt;x` to your score.&lt;/li&gt;
&lt;li&gt;Remove x from the array &lt;code&gt;nums&lt;/code&gt;.
Return the maximum score after performing m operations.
example&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-6"&gt;&lt;a class="lnlinks" href="#hl-0-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-7"&gt;&lt;a class="lnlinks" href="#hl-0-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [1,2,3], multipliers = [3,2,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 14
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: An optimal solution is as follows:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Choose from the end, [1], adding 1 * 1 = 1 to the score.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;The total score is 9 + 4 + 1 = 14.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-4"&gt;&lt;a class="lnlinks" href="#hl-1-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-5"&gt;&lt;a class="lnlinks" href="#hl-1-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-6"&gt;&lt;a class="lnlinks" href="#hl-1-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-7"&gt;&lt;a class="lnlinks" href="#hl-1-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-8"&gt;&lt;a class="lnlinks" href="#hl-1-8"&gt;8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-9"&gt;&lt;a class="lnlinks" href="#hl-1-9"&gt;9&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 102
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: An optimal solution is as follows:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;The total score is 50 + 15 - 9 + 4 + 42 = 102.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題最主要的重點是對於每個&lt;code&gt;multipliers[i]&lt;/code&gt;,它只能挑選最左邊或者最右邊的值。所有，我們需要知道&lt;code&gt;multipliers[i]&lt;/code&gt;拿最左邊的值最後的結果比較大，還是拿最右邊後的結果比較大。為了避免重複計算而超時，所以我們需要使用&lt;code&gt;dp&lt;/code&gt;來幫助我們記錄當前最優解。&lt;code&gt;注:因multipliers最多為m個，所有最多只能從nums拿m個數字&lt;/code&gt;&lt;/p&gt;</description></item><item><title>[Leetcode] Pancake Sorting(Medium)</title><link>http://localhost:1313/leetcodes/leetcode969/</link><pubDate>Thu, 15 Sep 2022 00:31:46 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode969/</guid><description>&lt;h2 id="leetcode-969---pancake-sorting"&gt;LeetCode 969 - Pancake Sorting
&lt;a class="header-anchor" href="#leetcode-969---pancake-sorting"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an array of integers &lt;code&gt;arr&lt;/code&gt;, sort the array by performing a series of &lt;strong&gt;pancake flips&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In one pancake flip we do the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Choose an integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;1 &amp;lt;= k &amp;lt;= arr.length&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Reverse the sub-array &lt;code&gt;arr[0...k-1]&lt;/code&gt; (&lt;strong&gt;0-indexed&lt;/strong&gt;).
For example, if arr = &lt;code&gt;[3,2,1,4]&lt;/code&gt; and we performed a pancake flip choosing &lt;code&gt;k = 3&lt;/code&gt;, we reverse the sub-array &lt;code&gt;[3,2,1]&lt;/code&gt;, so arr = &lt;code&gt;[1,2,3,4]&lt;/code&gt; after the pancake flip at k = 3.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Return an array of the &lt;code&gt;k&lt;/code&gt;-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within &lt;code&gt;10 * arr.length&lt;/code&gt; flips will be judged as correct.
example&lt;/p&gt;</description></item><item><title>[Leetcode] Find Original Array From Doubled Array(Medium)</title><link>http://localhost:1313/leetcodes/leetcode2007/</link><pubDate>Thu, 15 Sep 2022 00:21:27 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode2007/</guid><description>&lt;h2 id="leetcode-2007---find-original-array-from-doubled-array"&gt;LeetCode 2007 - Find Original Array From Doubled Array
&lt;a class="header-anchor" href="#leetcode-2007---find-original-array-from-doubled-array"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;An integer array &lt;code&gt;original&lt;/code&gt; is transformed into a &lt;strong&gt;doubled&lt;/strong&gt; array changed by appending &lt;strong&gt;twice the value&lt;/strong&gt; of every element in original, and then randomly &lt;strong&gt;shuffling&lt;/strong&gt; the resulting array.&lt;/p&gt;
&lt;p&gt;Given an array &lt;code&gt;changed&lt;/code&gt;, return &lt;code&gt;original&lt;/code&gt; if &lt;code&gt;changed&lt;/code&gt; is a &lt;strong&gt;doubled&lt;/strong&gt; array. If &lt;code&gt;changed&lt;/code&gt; is not a &lt;strong&gt;doubled&lt;/strong&gt; array, &lt;em&gt;return an empty array. The elements in &lt;code&gt;original&lt;/code&gt; may be returned in any order&lt;/em&gt;.
example&lt;/p&gt;</description></item><item><title>[Leetcode] Pseudo-Palindromic Paths in a Binary Tree(Medium)</title><link>http://localhost:1313/leetcodes/leetcode1457/</link><pubDate>Wed, 14 Sep 2022 15:27:08 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode1457/</guid><description>&lt;h2 id="leetcode-1457---pseudo-palindromic-paths-in-a-binary-tree"&gt;LeetCode 1457 - Pseudo-Palindromic Paths in a Binary Tree
&lt;a class="header-anchor" href="#leetcode-1457---pseudo-palindromic-paths-in-a-binary-tree"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be &lt;strong&gt;pseudo-palindromic&lt;/strong&gt; if at least one permutation of the node values in the path is a palindrome.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Return the number of &lt;strong&gt;pseudo-palindromic&lt;/strong&gt; paths going from the root node to leaf nodes.&lt;/em&gt;
example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [2,3,1,3,1,null,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 2 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [2,1,1,1,3,null,null,null,null,null,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 1 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [9]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這一題簡單的來說就是讓我們從&lt;strong&gt;Binary Tree&lt;/strong&gt;中找到有幾條&lt;code&gt;path&lt;/code&gt;是一個&lt;em&gt;Palindromic(Pseudo-Palindromic)偽迴文串&lt;/em&gt;。
也就是說從&lt;code&gt;root到leaft&lt;/code&gt;的&lt;code&gt;path&lt;/code&gt;是一個&lt;strong&gt;Palindromic&lt;/strong&gt;。 (我們只需要知道path是否能組成&lt;em&gt;Palindromic&lt;/em&gt;即可)&lt;/p&gt;</description></item><item><title>[Leetcode] UTF-8 Validation(Medium)</title><link>http://localhost:1313/leetcodes/leetcode393/</link><pubDate>Tue, 13 Sep 2022 14:41:37 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode393/</guid><description>&lt;h2 id="leetcode-393---utf-8-validation"&gt;LeetCode 393 - UTF-8 Validation
&lt;a class="header-anchor" href="#leetcode-393---utf-8-validation"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an integer array &lt;code&gt;data&lt;/code&gt; representing the data, return whether it is a valid &lt;strong&gt;UTF-8&lt;/strong&gt; encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).&lt;/p&gt;
&lt;p&gt;A character in &lt;strong&gt;UTF8&lt;/strong&gt; can be from &lt;strong&gt;1 to 4 bytes&lt;/strong&gt; long, subjected to the following rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For a &lt;strong&gt;1-byte&lt;/strong&gt; character, the first bit is a &lt;code&gt;0&lt;/code&gt;, followed by its Unicode code.&lt;/li&gt;
&lt;li&gt;For an &lt;strong&gt;n-bytes&lt;/strong&gt; character, the first n bits are all one&amp;rsquo;s, the &lt;code&gt;n + 1&lt;/code&gt; bit is &lt;code&gt;0&lt;/code&gt;, followed by &lt;code&gt;n - 1&lt;/code&gt; bytes with the most significant &lt;code&gt;2&lt;/code&gt; bits being &lt;code&gt;10&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is how the UTF-8 encoding would work:&lt;/p&gt;</description></item><item><title>[Leetcode] Bag of Tokens(Medium)</title><link>http://localhost:1313/leetcodes/leetcode948/</link><pubDate>Mon, 12 Sep 2022 18:01:44 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode948/</guid><description>&lt;h2 id="leetcode-948---bag-of-tokens"&gt;LeetCode 948 - Bag of Tokens
&lt;a class="header-anchor" href="#leetcode-948---bag-of-tokens"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You have an initial &lt;strong&gt;power&lt;/strong&gt; of &lt;code&gt;power&lt;/code&gt;, an initial &lt;strong&gt;score&lt;/strong&gt; of &lt;code&gt;0&lt;/code&gt;, and a bag of &lt;code&gt;tokens&lt;/code&gt; where &lt;code&gt;tokens[i]&lt;/code&gt; is the value of the i&lt;sup&gt;th&lt;/sup&gt; token (0-indexed).&lt;/p&gt;
&lt;p&gt;Your goal is to maximize your total &lt;strong&gt;score&lt;/strong&gt; by potentially playing each token in one of two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If your current &lt;strong&gt;power&lt;/strong&gt; is at least &lt;code&gt;tokens[i]&lt;/code&gt;, you may play the i&lt;sup&gt;th&lt;/sup&gt; token face up, losing &lt;code&gt;tokens[i]&lt;/code&gt;&lt;strong&gt;power&lt;/strong&gt; and gaining &lt;code&gt;1&lt;/code&gt;a score.&lt;/li&gt;
&lt;li&gt;If your current &lt;strong&gt;score&lt;/strong&gt; is at least &lt;code&gt;1&lt;/code&gt;, you may play the i&lt;sup&gt;th&lt;/sup&gt; token face down, gaining &lt;code&gt;tokens[i]&lt;/code&gt; &lt;strong&gt;power&lt;/strong&gt; and losing &lt;code&gt;1&lt;/code&gt; &lt;strong&gt;score&lt;/strong&gt;.
Each token may be played &lt;strong&gt;at most&lt;/strong&gt; once and &lt;strong&gt;in any order&lt;/strong&gt;. You do &lt;strong&gt;not&lt;/strong&gt; have to play all the tokens.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Return &lt;em&gt;the largest possible &lt;strong&gt;score&lt;/strong&gt; you can achieve after playing any number of tokens&lt;/em&gt;.&lt;/p&gt;</description></item><item><title>[Leetcode] The Number of Weak Characters in the Game(Medium)</title><link>http://localhost:1313/leetcodes/leetcode1996/</link><pubDate>Fri, 09 Sep 2022 23:36:50 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode1996/</guid><description>&lt;h2 id="leetcode-1996---the-number-of-weak-characters-in-the-game"&gt;LeetCode 1996 - The Number of Weak Characters in the Game
&lt;a class="header-anchor" href="#leetcode-1996---the-number-of-weak-characters-in-the-game"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are playing a game that contains multiple characters, and each of the characters has &lt;strong&gt;two&lt;/strong&gt; main properties: &lt;strong&gt;attack&lt;/strong&gt; and &lt;strong&gt;defense&lt;/strong&gt;. You are given a 2D integer array &lt;code&gt;properties&lt;/code&gt; where &lt;code&gt;properties[i] = [attacki, defensei]&lt;/code&gt; represents the properties of the i&lt;sup&gt;th&lt;/sup&gt; character in the game.&lt;/p&gt;
&lt;p&gt;A character is said to be &lt;strong&gt;weak&lt;/strong&gt; if any other character has &lt;strong&gt;both&lt;/strong&gt; attack and defense levels &lt;strong&gt;strictly greater&lt;/strong&gt; than this character&amp;rsquo;s attack and defense levels. More formally, a character &lt;code&gt;i&lt;/code&gt; is said to be &lt;strong&gt;weak&lt;/strong&gt; if there exists another character &lt;code&gt;j&lt;/code&gt; where attack&lt;sub&gt;j&lt;/sub&gt; attack&lt;sub&gt;i&lt;/sub&gt; and defense&lt;sub&gt;j&lt;/sub&gt; &amp;gt; defense&lt;sub&gt;i&lt;/sub&gt;.&lt;/p&gt;</description></item><item><title>[Leetcode] Binary Tree Inorder Traversal(Easy)</title><link>http://localhost:1313/leetcodes/leetcode94/</link><pubDate>Thu, 08 Sep 2022 20:22:06 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode94/</guid><description>&lt;h2 id="leetcode-94---binary-tree-inorder-traversal"&gt;LeetCode 94 - Binary Tree Inorder Traversal
&lt;a class="header-anchor" href="#leetcode-94---binary-tree-inorder-traversal"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a binary tree, return &lt;em&gt;the inorder traversal of its nodes&amp;rsquo; values.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [1,null,2,3]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [1,3,2]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = []
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: []&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [1]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題很簡單,只要使用中序遍歷即可。&lt;/p&gt;
&lt;h4 id="solution"&gt;Solution:
&lt;a class="header-anchor" href="#solution"&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-3-1"&gt;&lt;a class="lnlinks" href="#hl-3-1"&gt; 1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-2"&gt;&lt;a class="lnlinks" href="#hl-3-2"&gt; 2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-3"&gt;&lt;a class="lnlinks" href="#hl-3-3"&gt; 3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-4"&gt;&lt;a class="lnlinks" href="#hl-3-4"&gt; 4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-5"&gt;&lt;a class="lnlinks" href="#hl-3-5"&gt; 5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-6"&gt;&lt;a class="lnlinks" href="#hl-3-6"&gt; 6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-7"&gt;&lt;a class="lnlinks" href="#hl-3-7"&gt; 7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-8"&gt;&lt;a class="lnlinks" href="#hl-3-8"&gt; 8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-9"&gt;&lt;a class="lnlinks" href="#hl-3-9"&gt; 9&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-10"&gt;&lt;a class="lnlinks" href="#hl-3-10"&gt;10&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-11"&gt;&lt;a class="lnlinks" href="#hl-3-11"&gt;11&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-12"&gt;&lt;a class="lnlinks" href="#hl-3-12"&gt;12&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-13"&gt;&lt;a class="lnlinks" href="#hl-3-13"&gt;13&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-14"&gt;&lt;a class="lnlinks" href="#hl-3-14"&gt;14&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-15"&gt;&lt;a class="lnlinks" href="#hl-3-15"&gt;15&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-16"&gt;&lt;a class="lnlinks" href="#hl-3-16"&gt;16&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-17"&gt;&lt;a class="lnlinks" href="#hl-3-17"&gt;17&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-18"&gt;&lt;a class="lnlinks" href="#hl-3-18"&gt;18&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-19"&gt;&lt;a class="lnlinks" href="#hl-3-19"&gt;19&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-20"&gt;&lt;a class="lnlinks" href="#hl-3-20"&gt;20&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-21"&gt;&lt;a class="lnlinks" href="#hl-3-21"&gt;21&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-22"&gt;&lt;a class="lnlinks" href="#hl-3-22"&gt;22&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-23"&gt;&lt;a class="lnlinks" href="#hl-3-23"&gt;23&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-24"&gt;&lt;a class="lnlinks" href="#hl-3-24"&gt;24&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-25"&gt;&lt;a class="lnlinks" href="#hl-3-25"&gt;25&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-26"&gt;&lt;a class="lnlinks" href="#hl-3-26"&gt;26&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-27"&gt;&lt;a class="lnlinks" href="#hl-3-27"&gt;27&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-3-28"&gt;&lt;a class="lnlinks" href="#hl-3-28"&gt;28&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c++" data-lang="c++"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * Definition for a binary tree node.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * struct TreeNode {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * int val;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * TreeNode *left;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * TreeNode *right;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * TreeNode() : val(0), left(nullptr), right(nullptr) {}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; * };
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;inorderTraversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emplace_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>[Leetcode] Construct String from Binary Tree(Easy)</title><link>http://localhost:1313/leetcodes/leetcode606/</link><pubDate>Wed, 07 Sep 2022 10:12:28 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode606/</guid><description>&lt;h2 id="leetcode-606---construct-string-from-binary-tree"&gt;LeetCode 606 - Construct String from Binary Tree
&lt;a class="header-anchor" href="#leetcode-606---construct-string-from-binary-tree"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.&lt;/p&gt;
&lt;p&gt;Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.
example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [1,2,3,4]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: &amp;#34;1(2(4))(3)&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: Originally, it needs to be &amp;#34;1(2(4)())(3()())&amp;#34;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &amp;#34;1(2(4))(3)&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [1,2,3,null,4]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: &amp;#34;1(2()(4))(3)&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題就是要讓我們講以&lt;code&gt;string&lt;/code&gt;的方式輸出&lt;strong&gt;Binary Tree&lt;/strong&gt;。只要注意他的規則就可以解決這題。&lt;/p&gt;</description></item><item><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><link>http://localhost:1313/leetcodes/leetcode442/</link><pubDate>Tue, 06 Sep 2022 22:02:11 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode442/</guid><description>&lt;h2 id="leetcode-442---find-all-duplicates-in-an-array"&gt;LeetCode 442 - Find All Duplicates in an Array
&lt;a class="header-anchor" href="#leetcode-442---find-all-duplicates-in-an-array"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt; where all the integers of &lt;code&gt;nums&lt;/code&gt; are in the range &lt;code&gt;[1, n]&lt;/code&gt; and each integer appears &lt;strong&gt;once&lt;/strong&gt; or &lt;strong&gt;twice&lt;/strong&gt;, return an array of all the integers that appears &lt;strong&gt;twice&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;You must write an algorithm that runs in &lt;code&gt;O(n)&lt;/code&gt; time and uses only constant extra space.
example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [4,3,2,7,8,2,3,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [2,3]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: []&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題要我們找出所有在Array裡重複出現2次的數字。解法也很簡單, 因為題目也說了數字會出現1次或者2次,哪我們可以透過&lt;code&gt;Map&lt;/code&gt;來計數,但當前數字已經出現過1次,也就代表當前數字是重複了2次,加入到結果即可。&lt;/p&gt;</description></item><item><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><link>http://localhost:1313/leetcodes/leetcode2196/</link><pubDate>Tue, 06 Sep 2022 21:45:02 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode2196/</guid><description>&lt;h2 id="leetcode-2196---create-binary-tree-from-descriptions"&gt;LeetCode 2196 - Create Binary Tree From Descriptions
&lt;a class="header-anchor" href="#leetcode-2196---create-binary-tree-from-descriptions"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are given a 2D integer array &lt;code&gt;descriptions&lt;/code&gt; where &lt;code&gt;descriptions[i] = [parenti, childi, isLefti]&lt;/code&gt; indicates that parenti is the &lt;strong&gt;parent&lt;/strong&gt; of childi in a &lt;strong&gt;binary&lt;/strong&gt; tree of &lt;strong&gt;unique&lt;/strong&gt; values. Furthermore,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;isLefti == 1&lt;/code&gt;, then &lt;strong&gt;child&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; is the left child of &lt;strong&gt;parent&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;isLefti == 0&lt;/code&gt;, then &lt;strong&gt;child&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt; is the right child of &lt;strong&gt;parent&lt;sub&gt;i&lt;/sub&gt;&lt;/strong&gt;.
Construct the binary tree described by &lt;code&gt;descriptions&lt;/code&gt; and return &lt;em&gt;its &lt;strong&gt;root&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The test cases will be generated such that the binary tree is &lt;strong&gt;valid&lt;/strong&gt;.
example&lt;/p&gt;</description></item><item><title>[Leetcode] Binary Tree Pruning(Medium)</title><link>http://localhost:1313/leetcodes/leetcode814/</link><pubDate>Tue, 06 Sep 2022 21:30:56 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode814/</guid><description>&lt;h2 id="leetcode-814---binary-tree-pruning"&gt;LeetCode 814 - Binary Tree Pruning
&lt;a class="header-anchor" href="#leetcode-814---binary-tree-pruning"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a binary tree, return the same tree where every subtree (of the given tree) not containing a &lt;code&gt;1&lt;/code&gt; has been removed.&lt;/p&gt;
&lt;p&gt;A subtree of a node &lt;code&gt;node&lt;/code&gt; is node plus every node that is a descendant of &lt;code&gt;node&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [1,null,0,0,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [1,null,0,null,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Only the red nodes satisfy the property &amp;#34;every subtree not containing a 1&amp;#34;.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;The diagram on the right represents the answer.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [1,0,1,0,0,0,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [1,null,1,null,1]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題是要讓我們移除所有不包含&lt;code&gt;1&lt;/code&gt;的&lt;code&gt;sub-tree&lt;/code&gt;。所以，我們只要透過&lt;code&gt;DFS&lt;/code&gt;判斷一下&lt;code&gt;node&lt;/code&gt;的&lt;code&gt;left-sub tree&lt;/code&gt; 以及 &lt;code&gt;right-sub tree&lt;/code&gt; 是否都不包含&lt;code&gt;1&lt;/code&gt;:
1. 如果左右子樹都不包含&lt;code&gt;1&lt;/code&gt;且當前&lt;code&gt;node&lt;/code&gt;為0, 直接返回&lt;code&gt;nullptr&lt;/code&gt;
2. 若當前節點為&lt;code&gt;1&lt;/code&gt;就返回自身
2. 左子樹不包含&lt;code&gt;1&lt;/code&gt;, 當前&lt;code&gt;node&lt;/code&gt;的左子樹設成&lt;code&gt;nullptr&lt;/code&gt;;同理右子樹不包含&lt;code&gt;1&lt;/code&gt;,當前&lt;code&gt;node&lt;/code&gt; 的右子數設為&lt;code&gt;nullptr&lt;/code&gt;&lt;/p&gt;</description></item><item><title>[Leetcode] Reverse Linked List II(Medium)</title><link>http://localhost:1313/leetcodes/leetcode92/</link><pubDate>Thu, 21 Jul 2022 11:09:21 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode92/</guid><description>&lt;h2 id="leetcode-92----reverse-linked-list-ii"&gt;LeetCode 92 - Reverse Linked List II
&lt;a class="header-anchor" href="#leetcode-92----reverse-linked-list-ii"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given the &lt;code&gt;head&lt;/code&gt; of a singly linked list and two integers &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; where &lt;code&gt;left &amp;lt;= right&lt;/code&gt;, reverse the nodes of the list from position &lt;code&gt;left&lt;/code&gt; to position &lt;code&gt;right&lt;/code&gt;, and return the &lt;em&gt;reversed list&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: head = [1,2,3,4,5], left = 2, right = 4
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [1,4,3,2,5]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: head = [5], left = 1, right = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [5]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這一題的問題非常的簡單,就是要讓我們在給定的一個&lt;code&gt;list&lt;/code&gt;中翻轉(Reverse)&lt;code&gt;[left,right]&lt;/code&gt;之間的Node,並返回結果。這題跟&lt;strong&gt;Reverse Linked List I&lt;/strong&gt;解法類似,不同的是多了個翻轉範圍。&lt;br&gt;
首先，我們要做的是在的翻轉的開始的位置。然後再透過recursive來翻轉List,最後返回的&lt;code&gt;node/head&lt;/code&gt;再由&lt;code&gt;left&lt;/code&gt;位置的Node的前一個&lt;code&gt;Node&lt;/code&gt;接起來(如有)就可以了~&lt;/p&gt;</description></item><item><title>[Leetcode DP] K Inverse Pairs Array(Hard)</title><link>http://localhost:1313/leetcodes/leetcode629/</link><pubDate>Sun, 17 Jul 2022 11:55:10 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode629/</guid><description>&lt;p&gt;&lt;em&gt;這題主要是學習DP思想，做個小記錄&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="leetcode-629---k-inverse-pairs-array"&gt;LeetCode 629 - K Inverse Pairs Array
&lt;a class="header-anchor" href="#leetcode-629---k-inverse-pairs-array"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;For an integer array nums, an &lt;strong&gt;inverse pair&lt;/strong&gt; is a pair of integers &lt;code&gt;[i, j]&lt;/code&gt; where &lt;code&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length&lt;/code&gt; and &lt;code&gt;nums[i] &amp;gt; nums[j]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given two integers&lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, return the number of different arrays consist of numbers from 1 to n such that there are exactly &lt;code&gt;k&lt;/code&gt; &lt;strong&gt;inverse pairs&lt;/strong&gt;. Since the answer can be huge, return it &lt;strong&gt;modulo&lt;/strong&gt; &lt;code&gt;109 + 7&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>[Leetcode DP] Counting Bits(Easy)</title><link>http://localhost:1313/leetcodes/leetcodes338/</link><pubDate>Thu, 23 Jun 2022 11:33:51 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcodes338/</guid><description>&lt;h2 id="leetcode-338---counting-bits"&gt;LeetCode 338 - Counting Bits
&lt;a class="header-anchor" href="#leetcode-338---counting-bits"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an integer &lt;code&gt;n&lt;/code&gt;, return an &lt;em&gt;array &lt;code&gt;ans&lt;/code&gt; of length &lt;code&gt;n + 1&lt;/code&gt; such that for each &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;0 &amp;lt;= i &amp;lt;= n&lt;/code&gt;), &lt;code&gt;ans[i]&lt;/code&gt; is the &lt;strong&gt;number&lt;/strong&gt; of &lt;code&gt;1&lt;/code&gt;&amp;rsquo;s in the binary representation of &lt;code&gt;i&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-6"&gt;&lt;a class="lnlinks" href="#hl-0-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: n = 2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [0,1,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;0 --&amp;gt; 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1 --&amp;gt; 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;2 --&amp;gt; 10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-4"&gt;&lt;a class="lnlinks" href="#hl-1-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-5"&gt;&lt;a class="lnlinks" href="#hl-1-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-6"&gt;&lt;a class="lnlinks" href="#hl-1-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-7"&gt;&lt;a class="lnlinks" href="#hl-1-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-8"&gt;&lt;a class="lnlinks" href="#hl-1-8"&gt;8&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-9"&gt;&lt;a class="lnlinks" href="#hl-1-9"&gt;9&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: n = 5
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [0,1,1,2,1,2]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;0 --&amp;gt; 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1 --&amp;gt; 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;2 --&amp;gt; 10
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;3 --&amp;gt; 11
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;4 --&amp;gt; 100
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;5 --&amp;gt; 101&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題要我們解決的問題是給定一個數字&lt;code&gt;n&lt;/code&gt;,回傳&lt;code&gt;0 - n&lt;/code&gt;中每個數字包含了多少個為1的&lt;code&gt;bits&lt;/code&gt;。例如: &lt;code&gt;n=2 =&amp;gt; 00,01,10&lt;/code&gt;,回傳的結果便會是&lt;code&gt;[0,1,1]&lt;/code&gt;。&lt;/p&gt;</description></item><item><title>[Leetcode] Kth Largest Element in an Array(Medium)</title><link>http://localhost:1313/leetcodes/leetcodes215/</link><pubDate>Wed, 22 Jun 2022 22:55:53 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcodes215/</guid><description>&lt;h2 id="leetcode-1268---search-suggestions-system"&gt;LeetCode 1268 - Search Suggestions System
&lt;a class="header-anchor" href="#leetcode-1268---search-suggestions-system"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt; and an integer &lt;code&gt;k&lt;/code&gt;, return the &lt;code&gt;kth&lt;/code&gt; &lt;em&gt;largest element in the array&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Note that it is the &lt;code&gt;kth&lt;/code&gt; largest element in the sorted order, not the &lt;code&gt;kth&lt;/code&gt; distinct element.&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [3,2,1,5,6,4], k = 2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 5&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題要我們解決的問題是回傳在&lt;code&gt;sorted array&lt;/code&gt;(&lt;em&gt;Input Array沒有排序&lt;/em&gt;)中第&lt;code&gt;kth&lt;/code&gt;大的元素。最簡單的解法是直接排序,然後回傳&lt;code&gt;kth&lt;/code&gt;元素即可。但是, 這裡我們也可以使用&lt;code&gt;Priority Queue(Heap)&lt;/code&gt;來幫我們解決這個問題。因為&lt;code&gt;Priority Queue&lt;/code&gt;的特性,越大的值(&lt;code&gt;MaxHeap&lt;/code&gt;)/越小的值(&lt;code&gt;MinHeap&lt;/code&gt;)會越接近&lt;code&gt;root&lt;/code&gt;,也就是說最大值(&lt;code&gt;MaxHeap&lt;/code&gt;)/最小值(&lt;code&gt;MinHeap&lt;/code&gt;)會在&lt;code&gt;root&lt;/code&gt;。所以我們可以運用&lt;code&gt;MinHeap&lt;/code&gt;來幫助的我們解決這個問題,只要&lt;code&gt;Priority Queue&lt;/code&gt;裡面的元素多於&lt;code&gt;K&lt;/code&gt;個我們就會把&lt;code&gt;top&lt;/code&gt;的值移除，因更小的值會在前面,每次&lt;code&gt;pop&lt;/code&gt;的值都會是當前最小的值,直到最後，省下來的值的&lt;code&gt;root&lt;/code&gt;/&lt;code&gt;top&lt;/code&gt;就會是我們的第&lt;code&gt;K&lt;/code&gt;個最大的值，而&lt;code&gt;priority queue&lt;/code&gt;中最後一個值便會是&lt;code&gt;Input&lt;/code&gt;中最大的值。&lt;/p&gt;</description></item><item><title>[Leetcode] Furthest Building You Can Reach(Medium)</title><link>http://localhost:1313/leetcodes/leetcodes1642/</link><pubDate>Tue, 21 Jun 2022 22:55:43 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcodes1642/</guid><description>&lt;h2 id="leetcode-1642---furthest-building-you-can-reach"&gt;LeetCode 1642 - Furthest Building You Can Reach
&lt;a class="header-anchor" href="#leetcode-1642---furthest-building-you-can-reach"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are given an integer array &lt;code&gt;heights&lt;/code&gt; representing the heights of buildings, some &lt;code&gt;bricks&lt;/code&gt;, and some &lt;code&gt;ladders&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You start your journey from building &lt;code&gt;0&lt;/code&gt; and move to the next building by possibly using bricks or ladders.&lt;/p&gt;
&lt;p&gt;While moving from building &lt;code&gt;i&lt;/code&gt; to building &lt;code&gt;i+1&lt;/code&gt; (&lt;strong&gt;0-indexed&lt;/strong&gt;),&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the current building&amp;rsquo;s height is &lt;strong&gt;greater than or equal&lt;/strong&gt; to the next building&amp;rsquo;s height, you do not need a ladder or bricks.&lt;/li&gt;
&lt;li&gt;If the current building&amp;rsquo;s height is &lt;strong&gt;less than&lt;/strong&gt; the next building&amp;rsquo;s height, you can either use one ladder or &lt;code&gt;(h[i+1] - h[i])&lt;/code&gt; bricks.
&lt;em&gt;Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;example:&lt;/p&gt;</description></item><item><title>[Leetcode] Short Encoding of Words(Medium)</title><link>http://localhost:1313/leetcodes/leetcode802/</link><pubDate>Mon, 20 Jun 2022 12:45:05 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode802/</guid><description>&lt;h2 id="820---short-encoding-of-words"&gt;820 - Short Encoding of Words
&lt;a class="header-anchor" href="#820---short-encoding-of-words"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;A &lt;strong&gt;valid encoding&lt;/strong&gt; of an array of &lt;code&gt;words&lt;/code&gt; is any reference string s and array of indices indices such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;words.length&lt;/code&gt; == &lt;code&gt;indices.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The reference string &lt;code&gt;s&lt;/code&gt; ends with the &lt;code&gt;'#'&lt;/code&gt; character.&lt;/li&gt;
&lt;li&gt;For each index indices[i], the &lt;strong&gt;substring&lt;/strong&gt; of s starting from &lt;code&gt;indices[i]&lt;/code&gt; and up to (but not including) the next &lt;code&gt;'#'&lt;/code&gt; character is equal to &lt;code&gt;words[i]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given an array of &lt;code&gt;words&lt;/code&gt;, return the length of the shortest reference string &lt;code&gt;s&lt;/code&gt; possible of any valid encoding of &lt;code&gt;words&lt;/code&gt;.&lt;/p&gt;</description></item><item><title>[Leetcode] Search Suggestions System[Medium]</title><link>http://localhost:1313/leetcodes/leetcode1268/</link><pubDate>Sun, 19 Jun 2022 12:45:24 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode1268/</guid><description>&lt;h2 id="leetcode-1268---search-suggestions-system"&gt;LeetCode 1268 - Search Suggestions System
&lt;a class="header-anchor" href="#leetcode-1268---search-suggestions-system"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are given an array of strings &lt;code&gt;products&lt;/code&gt; and a string &lt;code&gt;searchWord&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Design a system that suggests at most three product names from &lt;code&gt;products&lt;/code&gt; after each character of &lt;code&gt;searchWord&lt;/code&gt; is typed. Suggested products should have common prefix with &lt;code&gt;searchWord&lt;/code&gt;. If there are more than three products with a common prefix return the three lexicographically minimums products.&lt;/p&gt;
&lt;p&gt;Return a &lt;em&gt;list of lists of the suggested products&lt;/em&gt; after each character of &lt;code&gt;searchWord&lt;/code&gt; is typed.
example:&lt;/p&gt;</description></item><item><title>[Leetcode] Longest Palindromic Substring(Medium)</title><link>http://localhost:1313/leetcodes/leetcode5/</link><pubDate>Thu, 16 Jun 2022 14:09:50 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode5/</guid><description>&lt;h2 id="leetcode-5---longest-palindromic-substring"&gt;LeetCode 5 - Longest Palindromic Substring
&lt;a class="header-anchor" href="#leetcode-5---longest-palindromic-substring"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given a string s, return the longest palindromic substring in s.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: s = &amp;#34;babad&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: &amp;#34;bab&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: &amp;#34;aba&amp;#34; is also a valid answer.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: s = &amp;#34;cbbd&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: &amp;#34;bb&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;要解決這題，我們必須要先知道什麼是Palindrome。可以參考這篇文章
&lt;a href="http://localhost:1313/leetcodenotes/palindromicstring" title="Palindromic string迴文" &gt;
 Palindromic string迴文
 
&lt;/a&gt;。而這題要我們找出在給定string中,找到最長的Palindrome。我們可以透過以每個單一字元(&lt;code&gt;index i&lt;/code&gt;)以及倆個字元(&lt;code&gt;index i&lt;/code&gt;,&lt;code&gt;index i+1&lt;/code&gt;)為中心點，並擴展&lt;code&gt;left,right&lt;/code&gt;找出他們的局部的最長Palindrome為多少，然後根據這個長度計算&lt;code&gt;starting point i&lt;/code&gt;以及記錄長度&lt;code&gt;len&lt;/code&gt;,最後以&lt;code&gt;starting point&lt;/code&gt;和&lt;code&gt;len&lt;/code&gt;得出字串中&lt;code&gt;str[startingPoint,len]&lt;/code&gt;為解。&lt;/p&gt;</description></item><item><title>[Leetcode] Delete Operation for Two Strings(Medium)</title><link>http://localhost:1313/leetcodes/leetcode583/</link><pubDate>Tue, 14 Jun 2022 13:37:49 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode583/</guid><description>&lt;h2 id="leetcode-583---delete-operation-for-two-strings"&gt;LeetCode 583 - Delete Operation for Two Strings
&lt;a class="header-anchor" href="#leetcode-583---delete-operation-for-two-strings"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given two strings &lt;code&gt;word1&lt;/code&gt; and &lt;code&gt;word2&lt;/code&gt;, return the minimum number of steps required to make &lt;code&gt;word1&lt;/code&gt; and &lt;code&gt;word2&lt;/code&gt; the same.&lt;/p&gt;
&lt;p&gt;In one &lt;code&gt;step&lt;/code&gt;, you can delete exactly one character in either string
example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: word1 = &amp;#34;sea&amp;#34;, word2 = &amp;#34;eat&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: You need one step to make &amp;#34;sea&amp;#34; to &amp;#34;ea&amp;#34; and another step to make &amp;#34;eat&amp;#34; to &amp;#34;ea&amp;#34;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: word1 = &amp;#34;leetcode&amp;#34;, word2 = &amp;#34;etco&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題要我們解決的問題是給定2個字串&lt;code&gt;Word1&lt;/code&gt;和&lt;code&gt;Word2&lt;/code&gt;,每次從&lt;code&gt;Word1&lt;/code&gt;或者&lt;code&gt;Word2&lt;/code&gt;中移除1個Character，問我們最少需要多少步使得2個string一樣。&lt;br&gt;
首先,我們需要先知道這2個&lt;code&gt;Word&lt;/code&gt;有哪些Character的是一致的。為了能獲得他們之間的最長共同子字串，我們可以透過&lt;code&gt;Longest Commond Substring&lt;/code&gt;來得到他們之間共同子字串的長度，只要每個字串的長度減去LCM的長度，就可以知道各自需要多少步。最後相加起來即可。&lt;br&gt;

&lt;a href="http://localhost:1313/leetcodenotes/lcm" title="Longest Commond Substring Template" &gt;
 Longest Commond Substring Template
 
&lt;/a&gt;&lt;/p&gt;</description></item><item><title>[Leetcode] Combination Sum III(Medium)</title><link>http://localhost:1313/leetcodes/leetcode216/</link><pubDate>Tue, 10 May 2022 11:41:43 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode216/</guid><description>&lt;h2 id="leetcode-216---combination-sum-iii"&gt;LeetCode 216 - Combination Sum III
&lt;a class="header-anchor" href="#leetcode-216---combination-sum-iii"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Find all valid combinations of &lt;code&gt;k&lt;/code&gt; numbers that sum up to &lt;code&gt;n&lt;/code&gt; such that the following conditions are true:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Only numbers 1 through 9 are used.&lt;/li&gt;
&lt;li&gt;Each number is used &lt;strong&gt;at most once&lt;/strong&gt;.
Return a &lt;em&gt;list of all possible valid combinations&lt;/em&gt;. The list must not contain the same combination twice, and the combinations may be returned in any order.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: k = 3, n = 7
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [[1,2,4]]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1 + 2 + 4 = 7
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;There are no other valid combinations.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-4"&gt;&lt;a class="lnlinks" href="#hl-1-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-5"&gt;&lt;a class="lnlinks" href="#hl-1-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-6"&gt;&lt;a class="lnlinks" href="#hl-1-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-7"&gt;&lt;a class="lnlinks" href="#hl-1-7"&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: k = 3, n = 9
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [[1,2,6],[1,3,5],[2,3,4]]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1 + 2 + 6 = 9
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1 + 3 + 5 = 9
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;2 + 3 + 4 = 9
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;There are no other valid combinations.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-3"&gt;&lt;a class="lnlinks" href="#hl-2-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-4"&gt;&lt;a class="lnlinks" href="#hl-2-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: k = 4, n = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: []
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: There are no valid combinations.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &amp;gt; 1, there are no valid combination.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題主要關注的點是數字範圍為&lt;code&gt;[1,9]&lt;/code&gt;，每個結果中，數字只能使用一次，而且數字必須是順序排列。例如:&lt;code&gt;2,3,4&lt;/code&gt;,&lt;code&gt;1,2,5&lt;/code&gt;。解決這題我們可以用&lt;strong&gt;back-traking&lt;/strong&gt;大法。只要我們當前的&lt;code&gt;Sum&lt;/code&gt;大於&lt;code&gt;n&lt;/code&gt;我們就直接退回back track回上一步,因為數值只會越來越大，並不是我們想要的。如果&lt;em&gt;Ans&lt;/em&gt;我們所需的&lt;code&gt;k&lt;/code&gt;個就直接判斷是否等於&lt;code&gt;n&lt;/code&gt;，如果是就直接加入到我們的&lt;em&gt;result&lt;/em&gt;即可。&lt;/p&gt;</description></item><item><title>[Leetcode] Letter Combinations of a Phone Number(Medium)</title><link>http://localhost:1313/leetcodes/leetcode17/</link><pubDate>Mon, 09 May 2022 21:50:34 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode17/</guid><description>&lt;h2 id="leetcode-17---letter-combinations-of-a-phone-number"&gt;LeetCode 17 - Letter Combinations of a Phone Number
&lt;a class="header-anchor" href="#leetcode-17---letter-combinations-of-a-phone-number"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given a string containing digits from &lt;code&gt;2-9&lt;/code&gt; inclusive, return all possible letter combinations that the number could represent. Return the answer in &lt;strong&gt;any order&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: digits = &amp;#34;23&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: digits = &amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: []&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: digits = &amp;#34;2&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題是要我們拿到&lt;code&gt;Input&lt;/code&gt;的數字所能組合出所有字串。解法也很簡單，我們可以透過&lt;code&gt;Map&lt;/code&gt;記錄每個數字代表來那些字符，然後再透過&lt;strong&gt;Back-tracking&lt;/strong&gt;技巧來幫助我們組合字串。你有可能會問什麼是&lt;strong&gt;Back-tracking&lt;/strong&gt;。簡單來說就是一個&lt;strong&gt;Recursive Function&lt;/strong&gt;,但他會迴避一些不正常的數值。比如:&amp;ldquo;abc&amp;rdquo;,而&amp;quot;abc&amp;quot;可能不是我們要的。因此退回上一步的&amp;quot;ab&amp;quot;,並嘗試其他數值/結果。&lt;/p&gt;</description></item><item><title>[Leetcode] Flatten Nested List Iterator(Medium)</title><link>http://localhost:1313/leetcodes/leetcode341/</link><pubDate>Sun, 08 May 2022 06:30:23 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode341/</guid><description>&lt;h2 id="leetcode-341---flatten-nested-list-iterator"&gt;LeetCode 341 - Flatten Nested List Iterator
&lt;a class="header-anchor" href="#leetcode-341---flatten-nested-list-iterator"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are given a nested list of integers &lt;code&gt;nestedList&lt;/code&gt;. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.&lt;/p&gt;
&lt;p&gt;Implement the NestedIterator &lt;code&gt;class&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NestedIterator(List&amp;lt;NestedInteger&amp;gt; nestedList)&lt;/code&gt; Initializes the iterator with the nested list &lt;code&gt;nestedList&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int next()&lt;/code&gt; Returns the next integer in the nested list.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean hasNext()&lt;/code&gt; Returns &lt;code&gt;true&lt;/code&gt; if there are still some integers in the nested list and false otherwise.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Your code will be tested with the following pseudocode:&lt;/p&gt;</description></item><item><title>[Leetcode] 132 Pattern(Medium)</title><link>http://localhost:1313/leetcodes/leetcode456/</link><pubDate>Sat, 07 May 2022 06:30:23 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode456/</guid><description>&lt;h2 id="leetcode-456---132-pattern"&gt;LeetCode 456 - 132 Pattern
&lt;a class="header-anchor" href="#leetcode-456---132-pattern"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an array of &lt;code&gt;n&lt;/code&gt; integers nums, a &lt;strong&gt;132 pattern&lt;/strong&gt; is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j].&lt;/p&gt;
&lt;p&gt;Return true &lt;em&gt;if there is a 132 pattern in nums, otherwise, return false&lt;/em&gt;.
example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [1,2,3,4]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: false
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: There is no 132 pattern in the sequence.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [3,1,4,2]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: true
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: There is a 132 pattern in the sequence: [1, 4, 2].&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-3"&gt;&lt;a class="lnlinks" href="#hl-2-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [-1,3,2,0]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: true
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題就是要我們找出&lt;code&gt;List&lt;/code&gt;有沒有符合&lt;code&gt;132 Pattern&lt;/code&gt;。那怎麼才算是&lt;code&gt;132 Pattern&lt;/code&gt;呢。從題目定義可以看出在&lt;code&gt;List&lt;/code&gt;中任意的&lt;code&gt;nums[i] &amp;lt; nums[k] &amp;lt; nums[j]，也就是說&lt;/code&gt;nums[k]&lt;code&gt;為最大,&lt;/code&gt;nums[j]&lt;code&gt;為第二大,&lt;/code&gt;nums[i]`為第三大。&lt;/p&gt;</description></item><item><title>[LeetCode] Remove All Adjacent Duplicates in String II(Medium)</title><link>http://localhost:1313/leetcodes/leetcode1209/</link><pubDate>Fri, 06 May 2022 21:19:25 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode1209/</guid><description>&lt;h2 id="leetcode-1209---remove-all-adjacent-duplicates-in-string-ii"&gt;LeetCode 1209 - Remove All Adjacent Duplicates in String II
&lt;a class="header-anchor" href="#leetcode-1209---remove-all-adjacent-duplicates-in-string-ii"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are given a string &lt;code&gt;s&lt;/code&gt; and an integer &lt;code&gt;k&lt;/code&gt;, a &lt;code&gt;k&lt;/code&gt; &lt;strong&gt;duplicate removal&lt;/strong&gt; consists of choosing &lt;code&gt;k&lt;/code&gt; adjacent and equal letters from &lt;code&gt;s&lt;/code&gt; and removing them, causing the left and the right side of the deleted substring to concatenate together.&lt;/p&gt;
&lt;p&gt;We repeatedly make &lt;code&gt;k&lt;/code&gt; duplicate removals on &lt;code&gt;s&lt;/code&gt; until we no longer can.&lt;/p&gt;
&lt;p&gt;Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.&lt;/p&gt;</description></item><item><title>[Leetcode] Implement Stack using Queues(Easy)</title><link>http://localhost:1313/leetcodes/leetcode225/</link><pubDate>Thu, 05 May 2022 09:39:35 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode225/</guid><description>&lt;h2 id="leetcode-225---implement-stack-using-queues"&gt;LeetCode 225 - Implement Stack using Queues
&lt;a class="header-anchor" href="#leetcode-225---implement-stack-using-queues"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (&lt;code&gt;push&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, and &lt;code&gt;empty&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Implement the &lt;code&gt;MyStack&lt;/code&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void &lt;code&gt;push(int x)&lt;/code&gt; Pushes element x to the top of the stack.&lt;/li&gt;
&lt;li&gt;int &lt;code&gt;pop()&lt;/code&gt; Removes the element on the top of the stack and returns it.&lt;/li&gt;
&lt;li&gt;int &lt;code&gt;top()&lt;/code&gt; Returns the element on the top of the stack.&lt;/li&gt;
&lt;li&gt;boolean &lt;code&gt;empty()&lt;/code&gt; Returns &lt;code&gt;true&lt;/code&gt; if the stack is empty, &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;:&lt;/p&gt;</description></item><item><title>[Leetcode] Max Number of K-Sum Pairs(Medium)</title><link>http://localhost:1313/leetcodes/leetcode1679/</link><pubDate>Wed, 04 May 2022 20:11:43 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode1679/</guid><description>&lt;h2 id="leetcode-1679---max-number-of-k-sum-pairs"&gt;LeetCode 1679 - Max Number of K-Sum Pairs
&lt;a class="header-anchor" href="#leetcode-1679---max-number-of-k-sum-pairs"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are given an integer array &lt;code&gt;nums&lt;/code&gt; and an integer &lt;code&gt;k&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In one operation, you can pick two numbers from the array whose sum equals &lt;code&gt;k&lt;/code&gt; and remove them from the array.&lt;/p&gt;
&lt;p&gt;Return &lt;code&gt;the maximum number of operations you can perform on the array&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-4"&gt;&lt;a class="lnlinks" href="#hl-0-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-5"&gt;&lt;a class="lnlinks" href="#hl-0-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-6"&gt;&lt;a class="lnlinks" href="#hl-0-6"&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [1,2,3,4], k = 5
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: Starting with nums = [1,2,3,4]:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Remove numbers 1 and 4, then nums = [2,3]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Remove numbers 2 and 3, then nums = []
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;There are no more pairs that sum up to 5, hence a total of 2 operations.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-4"&gt;&lt;a class="lnlinks" href="#hl-1-4"&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-5"&gt;&lt;a class="lnlinks" href="#hl-1-5"&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [3,1,3,4,3], k = 6
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: Starting with nums = [3,1,3,4,3]:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- Remove the first two 3&amp;#39;s, then nums = [1,4,3]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;There are no more pairs that sum up to 6, hence a total of 1 operation.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題就是要移除&lt;code&gt;Array&lt;/code&gt;中2個elements加起來等於&lt;code&gt;k&lt;/code&gt;的操作有幾次。&lt;br&gt;
第一個解法，我們可以使用&lt;code&gt;sorting&lt;/code&gt;以及&lt;code&gt;two-pointer approach&lt;/code&gt;來解決。先將&lt;code&gt;array&lt;/code&gt;排序，然後設置&lt;code&gt;i&lt;/code&gt;為0,&lt;code&gt;j&lt;/code&gt;為&lt;code&gt;n-1&lt;/code&gt;,直接使用iteration找出&lt;code&gt;nums[i]+nums[j] = k&lt;/code&gt;的數，然後&lt;code&gt;answer+1&lt;/code&gt;即可。&lt;/p&gt;</description></item><item><title>[Leetcode] Shortest Unsorted Continuous Subarray(Medium)</title><link>http://localhost:1313/leetcodes/leetcode581/</link><pubDate>Tue, 03 May 2022 18:27:24 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode581/</guid><description>&lt;h2 id="leetcode-581---shortest-unsorted-continuous-subarray"&gt;LeetCode 581 - Shortest Unsorted Continuous Subarray
&lt;a class="header-anchor" href="#leetcode-581---shortest-unsorted-continuous-subarray"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.&lt;/p&gt;
&lt;p&gt;Return &lt;code&gt;the shortest such subarray and output its length&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [2,6,4,8,10,9,15]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 5
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [1,2,3,4]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: 0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題比較難懂一點點，這裡先做一下題目的解釋。這題主要先問的是在輸入的&lt;code&gt;Array&lt;/code&gt;裡面找到一個最小需要排序的&lt;code&gt;Sub-array&lt;/code&gt;。&lt;br&gt;
從例子&lt;code&gt;[2,6,4,8,10,9,15]&lt;/code&gt;中，我們可以很明顯的看到&lt;code&gt;[6,4,8,10,9]&lt;/code&gt;並不是ascending order(順序),而這個&lt;code&gt;sub-array&lt;/code&gt;要進行排序的話，所有elements都需要進行排序，所以，他的length是&lt;code&gt;5&lt;/code&gt;。&lt;br&gt;
再舉另外一個例子&lt;code&gt;[1,3,2,3,3]&lt;/code&gt;，這個&lt;code&gt;Array&lt;/code&gt;我們可以看到&lt;code&gt;[3,2,3,3]&lt;/code&gt;並不是順序的，但是在這個&lt;code&gt;sub-array&lt;/code&gt;裡面,只有&lt;code&gt;[3,2]&lt;/code&gt;需要排序,所以，他的結果會是&lt;code&gt;2&lt;/code&gt;。&lt;/p&gt;</description></item><item><title>[Leetcode] Sort Array By Parity(Easy)</title><link>http://localhost:1313/leetcodes/leetcode905/</link><pubDate>Mon, 02 May 2022 18:19:41 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode905/</guid><description>&lt;h2 id="leetcode-905---sort-array-by-parity"&gt;LeetCode 905 - Sort Array By Parity
&lt;a class="header-anchor" href="#leetcode-905---sort-array-by-parity"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt;, move all the even integers at the beginning of the array followed by all the odd integers.&lt;/p&gt;
&lt;p&gt;Return &lt;strong&gt;any array&lt;/strong&gt; that satisfies this condition.&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [3,1,2,4]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [2,4,3,1]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [0]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [0]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這個問題很簡單，就是把偶數移動到Array的前面，基數移動到後面。我們這裡可以使用&lt;code&gt;Two-pointer approach&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;為尋找前面的基數，而&lt;code&gt;j&lt;/code&gt; 為尋找後面的偶數，只要&lt;code&gt;nums[i]&lt;/code&gt;為基數,&lt;code&gt;nums[j]&lt;/code&gt;為偶數就進行交換。&lt;/p&gt;</description></item><item><title>[Leetcode] Backspace String Compare(Easy)</title><link>http://localhost:1313/leetcodes/leetcode844/</link><pubDate>Sun, 01 May 2022 17:52:25 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode844/</guid><description>&lt;h2 id="leetcode-844---backspace-string-compare"&gt;LeetCode 844 - Backspace String Compare
&lt;a class="header-anchor" href="#leetcode-844---backspace-string-compare"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given two strings s and t, return true &lt;em&gt;if they are equal when both are typed into empty text editors&lt;/em&gt;. &lt;code&gt;'#'&lt;/code&gt; means a backspace character.&lt;/p&gt;
&lt;p&gt;Note that after backspacing an empty text, the text will continue empty.&lt;/p&gt;
&lt;p&gt;example:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-3"&gt;&lt;a class="lnlinks" href="#hl-0-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: s = &amp;#34;ab#c&amp;#34;, t = &amp;#34;ad#c&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: true
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: Both s and t become &amp;#34;ac&amp;#34;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-3"&gt;&lt;a class="lnlinks" href="#hl-1-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: s = &amp;#34;ab##&amp;#34;, t = &amp;#34;c#d#&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: true
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: Both s and t become &amp;#34;&amp;#34;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-2-1"&gt;&lt;a class="lnlinks" href="#hl-2-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-2"&gt;&lt;a class="lnlinks" href="#hl-2-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-2-3"&gt;&lt;a class="lnlinks" href="#hl-2-3"&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: s = &amp;#34;a#c&amp;#34;, t = &amp;#34;b&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: false
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Explanation: s becomes &amp;#34;c&amp;#34; while t becomes &amp;#34;b&amp;#34;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題主要要什麼比較2個String移除於&lt;code&gt;#&lt;/code&gt;前的字符後是否為相同的String，就相當於&lt;code&gt;Backspace(#) 字符&lt;/code&gt;。
這題有2種解法:&lt;/p&gt;</description></item><item><title>[Leetcode] Trim a Binary Search Tree(Medium)</title><link>http://localhost:1313/leetcodes/leetcode669/</link><pubDate>Fri, 15 Apr 2022 18:29:14 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode669/</guid><description>&lt;h2 id="leetcode-669---trim-a-binary-search-tree"&gt;LeetCode 669 - Trim a Binary Search Tree
&lt;a class="header-anchor" href="#leetcode-669---trim-a-binary-search-tree"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given the root of a binary search tree and the lowest and highest boundaries as &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt;, trim the tree so that all its elements lies in &lt;code&gt;[low, high]&lt;/code&gt;. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&amp;rsquo;s descendant should remain a descendant). It can be proven that there is a &lt;strong&gt;unique answer&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>[Leetcode] Search in a Binary Search Tree(Easy)</title><link>http://localhost:1313/leetcodes/leetcode700/</link><pubDate>Thu, 14 Apr 2022 15:05:44 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode700/</guid><description>&lt;h2 id="leetcode-700---search-in-a-binary-search-tree"&gt;LeetCode 700 - Search in a Binary Search Tree
&lt;a class="header-anchor" href="#leetcode-700---search-in-a-binary-search-tree"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are given the root of a binary search tree (BST) and an integer val.&lt;/p&gt;
&lt;p&gt;Find the node in the BST that the node&amp;rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [4,2,7,1,3], val = 2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [2,1,3]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: root = [4,2,7,1,3], val = 5
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: []&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;在解決問題之前，我們需要知道什麼是&lt;code&gt;Binary Search Tree&lt;/code&gt;。根據&lt;code&gt;BST&lt;/code&gt;的定義:&lt;/p&gt;</description></item><item><title>[Leetcode] Shift 2D Grid(Easy)</title><link>http://localhost:1313/leetcodes/leetcode1260/</link><pubDate>Wed, 13 Apr 2022 19:14:44 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode1260/</guid><description>&lt;h2 id="leetcode-1260----shift-2d-grid"&gt;LeetCode 1260 - Shift 2D Grid
&lt;a class="header-anchor" href="#leetcode-1260----shift-2d-grid"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.&lt;/p&gt;
&lt;p&gt;In one shift operation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Element at grid[i][j] moves to grid[i][j + 1].&lt;/li&gt;
&lt;li&gt;Element at grid[i][n - 1] moves to grid[i + 1][0].&lt;/li&gt;
&lt;li&gt;Element at grid[m - 1][n - 1] moves to grid[0][0].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Return the 2D grid after applying shift operation k times.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;</description></item><item><title>[Leetcode] Spiral Matrix II(Medium)</title><link>http://localhost:1313/leetcodes/leetcode59/</link><pubDate>Wed, 13 Apr 2022 14:26:29 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode59/</guid><description>&lt;h2 id="leetcode-59----spiral-matrix-ii"&gt;LeetCode 59 - Spiral Matrix II
&lt;a class="header-anchor" href="#leetcode-59----spiral-matrix-ii"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given a positive integer n, generate an n x n matrix filled with elements from 1 to n&lt;sup&gt;2&lt;/sup&gt; in spiral order.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: n = 3
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [[1,2,3],[8,9,4],[7,6,5]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: n = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [[1]]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這題跟&lt;code&gt;Spiral Matrix&lt;/code&gt;做法差不多，我們不難發現他的移動模式就是(&lt;em&gt;右→下↓左←上&lt;/em&gt;)，我們只需要通過幾個變數來限制移動的步數。另外，這題需要我們返回一個n&lt;sup&gt;2&lt;/sup&gt;的array，所以，需要額外定義一個counter來記錄每次插入的數值為多少，因此，只要counter 到達n&lt;sup&gt;2&lt;/sup&gt;的大小就知道是否完成插入所需的值。&lt;/p&gt;</description></item><item><title>[Leetcode] Game of Life(Medium)</title><link>http://localhost:1313/leetcodes/leetcode289/</link><pubDate>Tue, 12 Apr 2022 19:15:53 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode289/</guid><description>&lt;h2 id="leetcode-289----game-of-life"&gt;LeetCode 289 - Game of Life
&lt;a class="header-anchor" href="#leetcode-289----game-of-life"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;According to Wikipedia&amp;rsquo;s article: &amp;ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):&lt;/p&gt;</description></item><item><title>[Leetcode] Baseball Game(Easy)</title><link>http://localhost:1313/leetcodes/leetcode682/</link><pubDate>Sun, 10 Apr 2022 19:15:31 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode682/</guid><description>&lt;h2 id="leetcode-682---baseball-game"&gt;LeetCode 682 - Baseball Game
&lt;a class="header-anchor" href="#leetcode-682---baseball-game"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&amp;rsquo; scores.&lt;/p&gt;
&lt;p&gt;At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:&lt;/p&gt;</description></item><item><title>[Leetcode] Top K Frequent Elements(Medium)</title><link>http://localhost:1313/leetcodes/leetcode347/</link><pubDate>Sat, 09 Apr 2022 06:22:34 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode347/</guid><description>&lt;h2 id="leetcode-347---top-k-frequent-elements"&gt;LeetCode 347 - Top K Frequent Elements
&lt;a class="header-anchor" href="#leetcode-347---top-k-frequent-elements"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-0-1"&gt;&lt;a class="lnlinks" href="#hl-0-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-0-2"&gt;&lt;a class="lnlinks" href="#hl-0-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [1,1,1,2,2,3], k = 2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [1,2]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt" id="hl-1-1"&gt;&lt;a class="lnlinks" href="#hl-1-1"&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class="lnt" id="hl-1-2"&gt;&lt;a class="lnlinks" href="#hl-1-2"&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Input: nums = [1], k = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Output: [1]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="how-can-we-solve-this-problem"&gt;How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;這一題需要我們返回K個數量最多的element。所以，我們可以使用&lt;code&gt;map&lt;/code&gt;記錄我們array中element的個數，然後在把他們以&lt;code&gt;&amp;lt;frequency,element&amp;gt;&lt;/code&gt;存到&lt;code&gt;priority queue/max queue&lt;/code&gt;，最後只要返回&lt;code&gt;priority queue&lt;/code&gt;中的&lt;code&gt;k&lt;/code&gt;個element即可。&lt;/p&gt;</description></item><item><title>[Leetcode] Kth Largest Element in a Stream(Easy)</title><link>http://localhost:1313/leetcodes/leetcode703/</link><pubDate>Fri, 08 Apr 2022 20:21:39 +0800</pubDate><guid>http://localhost:1313/leetcodes/leetcode703/</guid><description>&lt;h2 id="leetcode-703---kth-largest-element-in-a-stream"&gt;LeetCode 703 - Kth Largest Element in a Stream
&lt;a class="header-anchor" href="#leetcode-703---kth-largest-element-in-a-stream"&gt;&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;
&lt;p&gt;Implement KthLargest class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KthLargest(int k, int[] nums)&lt;/code&gt; Initializes the object with the integer &lt;code&gt;k&lt;/code&gt; and the stream of integers nums.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int add(int val)&lt;/code&gt; Appends the integer val to the stream and returns the element representing the kth largest element in the stream.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;example:&lt;/p&gt;</description></item></channel></rss>