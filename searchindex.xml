<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>簡歷模板 Resume Template</title><url>https://ryantokmanmokmtm.github.io/resources/resume-template/</url><categories><category>resume</category><category>resources</category></categories><tags/><content type="html"> 中英文簡歷模板 English CV Template(docx) 中文模板(docx) 資料來源 DBC</content></entry><entry><title>透過Kops工具在AWS中部署K8S集群</title><url>https://ryantokmanmokmtm.github.io/post/kuberneters-on-aws/</url><categories><category>cloud native</category></categories><tags><tag>tutorial</tag></tags><content type="html"> 這篇文章主要是講述如何在AWS雲服務中部署Kubernetes集群 首先，我們需要準備使用一下工具進行設置
KOps - 一個能讓我們輕鬆無痛部署Kubernetes到任何雲服務的工具，可以想象為集群的kubectl AWS IAM - 申請一個能讓Kops存取權限的賬號 AWS S3 Bucket - 用來作為存取Kubernets資料的資料庫 AWS Route53 - 用於使用自定義Domain Name 並連接到Master Node中 GoDady - 作為DNS 服務供應商 前置工作 在電腦中安裝KOps工具用於幫助我們部署集群 想要了解更多關於KOps的讀者，可以參閱kOps-Kubernetes Operations
安裝: Linux
curl -Lo kops https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)/kops-linux-amd64 chmod +x kops sudo mv kops /usr/local/bin/kops Macos
curl -Lo kops https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)/kops-darwin-amd64 chmod +x kops sudo mv kops /usr/local/bin/kops 或者使用 Homebrew 安裝
brew update &amp;&amp; brew install kops Window
到KOps的github中的Release中下載kops-windows-amd64 重新命名為kOps，並設置為環境變數 安裝AWS Cli 到AWS 的官方網站中直接下載安裝即可 AWS CLI
設置IAM 賬號用於kOps 存取 AWS資源 如果還沒有AWS 賬號，可以先去申請一個再完成下面的步驟
透過UI設置
搜尋IAM,在Access management中選擇Users。 如下圖所示 新增用戶Add users,輸入使用者賬號並選擇Access key - Programmatic access。如下圖所示 3.選擇Attact existing policies directly並選擇以下的Policies
AmazonEC2FullAccess AmazonRoute53FullAccess AmazonS3FullAccess IAMFullAccess AmazonVPCFullAccess AmazonSQSFullAccess AmazonEventBridgeFullAccess 新增使用者 記錄Access key ID和Secret access key 打開Terminal設置AWS Cli的Configure中的存取賬號(KOps 會使用這組Token操作AWS)
aws configure
輸入剛才申請賬號的Access key ID(因我已經設置過了，就不重複設置了) 輸入剛才申請賬號的Secret access key(因我已經設置過了，就不重複設置了) Default region name 可以不輸入，使用DEFAULT即可 Default output format 可以不輸入 ，使用DEFAULT即可 透過AWS Cli 設置
aws iam create-group --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonEC2FullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonRoute53FullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/IAMFullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonVPCFullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonSQSFullAccess --group-name kops aws iam attach-group-policy --policy-arn arn:aws:iam::aws:policy/AmazonEventBridgeFullAccess --group-name kops aws iam create-user --user-name kops aws iam add-user-to-group --user-name kops --group-name kops aws iam create-access-key --user-name kops 記得要設置AWS
使用AWS Route53 設置DNS 故博主已在GoDady購買Domain Name - 所以以projectdomaindns.com
透過UI建立aws route53
搜尋Route53
新增Domain Name - 注意:Domain Name 必須要跟註冊的一樣！ 進入到建立好的Host,將裡面的Name Server(NS)到DNS 服務商中設定(以GoDady為例) Godady DNS設置跟Route53 NS一樣
透過Terminal建立 aws route53
注意:Domain Name 必須要跟註冊的一樣！
ID=$(uuidgen) &amp;&amp; aws route53 create-hosted-zone --name projectdomaindns.com --caller-reference $ID | jq .DelegationSet.NameServers 設置完畢後，會回傳一組NS,到DNS 供應商中設置為這組NS即可
使用AWS S3 用於保存Cluster資料 博主設置的地區是新加坡 - Asia Pacific (Singapore) ap-southeast-1 透過UI建立aws s3
搜尋aws S3 建立Bucket - Bucket名字必須是唯一的 要注意的是Region以及Block Public Access settings for this bucket
Region 要記得你設置的區域，建議跟部署集群地區一致~ Block Public Access 設置為public~ 透過Terminal建立 aws s3
aws s3api create-bucket --bucket k8s-example \ --region ap-southeast-1 \ --create-bucket-configuration LocationConstraint=ap-southeast-1 &ndash;create-bucket-configuration LocationConstraint=ap-southeast-1 這個設定對於us-east-1地區以外的都必須要加上，不然會出錯
以上都為準備階段，所要完成的工作，接下來就是重頭戲了！
透過kOps新增Cluster - 還沒正在開始建立(設定而已啦~) 先建立SSH-key - 之後登入到Cluster會用到這組key
ssh-keygen -f .ssh/id_rsa
kops create cluster \ --name=projectdomain.com \ --cloud=aws \ --zones= ap-southeast-1a\ --state=s3://k8s-example --master-size=t2.micro --node-size=t2.micro --node-count= --dns-zone=projectdomain.com name - K8S集群的名字 cloud - 雲服務商 zones - Nodes要部署的地區，而博主的設置的地區是ap-southeast-1,該對應的地區Code就是ap-southeast-1a master-size - master node的機器類型(可參考AWS) node-size - 一般node的機器的類型(可以參考AWS) node-count - 一般node的數量 state - 存放S3的Bucket 以上指令運行完後的結果如下:
如果設置完，需要修改可以使用 kops edit
建立Cluster 如果設定都沒有問題，就可以開始建立咯~ (有點久就是了 哈哈哈哈哈) 複製Finally configure your cluster with:後面的指令，加上--state=${s3 bucket url}
kops update cluster --name projectdomaindns.com --yes --admin --state=s3://k8s-bucket-demo 然後就是漫長的等待&hellip;&hellip; 5 - 20分鐘左右. 可以透過一下指令檢查是否完成部署，使用--wait 10m 10分鐘內會不斷的檢測~
kops validate cluster --wait 10m --state=${S3} 完成部署後，會顯示ready的狀態
透過kubectl get nodes也可以看到3個nodes,他們的Name就會是AWS EC2主機的名字咯~ 如果我們會看一下AWS上面的狀態，會發現EC2多了3台運行中的機器 Route53以及S3中也會有新的資料哦~ 如果讀書讀者的話,會發現api.projectdomaindns.com所導向的IP正是Master Node的public IP! 也就是說我們可以透過這個url直接存取Master Node！
AWS S3中也多出了Cluster的資料呢~ 使用Cluster 現在我們嘗試一下部署簡單的應用到這集群上看看能不能成功運行！
如果讀者還沒有學過K8S基礎，建議去K8S官網玩玩看教學！
這是我準備的簡單WebServer 應用,裡面只包含了一個API，透過/ping,server會回傳pong
// deploy.ymlapiVersion:apps/v1kind:Deploymentmetadata:name:demo-deployspec:selector:matchLabels:app:web-serverreplicas:3template:metadata:name:web-server-podlabels:app:web-serverspec:containers:- name:api-serverimage:jacksontmm/demo-server:v1ports:- containerPort:8080~ 上面這份config簡單來說就是會有3個一模一樣的pod,但是IP不同
建立Deployment物件
kubectl create -f deploy.yaml 透過kubectl get pods指令會發現有3個pod正在運行 透過kubectl get deploy指令會發現有一個deployment，也就是我們剛才所建立的deployment 物件 我們是沒有辦法直接存取Cluster內部的Pod的，所以必須先透過Service 物件來幫助我們，將他們expose出來，才能存取
以下指令會將我們Deployment物件的8080,透過與service expose出去
kubectl expose deploy demo-deploy --name=deploy-svc --type=NodePort --port=8080 執行kubectl get service會發現多了一個service的Name為deploy-svc，也就是我們剛才所建立的！ 現在我們只需要透過expose 的port,port:31176,就可以存取了！
注意：要先去將Master node(EC2)的31176 port 對外開放哦~ 不然會進不去 哈哈哈 - 設置secret group 的inbound 即可
打開瀏覽器輸入http://13.212.80.234:31176/ping,就會看到pong回傳回來!
13.212.80.234為Master node 的public ip
太棒了！恭喜我們成功上雲٩(˃̶͈̀௰˂̶͈́)و
如果想要刪除cluster的話,使用以下指令就可以把所有東西移除掉了唷(EC2,S3)！
kops delete cluster --name=${cluster name}--state=s3://${s3 name} --yes 參考資料 Kubernetes 30天學習筆記 kOps - Kubernetes Operations Manage Kubernetes Clusters on AWS Using Kops</content></entry><entry><title>[Side-Project] Movie App</title><url>https://ryantokmanmokmtm.github.io/project/movie-app/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> Movie App - Frontend
Movie App - Backend
簡介 開發這個App的目的主要是為了解決在搜尋電影OTT資源以及電影內容討論分散在多個不同平台等問題，如:搜尋到的資源是無效/不合法的，花費大量時間在搜尋上等等&hellip;。因此這個App主要分成2個組成部分，分別是電影資訊搜尋獲取OTT資源，並整合不同OTT平台的電影資源，供用戶選擇合法資源，並過濾無效資源以及電影分享社群，供用戶在觀看完電影後，直接在App中發佈相關文章以分享給其他用戶，而無需在不同平台發佈。
主要功能 用戶基本功能(登入/登出/修改資料等) 提供海量電影資源供用戶查閱(約100w+) 提供用戶點讚電影以及收藏電影 提供有效電影的OTT資源(如:Netfilx,Disney+,YoutubeTV等) 提供社群平台讓用戶發佈電影文章，對其他用戶的文章點讚,留言,回復留言等社群功能 提供用戶瀏覽其他用戶個人資訊(如:發佈之文章,點讚的電影,以及個人收藏的專輯) 用戶可與相互為朋友的用戶進行簡單文字交流,分享更多資訊 分享App文章到社交媒體(如: Instagram) 技術棧/工具 SwiftUI UIKit Comebine Go-Zero MySQL Gorm Docker Websocket CI/CD Pipeline (Github Action + AWS CodeDeploy) TMDB - 電影數據來源處 App 測試影片 階段性測試
最新版本</content></entry><entry><title>Leetcode 週賽第319場復盤總結</title><url>https://ryantokmanmokmtm.github.io/review/leetcode-contest319/</url><categories><category>summary</category></categories><tags/><content type="html"> 今日為2022年11月13日(週日) - Leetcode 週賽第319場 目前參加週賽主要的目的是學習跟訓練，所有當前主要focus在解Easy 跟 Medium的題目，Hard的題目暫且先跳過了
週賽題目如下: Convert the Temperature - Easy Number of Subarrays With LCM Equal to K - Medium Minimum Number of Operations to Sort a Binary Tree by Level - Medium Convert the Temperature - Easy You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.
You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].
Return the array ans. Answers within 105 of the actual answer will be accepted.
Example
Input: celsius = 36.50 Output: [309.65000,97.70000] Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70. Input: celsius = 122.11 Output: [395.26000,251.79800] Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798. 解題思路 這題沒有什麼難度呢，就直接代題目給的公式就可以AC了
class Solution { public: vector&lt;double> convertTemperature(double celsius) { double kelvin = celsius + 273.15; double Fahrenheit = celsius * 1.80 + 32; return {kelvin,Fahrenheit}; } }; Number of Subarrays With LCM Equal to K - Medium Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray&rsquo;s elements is k.
A subarray is a contiguous non-empty sequence of elements within an array.
The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.
Example
Input: nums = [3,6,2,7,1], k = 6 Output: 4 Explanation: The subarrays of nums where 6 is the least common multiple of all the subarray's elements are: - [3,6,2,7,1] - [3,6,2,7,1] - [3,6,2,7,1] - [3,6,2,7,1] Input: nums = [3], k = 2 Output: 0 Explanation: There are no subarrays of nums where 2 is the least common multiple of all the subarray's elements. 解題思路 這一題要注意的是LCM的計算以及subarry的定義
Subarray 是 在array中連續的一組array，跟subsequence不一樣呢~
這題的重點是要關注subarray的部分，也就是我們要知道[i : n-1] where i = 0 to n - 1的LCM是否與K相等。 所以我們要一個一個subarray的去找從size為1 擴展至n - i - 1, 檢查擴展的過程中是否存在LCM與K相等。
注：因為LCM的算計過程中會進行multipy,所以不能使用sign int, 需使用unsign int。否者會overflow.
class Solution { public: int subarrayLCM(vector&lt;int>&amp; nums, int k) { int ans = 0; for(int i = 0;i&lt;nums.size();i++){ unsigned int curLCM = 1; for(int j = i;j&lt;nums.size();j++){ curLCM = lcm(curLCM,nums[j]); //[for i to n] if(curLCM == k) ans++; } } return ans; } }; Minimum Number of Operations to Sort a Binary Tree by Level - Medium You are given the root of a binary tree with unique values.
In one operation, you can choose any two nodes at the same level and swap their values.
Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.
The level of a node is the number of edges along the path between it and the root node.
Example
1 / \ 4 3 / \ / \ 7 6 8 5 / / 9 10 Input: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10] Output: 3 Explanation: - Swap 4 and 3. The 2nd level becomes [3,4]. - Swap 7 and 5. The 3rd level becomes [5,6,8,7]. - Swap 8 and 7. The 3rd level becomes [5,6,7,8]. We used 3 operations so return 3. It can be proven that 3 is the minimum number of operations needed. 1 / \ 3 2 / \ / \ 7 6 5 4 Input: root = [1,3,2,7,6,5,4] Output: 3 Explanation: - Swap 3 and 2. The 2nd level becomes [2,3]. - Swap 7 and 4. The 3rd level becomes [4,6,5,7]. - Swap 6 and 5. The 3rd level becomes [4,5,6,7]. We used 3 operations so return 3. It can be proven that 3 is the minimum number of operations needed. 1 / \ 2 3 / \ / 4 5 6 Input: root = [1,2,3,4,5,6] Output: 0 Explanation: Each level is already sorted in increasing order so return 0. 解題思路(這題查的資料) 這題主要的難點是當我們拿到了每個level的Node的數時候，我們要怎麼得知最少的swap到正確的位置是多少呢？？
假設我們現在有下面的這個情況
2 - 4 - 1 - 5 我們要透過最少的swap的次數，使之變為有序的。 哪應該要怎麼解呢？
我們是不是只需要將他們移動到他們各自對應的正確的index就可以了呢?
比如: 2 - 4 - 1 - 5 這裡的1應該在index 0的位置,2應該在index 1 的位置,如此類推。最後就會得出 1 - 2 - 4 -5
由此可見，我們只需要將錯誤的index 與 正確的index連接在一起(也就是Swap) ，哪我們只要知道一共有多少條node連接到同一條edge上 , 哪我們就知道swap了多少回了。
例如： 7 6 4 5 => 7(移動到5的位置) -> 5(移動到6的位置) -> 6(移動到4的位置) -> 4代表了 swap(7,5) + swap(5,6) + swap(6,4) swap(7,5) => 5 6 4 7 swap(5,6) => 6 5 4 7 swap(6,4) => 4 5 6 7
只要對每層level建立一個directed graph就可以知道最少swap了多少次。
輔助函數 -> 因為我們計算的是edge的數目,而我們遍歷了node的數目，node = edge + 1,所以需要-1
int helper(vector&lt;int>&amp; res){ if(res.size() &lt;= 1) return 0; //no need int swapTime = 0; vector&lt;pair&lt;int,int>> g; for(int i = 0;i&lt;res.size();i++){ //building the graph //O(res.size()) g.push_back({res[i],i}); } sort(g.begin(),g.end());//sort it by value not index vector&lt;int> nodeVisited(res.size()); for(int i = 0;i&lt;res.size();i++){ //if current value need to keep in current index -> continue or is already swapped if(nodeVisited[i] || g[i].second == i) continue; int count = 0; int start = i; while(!nodeVisited[start]){ nodeVisited[start] = true; start = g[start].second; count++; } if(count > 1) swapTime += count - 1; } return swapTime; } 遍歷每一個Level，透過BFS即可
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minimumOperations(TreeNode* root) { if(root == nullptr) return 0; queue&lt;TreeNode*> q; q.push(root); int minTime = 0; while(!q.empty()){ int size = q.size(); vector&lt;int> res; for(int i = 0;i&lt;size;i++){ auto front = q.front();q.pop(); res.push_back(front->val); if(front->left != nullptr) q.push(front->left); if(front->right != nullptr) q.push(front->right); } minTime += helper(res); } return minTime; } int helper(vector&lt;int>&amp; res){ if(res.size() &lt;= 1) return 0; //no need int swapTime = 0; vector&lt;pair&lt;int,int>> g; for(int i = 0;i&lt;res.size();i++){ //building the graph //O(res.size()) g.push_back({res[i],i}); } sort(g.begin(),g.end());//sort it by value not index vector&lt;int> nodeVisited(res.size()); for(int i = 0;i&lt;res.size();i++){ //if current value need to keep in current index -> continue or is already swapped if(nodeVisited[i] || g[i].second == i) continue; int count = 0; int start = i; while(!nodeVisited[start]){ nodeVisited[start] = true; start = g[start].second; count++; } if(count > 1) swapTime += count - 1; } return swapTime; } }; 總結 對於Graph的處理以及思路需要加強改善, 特別是需要自己建立Graph的題目。</content></entry><entry><title>此版說明</title><url>https://ryantokmanmokmtm.github.io/review/intro/</url><categories/><tags/><content type="html"> 開啟該版主要是用於復盤/總結經歷，從而思考自總結己需要改善的部分。 主要focus(但不限於):
Leetcode 競賽題(AC/沒AC)的題目 Project 中解決的問題(問題於方法) 面試相關問題於總結</content></entry><entry><title>[Leetcode] Maximum Length of Repeated Subarray(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode718/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag></tags><content type="html"> LeetCode 718 - Maximum Length of Repeated Subarray Given two integer arrays ``nums1andnums2`, return the maximum length of a subarray that appears in both arrays.
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3,2,1]. Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0] Output: 5 How can we solve this problem? 這題要我們找出2個array中最長的相同subarray。這題有點類似於最長公共子序列,但是不同的是子序列不一樣的連續的,而subarray是必須要連續的。哪我們只需要改寫一下最長公共子序列,我們只需要更新相等的元素即可。其餘的都不需要關心。
Solution: class Solution { vector&lt;vector&lt;int>> dp; public: int findLength(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) { /* [0,1,1,1,1] [1,0,1,0,1] we need to know where the max length between num 1 and num 2 suppose i = 0,j = 0 dp[0][0] = the longest length of subarray in num2[i:n-1]num2[j:m-1] */ int n = nums1.size(); int m = nums2.size(); int res = 0; dp = vector&lt;vector&lt;int>>(n+1,vector&lt;int>(m+1,0)); for(int i = 1;i&lt;n+1;i++){ for(int j = 1; j &lt;m+1;j++){ if(nums1[i-1] == nums2[j-1]){ dp[i][j] = 1 + dp[i-1][j-1]; } res = max(dp[i][j],res); } } return res; } };</content></entry><entry><title>[Leetcode] Find Duplicate File in System(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode609/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>map</tag></tags><content type="html"> LeetCode 42 - Trapping Rain Water Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.
A group of duplicate files consists of at least two files that have the same content.
A single directory info string in the input list has the following format:
"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)" It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory "root/d1/d2/.../dm". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.
The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:
&ldquo;directory_path/file_name.txt&rdquo; Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)","root 4.txt(efgh)"] Output: [["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]] Input: paths = ["root/a 1.txt(abcd) 2.txt(efgh)","root/c 3.txt(abcd)","root/c/d 4.txt(efgh)"] Output: [["root/a/2.txt","root/c/d/4.txt"],["root/a/1.txt","root/c/3.txt"]] How can we solve this problem? 這題是也什麼難度，只要透過字串分隔和透過Map保存相同內容(Content)的路徑即可。
Solution: class Solution { public: vector&lt;vector&lt;string>> findDuplicate(vector&lt;string>&amp; paths) { //format : directory fileName(content) fileName2(contnet) //abcd : "root/a/1.txt","root/c 3.txt(abcd)" unordered_map&lt;string,vector&lt;string>> m; vector&lt;vector&lt;string>> res; for(auto &amp;str : paths){ //find root path int i = 0; int n = str.length(); while(i &lt; n){ if(str[i] == ' ')break; i++; } string root = str.substr(0,i); i++; //after sapce vector&lt;string> files; while(i &lt; n){ //find file name //find file content string fileName,fileContent; while(str[i] != '('){ fileName += str[i++]; } // cout &lt;&lt; fileName &lt;&lt; " "; i++; //skip ( while(str[i] != ')') fileContent += str[i++]; // cout &lt;&lt; fileContent &lt;&lt; endl; i+=2; //skip and move to next file m[fileContent].push_back(root + "/" + fileName); } } for(auto &amp;ele : m){ if(ele.second.size() > 1) res.push_back(ele.second); } return res; } };</content></entry><entry><title>Leetcode Weekly Contest 331(第一次參加競賽)</title><url>https://ryantokmanmokmtm.github.io/post/leetcodeweeklycontest331/</url><categories><category>leetcode contest</category></categories><tags/><content type="html"> 今天是我第一次參加Leetcode 雙週賽，所以想記錄一下今天的競賽題目。希望能透過博客來記錄自己的競賽狀況。
本週AC題數為:4/4
題目 2413. Smallest Even Multiple(EASY) - AC Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.
Example Input: n = 5 Output: 10 Explanation: The smallest multiple of both 5 and 2 is 10. Input: n = 6 Output: 6 Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself. Solution 這題主要是讓我們返回一個最小的整數是可以同時被n和2整除。哪解這題的思路也很簡單，就是如果n可以被2整除，就直接放回n否者就返回2 * n即可。
class Solution { public: int smallestEvenMultiple(int n) { return n % 2 == 0 ? n : 2 * n; } }; 2414. Length of the Longest Alphabetical Continuous Substring(Medium) - AC An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string "abcdefghijklmnopqrstuvwxyz".
For example, "abc" is an alphabetical continuous string, while "acb" and "za" are not. Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring. Example Input: s = "abacaba" Output: 2 Explanation: There are 4 distinct continuous substrings: "a", "b", "c" and "ab". "ab" is the longest continuous substring. Input: s = "abcde" Output: 5 Explanation: "abcde" is the longest continuous substring. Solution 這題主要是要讓我們在給定字串找到最長的按字母順序的長度(a之後一定是b,ac並不成立按字母順序)。我們可以透過Sliding Window的方式來幫助我們找到最長的。
如果當前window 長度為 0,向右滑動(往右增長) 如果當前字符為前面字符的ASCII CODE + 1，則符合按字母順序， 向右滑動(往右增長)。並更新最大值。 如果當前字符不為前面字符的ASCII CODE + 1，重置Window長度,並將window最左邊設置為當前位置。 class Solution { public: int longestContinuousSubstring(string s) { //longest continuous substring. //consecutive letters int res = 1; //at least one //continuous int left = 0; int right = 0; int i = 0; int n = s.length(); while(right &lt; n){ if(left == right) right++; else if((s[right] - 'a') == (s[right - 1] - 'a') + 1 ){ //check current right and previous right ++; res = max(res,right - left); }else left = right; //reset window } return res; } }; 2415. Reverse Odd Levels of Binary Tree(Medium) - AC Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.
For example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2]. Return the root of the reversed tree. A binary tree is perfect if all parent nodes have two children and all leaves are on the same level.
The level of a node is the number of edges along the path between it and the root node.
Example Input: root = [2,3,5,8,13,21,34] Output: [2,5,3,8,13,21,34] Explanation: The tree has only one odd level. The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3. Input: root = [7,13,11] Output: [7,11,13] Explanation: The nodes at level 1 are 13, 11, which are reversed and become 11, 13. Solution 這道題就是要讓我們翻轉Complete Binary Tree中，奇數層的Node。我們可以透過BFS來解題，會比較簡單，因為BFS可以很清楚的知道當前遍歷的是那一層。只要層數為奇數我們就做*數值交換(Swap)*即可。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* reverseOddLevels(TreeNode* root) { if(!root) return nullptr; queue&lt;TreeNode*> q; q.push(root); int depth = -1; while(!q.empty()){ int size = q.size(); depth++; vector&lt;TreeNode*> temp; for(int i = 0;i&lt;size;i++){ auto front = q.front();q.pop(); if(front->left) q.push(front->left); if(front->right) q.push(front->right); if((depth + 1) % 2 == 0) temp.push_back(front); } if((depth + 1) % 2 == 0){ int left = 0; int right = temp.size() - 1; while(left &lt; right){ swap(temp[left++]->val,temp[right--]->val); } } } // for(int i = 0;i&lt;node.size();i++){ // int left = 0; // int right = node[i].size() - 1; // while(left &lt; right){ // swap(node[i][left++]->val,node[i][right--]->val); // } // } return root; } }; 2416. Sum of Prefix Scores of Strings(Hard) - AC You are given an array words of size n consisting of non-empty strings.
We define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].
For example, if words = ["a", "ab", "abc", "cab"], then the score of &ldquo;ab&rdquo; is 2, since &ldquo;ab&rdquo; is a prefix of both "ab" and "abc". Return an array answer of size n where answer[i]s is the sum of scores of every non-empty prefix of words[i]. Note that a string is considered as a prefix of itself.
Example Input: words = ["abc","ab","bc","b"] Output: [5,4,3,2] Explanation: The answer for each string is the following: - "abc" has 3 prefixes: "a", "ab", and "abc". - There are 2 strings with the prefix "a", 2 strings with the prefix "ab", and 1 string with the prefix "abc". The total is answer[0] = 2 + 2 + 1 = 5. - "ab" has 2 prefixes: "a" and "ab". - There are 2 strings with the prefix "a", and 2 strings with the prefix "ab". The total is answer[1] = 2 + 2 = 4. - "bc" has 2 prefixes: "b" and "bc". - There are 2 strings with the prefix "b", and 1 string with the prefix "bc". The total is answer[2] = 2 + 1 = 3. - "b" has 1 prefix: "b". - There are 2 strings with the prefix "b". The total is answer[3] = 2. Input: words = ["abcd"] Output: [4] Explanation: "abcd" has 4 prefixes: "a", "ab", "abc", and "abcd". Each prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4. Solution 這題有一點難理解，就是要我們計算以words[i] 為prefix(以words[i][0...j]為前綴)的字符串有多少個。例如abc,他的prefix會有3個[a,ab,abc]。我們只要知道words中有哪些字符串以a、ab和abc為prefix，他們的個數加總起來便是words[i]的答案。
哪我們要怎麼知道有哪些字符串包含這些前綴呢？我們可以透過字典樹/前綴樹(Tire Tree)。
按著Words List 建立Tire Tree，並為每個Node設置一個Counter，用於計數有多少個字符有相同的prefix。 按著Words 遍歷Tire Tree並將經過的Tree Node的Counter的數值累加起來，便會得到words[i]的分數。 class TrieTree { public: TrieTree(){ children = vector&lt;TrieTree*>(26,nullptr); } int samePrefixCount = 0;//how many string have the same prefix vector&lt;TrieTree*> children; }; class Solution { public: vector&lt;int> sumPrefixScores(vector&lt;string>&amp; words) { TrieTree *root = new TrieTree(); for(int i = 0;i&lt;words.size();i++){ BuildTree(words[i],root); } vector&lt;int> res(words.size(),0); for(int i = 0;i&lt;words.size();i++){ res[i] = countPrefixSum(words[i],root); } return res; } void BuildTree(string&amp; str, TrieTree *root){ TrieTree *head = root; for(int i = 0;i&lt;str.length();i++){ if(head->children[str[i] - 'a'] == nullptr) head->children[str[i] - 'a'] = new TrieTree(); head = head->children[str[i] - 'a']; head->samePrefixCount++; } } int countPrefixSum(string&amp; str, TrieTree *root){ int count = 0; TrieTree *head = root; for(int i = 0;i&lt;str.length();i++){ head = head->children[str[i] - 'a']; count += head-> samePrefixCount; } return count; } }; 總結 今天這4道題可能是比較簡單，所以才能順利的做完。接下來每週都會去參加LeetCode競賽，不論有沒有做出來都會寫一篇文章做總結。希望自己能透過競賽知道自己的不足之處！</content></entry><entry><title>[Leetcode] Trapping Rain Water(Hard)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode42/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag></tags><content type="html"> LeetCode 42 - Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. example
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Input: height = [4,2,0,3,2,5] Output: 9 How can we solve this problem? 這題是給定一個array代表著高度，問我們一共可以裝多少水。這題的解題思路，假設當前是i,那我當前這個i是否可以裝水呢？我們是是不是要知道i的左手邊的最高的柱子(x)和最右手邊的最高的柱子(y)，那跟柱子比較矮而且是不是大於現在這個i。假設IFF x &lt; y &amp;&amp; x > i,哪i可以裝的水就會是x - i那麼多。所以說，我們必須要知道當前i的左邊最高和i的右邊最高是多少。哪要怎麼做呢？我們可以透過預處理的方式，預先計算左手邊(i之前)最大值以及右手邊(i之後)的最大值，然後在根據以上的方法即可解出答案。
Solution: class Solution { public: int trap(vector&lt;int>&amp; height) { int n = height.size(); /* how can we solve this problem? [i] can trap water ?? it determin the min(maxinum number [0..i] ,maxinum number [i...n-1]) but the problem is how can we know what is the maxinum height before i?[0...i] //maybe itself is the local maxinum height and how can we know what is the maxinum height after i ?// /maybe itself is the local maxinum height pre-calculating the left and the right?? */ vector&lt;int> leftHeight(n,0); vector&lt;int> rightHeight(n,0); //init case ->the first height is the maxinum heigh of left height //init case ->the last height is the maxinum heigh of right height leftHeight[0] = height[0]; rightHeight[n-1] = height[n-1]; //precalculating step for(int i = 1;i&lt;n;i++) leftHeight[i] = max(leftHeight[i-1],height[i]); //current i is the heigher one ? for(int i = n-2;i >= 0;i--) rightHeight[i] = max(rightHeight[i+1],height[i]); int res = 0; //calculating trapping water for(int i = 1;i&lt;n-1;i++){ //the first height and the last height can't trap any water res += min(leftHeight[i],rightHeight[i]) - height[i]; } return res; } };</content></entry><entry><title>[Leetcode] Palindrome Pairs(Hard)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode336/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>tire Tree</tag><tag>string</tag></tags><content type="html"> LeetCode 336 - Palindrome Pairs Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.
example
Input: words = ["abcd","dcba","lls","s","sssll"] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"] Input: words = ["bat","tab","cat"] Output: [[0,1],[1,0]] Explanation: The palindromes are ["battab","tabbat"] How can we solve this problem? 在解這題之前我們先要知道有哪些情況是成立Palindrome。
Case 1 ：2個字符串為反向字符串 - "abcd""dcba" => "abcd|dcba" Case 2 ：2個字符前中一個與另一個字符串的前面部分為Palindrome,剩餘未能匹配的部分也是一個 Palindrome - "abb""hcch|bba" => abbhc|chbba Case 3 : 2個字符的其中一個為空字符，而另外一個自己就是一個Palindrome - """aba" => "aba" 哪我們怎麼才能知道哪些字符串是某字符串的Palindrome呢？
我們可以透過Trie Tree(前綴樹)來幫助進行我們匹配。
注:建立樹時必須是反向的方式插入(abcd => dbca),這樣當我們進行搜尋或者匹配的時候，才知道哪些與當前字符串匹配
為了能匹配出Case 2，每遍歷一個Node,都需要檢查[0..j]是否為Palindrome，如果是插入當前字符串的index到當前的Node中，以便之後的匹配步驟。另外對於空字符串而已，需要插入至root的Node。(任何本來就是一個Palindrome的字符串也會出現在root的list(保存的是index)中："","aba","a","bbbabbb")
建立完成以後，便可以進行匹配。當遍歷到的Node是一個完整的字符串而且Index不等於自己以及剩餘的部分是一個Palindrome，也就是匹配到了我們的Case2，並加入至result。重複這個過程直到，遍歷完當前字符串。但是遍歷完當前字符串，並不代表沒有其他字符串可以組成Palindrome。之前建立Tree的時候，在這個Node中插入[0...j(當前的node)]字符串為Palindrome的index list,就可以直接使用了。只要index不等於當前的字符串的index直接加入到result即可。(匹配Case 2或者Case 3(如果是root的話)`)。
透過以上這些步驟就可以解決這一題(有點難度&hellip;哈哈哈)
Solution: class TrieNode { public: TrieNode(){ children = vector&lt;TrieNode*>(26,nullptr); } int index = -1; //if this variable is not -1 ,it means a word vector&lt;TrieNode*> children; //coz we are matched the prevous character a(xxx)|(rest of string is palindrome too)|(xxx) vector&lt;int> restPalindromeIndex; }; class Solution { public: vector&lt;vector&lt;int>> palindromePairs(vector&lt;string>&amp; words) { //distinct indices (i, j) TrieNode* root = new TrieNode(); for(int i = 0;i&lt;words.size();i++) BuildTrieTree(root,words[i],i); vector&lt;vector&lt;int>> res; //seach the palindrome for(int i = 0;i&lt;words.size();i++) search(res,i,words,root); return res; } void BuildTrieTree(TrieNode* root,string&amp; str,int wordIndex){ //insert the string in reverse order TrieNode* head = root; for(int i = str.length()-1;i>=0;i--){ if(isPalindrome(str,0,i)) head->restPalindromeIndex.push_back(wordIndex); //[0..j] is a Palindrome? record the index if(head->children[str[i] - 'a'] == nullptr) head->children[str[i] - 'a'] = new TrieNode(); head = head->children[str[i] - 'a']; } head->index = wordIndex; //after the string is inserted to the tree ,set the index head->restPalindromeIndex.push_back(wordIndex);//if empty string } void search(vector&lt;vector&lt;int>>&amp; res,int wordIdx,vector&lt;string>&amp; words,TrieNode* root){ if(!root) return; TrieNode* head = root; for(int i = 0;i&lt;words[wordIdx].length() &amp;&amp; head;i++){ //find the word if(head->index != -1 &amp;&amp; head->index != wordIdx &amp;&amp; isPalindrome(words[wordIdx],i,words[wordIdx].length() - 1)) res.push_back({wordIdx,head->index}); head = head->children[words[wordIdx][i] - 'a']; } //if there is no any character ,return it if(!head) return; //we need to add all string that is palindrome from [head(character to 0] //for example : str is aab and any string has same baa at the back //aab|(if sub string is palindrome with postfix (baa)) //if can make as a Palindrome Pairs //aab|(aba)baa => aaba b abaa => YES //aab|(cbc)baa => aabc b cbaa => YES //aab|(abba)baa => aabab babaa => YES for(auto index : head->restPalindromeIndex) if(index != wordIdx) res.push_back({wordIdx,index}); //distinct i and j } bool isPalindrome(string&amp; str,int l, int r){ while(l &lt; r &amp;&amp; str[l] == str[r]){ l++; r--; } return l >= r; } };</content></entry><entry><title>[Leetcode] Maximum Score from Performing Multiplication Operations(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1770/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>dp</tag><tag>dynamic programming</tag><tag>recursion</tag></tags><content type="html"> LeetCode 1770 - Maximum Score from Performing Multiplication Operations You are given two integer arrays nums and multipliers of size n and m respectively, where n >= m. The arrays are 1-indexed.
You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will:
Choose one integer x from either the start or the end of the array nums. Add multipliers[i] * x` to your score. Remove x from the array nums. Return the maximum score after performing m operations. example Input: nums = [1,2,3], multipliers = [3,2,1] Output: 14 Explanation: An optimal solution is as follows: - Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score. - Choose from the end, [1,2], adding 2 * 2 = 4 to the score. - Choose from the end, [1], adding 1 * 1 = 1 to the score. The total score is 9 + 4 + 1 = 14. Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] Output: 102 Explanation: An optimal solution is as follows: - Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score. - Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score. - Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score. - Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score. - Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. The total score is 50 + 15 - 9 + 4 + 42 = 102. How can we solve this problem? 這題最主要的重點是對於每個multipliers[i],它只能挑選最左邊或者最右邊的值。所有，我們需要知道multipliers[i]拿最左邊的值最後的結果比較大，還是拿最右邊後的結果比較大。為了避免重複計算而超時，所以我們需要使用dp來幫助我們記錄當前最優解。注:因multipliers最多為m個，所有最多只能從nums拿m個數字
dp 定義： dp[i][j], 從前面取了i個,以及後面取了j個，但是因為j很大(n-1),所以我們透過計算當前計算的multipliers的第k個來表示(n - j - i + 1)。當前的multipliers是k。 dp 初始條件 : init 為 INT_MIN Solution: class Solution { vector&lt;vector&lt;int>> dp; public: int maximumScore(vector&lt;int>&amp; nums, vector&lt;int>&amp; multipliers) { //n >= m //socre : 0 //m operations //[3,2,1] int m = multipliers.size(); int n = nums.size(); dp = vector&lt;vector&lt;int>>(m+1,vector&lt;int>(m+1,INT_MIN)); return solution(nums,multipliers,0,n-1,n,m); } int solution(vector&lt;int>&amp; nums, vector&lt;int>&amp; multipliers,int i,int j,int n,int m){ int currentMul = n - (j - i + 1); //the rest of size of the sub-array is the index of current multipliers if(currentMul == m) return 0; //current maxvalue = choose first or choose end? if(dp[i][currentMul] != INT_MIN) return dp[i][currentMul]; //choose the front val return dp[i][currentMul] = max( (nums[i] * multipliers[currentMul]) + solution(nums,multipliers,i+1,j,n,m),// take left (nums[j] * multipliers[currentMul]) + solution(nums,multipliers,i,j-1,n,m) //take right ); } };</content></entry><entry><title>[Leetcode] Pancake Sorting(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode969/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>reverse</tag><tag>recursive</tag></tags><content type="html"> LeetCode 969 - Pancake Sorting Given an array of integers arr, sort the array by performing a series of pancake flips.
In one pancake flip we do the following steps:
Choose an integer k where 1 &lt;= k &lt;= arr.length. Reverse the sub-array arr[0...k-1] (0-indexed). For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3. Return an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct. example
Input: arr = [3,2,4,1] Output: [4,2,4,3] Explanation: We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: arr = [3, 2, 4, 1] After 1st flip (k = 4): arr = [1, 4, 2, 3] After 2nd flip (k = 2): arr = [4, 1, 2, 3] After 3rd flip (k = 4): arr = [3, 2, 1, 4] After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted. Input: arr = [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted. How can we solve this problem? 這題我我們要關注的點是如何將當前數字範圍([0,n))中最大的元素移動到array的最後。從上述例子中，我們可以觀察到:
翻轉[0,最大值的Index] -> 最大值就會被移動到最前面 翻轉[0,n) -> 最大值就會被移動的最後面 我們只需要重複以上步驟，每次做完就代表著[n-i,n-1]的這段範圍是已經被排序了。所以，每次做完只關注n-i-i即可(就是當前位置的前面的所有未排序元素[x,x,x,|y(n-i),y,y(n-1)])。 Solution: class Solution { public: vector&lt;int> pancakeSort(vector&lt;int>&amp; arr) { vector&lt;int> res; /* [3,2,4,1] -> we need to move the large value to the end //move the large element to the front then flip n-1 [4,2,3,1] 4(3) [1,3,2,4] n 4 [3,1,2,4] 3(2) [2,1,3,4] n-1 3 [1,2,3,4] 1 ,3 2 ,4 */ // we need to push the large number to the back // so we need to find out the maxinum number in [0,n] // then reverse [0,maxinum index] and then reverse whole list to make the large number at the end of the list(n) for(auto it = arr.end(); it != arr.begin(); it--){ auto maxVal = max_element(arr.begin(),it); //where is this element in the list if(distance(maxVal,it) > 1){ //if current val is not the maxinum if(maxVal != arr.begin()){ //if current value is not the first one -> no need to put it at the front of the array reverse(arr.begin(),maxVal + 1); res.push_back(distance(arr.begin(),maxVal) + 1); } //move the maxinum value to the back reverse(arr.begin(),it); res.push_back(distance(arr.begin(),it)); //don't filp sorted element at the end of the array } } // filp(arr,arr.size()); return res; } // void filp(vector&lt;int>&amp; arr,int n){ // if(n == 0) return; // //find the maximun // int max = 0; // int idx = 0; // for(int i = 0;i&lt;n;i++){ // if(arr[i] > max){ // max = arr[i]; // idx = i; // } // } // // move the max value to the front -> flip idx + 1 // res.push_back(idx + 1); // //swap the value // swapVal(arr,0,idx); // //move the large element to the end // swapVal(arr,0,n-1); // res.push_back(n); // //need doing this approach til sorted // filp(arr,n-1); // } // void swapVal(vector&lt;int>&amp; arr,int i,int j){ // while(i &lt; j){ // int temp = arr[i]; // arr[i] = arr[j]; // arr[j] = temp; // i++; // j--; // } // } };</content></entry><entry><title>[Leetcode] Find Original Array From Doubled Array(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2007/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>hash map</tag></tags><content type="html"> LeetCode 2007 - Find Original Array From Doubled Array An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.
Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order. example
Input: changed = [1,3,4,2,6,8] Output: [1,3,4] Explanation: One possible original array could be [1,3,4]: - Twice the value of 1 is 1 * 2 = 2. - Twice the value of 3 is 3 * 2 = 6. - Twice the value of 4 is 4 * 2 = 8. Other original arrays could be [4,3,1] or [3,1,4]. Input: changed = [6,3,0,1] Output: [] Explanation: changed is not a doubled array. Input: changed = [1] Output: [] Explanation: changed is not a doubled array. How can we solve this problem? 這是其實需要我們計算每個數出現的頻率，如果要找出某個數x的雙倍數是否存在於array中，如果存在，我們只需要將x與雙倍數移除(因為每個x只會匹配到一個順便數)。如果不存在，也就代表了這個array並不是一個有效的Double list，直接return false即可。
Solution: class Solution { public: vector&lt;int> findOriginalArray(vector&lt;int>&amp; changed) { if(changed.size() % 2 != 0) return {}; //must be an even size vector&lt;int> res; int n = changed.size(); sort(changed.begin(),changed.end()); unordered_map&lt;int,int> m; for(auto num : changed) m[num]++; //number frequency for(auto num : changed){ if(m.count(num) &amp;&amp; m[num] > 0){ //num is exist? m[num]--; if(!m.count(num * 2) || m[num*2] == 0){ //num * 2 is not exist or num*2 is empty return {}; }else { m[num * 2]--; res.push_back(num); } } } return res; } };</content></entry><entry><title>[Leetcode] Pseudo-Palindromic Paths in a Binary Tree(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1457/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>recursive</tag><tag>XOR</tag></tags><content type="html"> LeetCode 1457 - Pseudo-Palindromic Paths in a Binary Tree Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.
Return the number of pseudo-palindromic paths going from the root node to leaf nodes. example
Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). Input: root = [2,1,1,1,3,null,null,null,null,null,1] Output: 1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). Input: root = [9] Output: 1 How can we solve this problem? 這一題簡單的來說就是讓我們從Binary Tree中找到有幾條path是一個Palindromic(Pseudo-Palindromic)偽迴文串。 也就是說從root到leaft的path是一個Palindromic。 (我們只需要知道path是否能組成Palindromic即可)
哪我們要怎麼知道path是不是Palindromic的呢?
解決這個問題之前,我們先來看一下Palindromic分成了以下2個case。
Odd(Path長度為基數): aabbdbbaa => a:2,b:2, d:1 從這裡我們可以看得出來,只會有1個值/字符是基數,其餘的都會是偶數。
Even(Path長度為偶數): aabb => a:2,b:2 從這裡我們可以看得出來,所有值/字符都是偶數。
所以,我們可以直接通過一個array幫助我們計數有多少個值為基數。如果基數數目小於或者等於1的話,就符合了以上這2個條件，否則不能組成一個Palindromic。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int res = 0; int counter = 0; public: int pseudoPalindromicPaths (TreeNode* root) { vector&lt;int> counter(10,0); // from 1 - 9 solution(root,counter); return res; } void solution(TreeNode* root,vector&lt;int> &amp;counter){ //m uses to count how many number in the path //for odd case there will only remind 1 number such that xyzUyxz l //for even case there will not remind any number such that any number in the path occurs twice //example : xxyyzz -> rerange as xyzzyx if(root == nullptr) return; counter[root->val]++; if(!root->left &amp;&amp; !root->right){ //vector sum num be 0 or 1 int oddOccur = 0; for(auto n : counter){ if(n % 2 == 1) oddOccur ++; } //odd element at most appears once if(oddOccur &lt;= 1) res++; counter[root->val]--; return; } solution(root->left,counter); solution(root->right,counter); //check counter[root->val]--; } };</content></entry><entry><title>[Leetcode] UTF-8 Validation(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode393/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>binary</tag><tag>bit operation</tag></tags><content type="html"> LeetCode 393 - UTF-8 Validation Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
For a 1-byte character, the first bit is a 0, followed by its Unicode code. For an n-bytes character, the first n bits are all one&rsquo;s, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10. This is how the UTF-8 encoding would work:
Number of Bytes | UTF-8 Octet Sequence | (binary) --------------------+----------------------------------------- 1 | 0xxxxxxx 2 | 110xxxxx 10xxxxxx 3 | 1110xxxx 10xxxxxx 10xxxxxx 4 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx example
Input: data = [197,130,1] Output: true Explanation: data represents the octet sequence: 11000101 10000010 00000001. It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. Input: data = [235,140,4] Output: false Explanation: data represented the octet sequence: 11101011 10001100 00000100. The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that's correct. But the second continuation byte does not start with 10, so it is invalid. How can we solve this problem? 這一題其實也不太算是算法題, 只是單純的驗證是不是一個合法的UTF-8。只要根據題目給你條件，就可以判斷出是不是合法的了。
要解這題我們需要判斷UTF-8的長度是多少，然後根據這個長度檢測是否包含了這裡多個BYTE(n-1)即可。
UTF-8 長度為1 => 沒有其他組成部分，所有ByteCount會是0 UTF-8 長度為2 => 組成部分包含了2個(包含自己),所以ByteCount會是1 UTF-8 長度為3 => 組成部分包含了3個(包含自己),所以ByteCount會是2 UTF-8 長度為4 => 組成部分包含了4個(包含自己),所以ByteCount會是3 因此讀取到(110xx xxx)/(1110 xxxx)/(1111 0xxx) 為UTF-8開頭,接下來就會包含n-1個為10xx xxxx的BYTE(1-byte的除外(0xxx xxxx))。如果不符號這個條件直接返回false即可。
小提示：
0(b00000000) - 127(b01111111) : 0xxx xxxx的最小值與最大值的範圍
128(b10000000) - 191(b10111111) : 10xx xxxx的最小值與最大值的範圍
192(b11000000) - 223(b11011111) : 110x xxxx的最小值與最大值的範圍
224(b11100000) - 239(b11101111) : 1110 xxxx的最小值與最大值的範圍
240(b11000000) - 247(b11011111) : 1111 0xxx的最小值與最大值的範圍
Solution: class Solution { public: bool validUtf8(vector&lt;int>&amp; data) { ios_base::sync_with_stdio(false); cin.tie(nullptr); //UTF 8 1 to 4 bytes //1 byte character -> 8bit -> the first bit is 0 -> unicode //n byte ->first n bytes -> 1 then n+1 -> 0(at most 4) //starting at 2th byte to n-1 byte -> the most significant 2 bits should be 10 /* suppose n = 4 //first number only 11110xxx = 2^3(xxx) (128,64,32,16,8,4,2,1) 1 1 1 1 0 x x x 128+64+32+16 */ /* 0xxxxx data[i] */ int n = data.size(); int byteCount = 0; for(int i = 0;i&lt;n;i++){ //there may be not only one nbyte code?? if(byteCount == 0){ if(data[i] >= 0 &amp;&amp; data[i] &lt; 128 ) byteCount = 0; // for unicode else if(data[i] >= 192 &amp;&amp; data[i] &lt; 224) byteCount = 1; else if(data[i] >= 224 &amp;&amp; data[i] &lt; 240) byteCount = 2; else if(data[i] >= 240 &amp;&amp; data[i] &lt; 248) byteCount = 3; else return false; }else { if(data[i] &lt; 128 || data[i] > 191) return false; //less/greater than 10xxxxx byteCount--; } } // return byteCount == 0; } };</content></entry><entry><title>[Leetcode] Bag of Tokens(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode948/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>greedy</tag><tag>sort</tag><tag>two pointer</tag></tags><content type="html"> LeetCode 948 - Bag of Tokens You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed).
Your goal is to maximize your total score by potentially playing each token in one of two ways:
If your current power is at least tokens[i], you may play the ith token face up, losing tokens[i]power and gaining 1a score. If your current score is at least 1, you may play the ith token face down, gaining tokens[i] power and losing 1 score. Each token may be played at most once and in any order. You do not have to play all the tokens. Return the largest possible score you can achieve after playing any number of tokens.
example
Input: tokens = [100,200], power = 150 Output: 1 Explanation: Play the 0th token (100) face up, your power becomes 50 and score becomes 1. There is no need to play the 1st token since you cannot play it face up to add to your score. Input: tokens = [100,200,300,400], power = 200 Output: 2 Explanation: Play the tokens in this order to get a score of 2: 1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1. 2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0. 3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1. 4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2. How can we solve this problem? 這題的解題思路是這樣透過貪心(gready),也就是說我能用多少power換分就用多少，如果不夠了我就用分換power。換句話說，就是先從最低的token開始換,直到足夠的power後，就以分來換取最高的power,直到不符合條件未知或者沒有任何token可以買為止。
因為要知道當前最大和最小，所以要先排序
Solution: class Solution { public: int bagOfTokensScore(vector&lt;int>&amp; tokens, int power) { //maxinum if(tokens.empty())return 0; int score = 0; sort(tokens.begin(),tokens.end()); /* strategy: get the mininum token if not enough -> get maxinum token if it has enough power -> get this token */ int i = 0; int j = tokens.size() - 1; int res = 0; while(i &lt;= j){ if(power >= tokens[i]){ score += 1; power -= tokens[i++]; res = max(res,score); }else if(score > 0){ score -= 1; power += tokens[j--]; } else break; } return res; } };</content></entry><entry><title>[Leetcode] The Number of Weak Characters in the Game(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1996/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 1996 - The Number of Weak Characters in the Game You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.
A character is said to be weak if any other character has both attack and defense levels strictly greater than this character&rsquo;s attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj attacki and defensej > defensei.
Return the number of weak characters.
example
Input: properties = [[5,5],[6,3],[3,6]] Output: 0 Explanation: No character has strictly greater attack and defense than the other. Input: properties = [[2,2],[3,3]] Output: 1 Explanation: The first character is weak because the second character has a strictly greater attack and defense. How can we solve this problem? 這題就是要我們找出多少個弱角色(會被攻擊的人)。對於這種包含了2個維度資訊的題目(attack,defense)，直接藉並不好解，所以，通常我們都會固定一個維度去解另外一個維度，這樣就會相對容易許多。
這題我們可以透過固定attack這個維度。因為我們知道高attack的可以攻擊低attackd的人。所以我們根據attack做排序。這樣attack就會是單調遞增排序。我們自然就可以不讓管這個維度(因為已經符合 attacki &lt; attackj 這個條件)。之後我們只需要處理defense這個維度就可以了。
defense這個維度必須以單調遞減的方式處理! 為什麼呢?
假設 Attack : [[1,1],[1,2],[2,4]] -> 這裡會有2個attack為1的角色。如果不以遞減的方式除了,這樣就會不符合條件(相同attack不能互打)。所以一遞減方式會變成這樣[[1,2],[1,1]...]，這樣一來就能避免互打的情況
解決完維度問題後，就很簡單了，只需要透過stack就可以知道有多少個人被攻擊了。只要進來的人defense的比stack top的人defense 大就+1即可。
Solution: class Solution { public: int numberOfWeakCharacters(vector&lt;vector&lt;int>>&amp; pro) { //[attacki, defensei] sort(pro.begin(),pro.end(),[&amp;](auto &amp;a1,auto &amp;a2){ if(a1[0]==a2[0]){ return a1[1]>a2[1]; } return a1[0]&lt;a2[0]; }); /* 3: 6 5: 5 6: 3 */ /* get the maxinum defense value from previous group if previous group defense value is greater the current group characteri -> this guy is the weak one in this case: [9,1] is a weak character [10,5] ->[9,1] [10,4] ->[9,1] [10,3] ->[9,1] [10,2] ->[9,1] [9,2] is a weak character [10,5] ->[9,3] [10,4] ->[9,3] */ int res = 0; stack&lt;int> s; for(int i = 0;i&lt;pro.size();i++){ while(!s.empty() &amp;&amp; s.top() &lt; pro[i][1]){ s.pop(); res++; } s.push(pro[i][1]); } return res; } };</content></entry><entry><title>[Leetcode] Binary Tree Inorder Traversal(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode94/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>traversal</tag></tags><content type="html"> LeetCode 94 - Binary Tree Inorder Traversal Given the root of a binary tree, return the inorder traversal of its nodes&rsquo; values.
example
Input: root = [1,null,2,3] Output: [1,3,2] Input: root = [] Output: [] Input: root = [1] Output: [1] How can we solve this problem? 這題很簡單,只要使用中序遍歷即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int> inorderTraversal(TreeNode* root) { vector&lt;int> res; inorder(root,res); return res; } void inorder(TreeNode* root,vector&lt;int>&amp; res){ if(!root) return; inorder(root->left,res); res.emplace_back(root->val); inorder(root->right,res); } };</content></entry><entry><title>[Leetcode] Construct String from Binary Tree(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode606/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>array</tag><tag>recursive</tag><tag>dsf</tag></tags><content type="html"> LeetCode 606 - Construct String from Binary Tree Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.
Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. example
Input: root = [1,2,3,4] Output: "1(2(4))(3)" Explanation: Originally, it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)" Input: root = [1,2,3,null,4] Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output How can we solve this problem? 這題就是要讓我們講以string的方式輸出Binary Tree。只要注意他的規則就可以解決這題。
node的children都會被()包裹住 node如果有left-child沒有right-child可以無視right-child的() node如果有right-child沒有left-child,left-child的位置必須包含一個()
根據以上這幾條輸出規則，透過postorder traversal就可以解決。 postorder traversal : traverse Left-child -> Right-child -> self node
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: string tree2str(TreeNode* root) { string res; solution(root,res); return res; } //Solution A string constructStr(TreeNode* root){ if(!root) return ""; string cur = to_string(root->val); if(root->left) cur += '(' + tree2str(root->left) +')'; else if(root->right) cur += "()"; //for no left child but right child case if(root->right) cur += '(' + tree2str(root->right) +')'; return cur; } //Solution B void solution(TreeNode* root,string &amp;res){ if(!root) return; res += to_string(root->val); if(root->left || root->right){ res+= "("; solution(root->left,res); res+= ")"; if(root->right){ res+= "("; solution(root->right,res); res+= ")"; } } } };</content></entry><entry><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode442/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>hash map</tag></tags><content type="html"> LeetCode 442 - Find All Duplicates in an Array Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
You must write an algorithm that runs in O(n) time and uses only constant extra space. example
Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] Input: nums = [1] Output: [] How can we solve this problem? 這題要我們找出所有在Array裡重複出現2次的數字。解法也很簡單, 因為題目也說了數字會出現1次或者2次,哪我們可以透過Map來計數,但當前數字已經出現過1次,也就代表當前數字是重複了2次,加入到結果即可。
Solution: class Solution { public: vector&lt;int> findDuplicates(vector&lt;int>&amp; nums) { vector&lt;int> res; // unordered_map&lt;int,int> m; int n = nums.size(); vector&lt;int> m(nums.size() + 1); // 1 - n for(int i = 0;i&lt;n;i++){ if (m[nums[i]] == 0) { m[nums[i]] ++; }else{ res.emplace_back(nums[i]); } } return res; } };</content></entry><entry><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode2196/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>array</tag><tag>hash map</tag></tags><content type="html"> LeetCode 2196 - Create Binary Tree From Descriptions You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,
If isLefti == 1, then childi is the left child of parenti. If isLefti == 0, then childi is the right child of parenti. Construct the binary tree described by descriptions and return its root. The test cases will be generated such that the binary tree is valid. example
Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] Output: [50,20,80,15,17,19] Explanation: The root node is the node with value 50 since it has no parent. The resulting binary tree is shown in the diagram. Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]] Output: [1,2,null,null,3,4] Explanation: The root node is the node with value 1 since it has no parent. The resulting binary tree is shown in the diagram. How can we solve this problem? 這是給定一個2維的Array,根據Array[i]建構一棵Binary tree。主要得問題是哪一個是成為Tree root呢?要怎麼知道有哪些Child Node呢?
我們透過Map來幫助我們記錄所有Child Node,以便之後的建構 因每個Child Node都必須有一個Parent Node,也就是說在Map中能找到的Node必定是有Parent的，當找到1個Node沒有在Map中，也就代表著該Node必定是整棵Binary Tree的Head。
根據1跟2的邏輯,並使用一個Loop來建構Binary Tree即可。 Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* createBinaryTree(vector&lt;vector&lt;int>>&amp; des) { unordered_map&lt;int,TreeNode*> m; TreeNode* head = nullptr; //creating all node ->child node for(int i = 0;i&lt;des.size();i++) m[des[i][1]] = new TreeNode(des[i][1]); // all child node,except head node for(int i = 0;i&lt;des.size();i++){ //getting root node from map if(m.find(des[i][0]) == m.end()){ //getting head node TreeNode* root = new TreeNode(des[i][0]); head = root; m[des[i][0]] = root; } if(des[i][2]){ m[des[i][0]]->left = m.find(des[i][1]) == m.end() ? new TreeNode(des[i][1]) : m[des[i][1]]; }else { m[des[i][0]]->right = m.find(des[i][1]) == m.end() ? new TreeNode(des[i][1]) : m[des[i][1]];; } } return head; } };</content></entry><entry><title>[Leetcode] Binary Tree Pruning(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode814/</url><categories><category>leetcode</category></categories><tags><tag>binary tree</tag><tag>dfs</tag><tag>recursive</tag></tags><content type="html"> LeetCode 814 - Binary Tree Pruning Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.
A subtree of a node node is node plus every node that is a descendant of node.
example
Input: root = [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property "every subtree not containing a 1". The diagram on the right represents the answer. Input: root = [1,0,1,0,0,0,1] Output: [1,null,1,null,1] How can we solve this problem? 這題是要讓我們移除所有不包含1的sub-tree。所以，我們只要透過DFS判斷一下node的left-sub tree 以及 right-sub tree 是否都不包含1: 1. 如果左右子樹都不包含1且當前node為0, 直接返回nullptr 2. 若當前節點為1就返回自身 2. 左子樹不包含1, 當前node的左子樹設成nullptr;同理右子樹不包含1,當前node 的右子數設為nullptr
Solution: class Solution { public: TreeNode* pruneTree(TreeNode* root) { if(!root) return nullptr; root->left = solution(root->left); //contain 1? root->right = solution(root->right); //contain 1? if (root->val == 0 &amp;&amp; !root->left &amp;&amp; !root->right) return nullptr; //remove itself return root; } // TreeNode* solution(TreeNode* root){ // if(!root) return nullptr; // root->left = solution(root->left); //contain 1? // root->right = solution(root->right); //contain 1? // if(root->val == 0 &amp;&amp; !root->left &amp;&amp; !root->right) return nullptr; //remove itself // return root; // } // bool solutionA(TreeNode* root){ // if(!root) return false; // if(!root->left &amp;&amp; !root->right) return root->val == 1; // bool left = solution(root->left); //contain 1? // bool right = solution(root->right); //contain 1? // if(!left) root->left = nullptr; // if(!right) root->right = nullptr; // return left || right || root->val == 1; // } };</content></entry><entry><title>[開發日記]OTT電影社群APP(一)</title><url>https://ryantokmanmokmtm.github.io/post/dev-ottapp-1/</url><categories><category>side-project</category><category>ios</category><category>dev-diary</category></categories><tags><tag>ios</tag><tag>dev</tag></tags><content type="html"> 最近這2個月都沒有更新發文章，主要是因為這2個月都在專注重構畢業專題的項目，也是只OTT電影平台。
今天這篇文章主要是跟大家分享這2個月所開發的進度和目前開發到的階段，以此作為這個項目的開發日記。
目前的成果 廢話少說，先上圖！
前端UI: 主界面 包含APP4個主要得核心功能
電影預覽與電影搜尋 - 提供了以電影類別預覽以及根據電影情況的預覽。如熱門電影,最受歡迎等&hellip; 用戶電影評論與影評分享 - 可允許用戶在觀看完電影後，寫下觀後感與他人分享 聊天與通知 - 可與朋友進行即時討論 用戶個人頁 - 包含了用戶基本訊息,發佈的文章,喜歡的電影以及收藏的電影 電影搜尋/預覽界面 功能如下：
讓用戶以文字的方式進行電影的查詢
讓用戶按著電影類別來預覽不同的電影
未實現功能如下：
刷新以及獲取更多資料 電影資訊界面 功能如下：
提供電影基本以及詳細資訊(包含電影說明,演員,成員,宣傳影片等) 為用戶提供OTT資源(如有串流平台提供資源)，並直連至該平台進行觀看 為用戶提供相似的電影 用戶可以點讚或者收藏電影 未實現功能如下：
刷新以及獲取更多資料 用戶社群與文章發佈界面 功能如下：
為用戶推送最新的電影評論文章 為用戶推送關注用戶的最新評論文章 用戶可以對文章直接評論以及點讚 用戶可以自行建立文章，發表電影感想 文章都會提供電影導向連接，可直接跳轉至電影詳細 未實現功能如下：
留言點讚 刷新以及獲取更多資料 聊天與通知界面 這部分的界面目前只使用了假數據進行UI設計，還沒設計對應的API
這部分會使用到Websocket 技術的幫助(還在研究當中QQ)
未實現功能如下：
用戶與用戶之間的對話 為用戶推送點讚,關注,留言的通知 直接搜尋好友進行通訊 刷新以及獲取更多資料 個人與他人資訊界面 功能如下：
用戶可以編輯更新個人資訊 用戶可以觀看用戶發表文章 用戶可以觀看用戶點讚電影 用戶可以觀看用戶收藏列表 用戶可以建立自定義的片單 未實現功能如下：
移除片單 移除片單中的電影 刷新以及獲取更多資料 後端API 已完成 SERVER HEALTH USER API USER GENRE API MOVIE API USER GENRE API POST LIKES API LIKED MOVIE API COMMENT LIKES API FRIEND API COMMENT API 待完成 Websocket 消息推送 Unit Test 部署至K8S以及AWS 總結 以上內容就是我7-8月之間所完成的開發事項。但APP還有很多地方沒有完成和完善！讓我們期待下一次的開發日記(*❦ω❦)
謝謝各位的耐心觀看！</content></entry><entry><title>[Leetcode] Reverse Linked List II(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode92/</url><categories><category>leetcode</category></categories><tags><tag>list</tag><tag>recursive</tag></tags><content type="html"> LeetCode 92 - Reverse Linked List II Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.
example
Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Input: head = [5], left = 1, right = 1 Output: [5] How can we solve this problem? 這一題的問題非常的簡單,就是要讓我們在給定的一個list中翻轉(Reverse)[left,right]之間的Node,並返回結果。這題跟Reverse Linked List I解法類似,不同的是多了個翻轉範圍。
首先，我們要做的是在的翻轉的開始的位置。然後再透過recursive來翻轉List,最後返回的node/head再由left位置的Node的前一個Node接起來(如有)就可以了~
Solution: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { ListNode* theNodeAfter = nullptr; // ListNode* pre = nullptr; // ListNode* starting = nullptr; // ListNode* last = nullptr; // ListNode* first = nullptr; public: ListNode* reverseBetween(ListNode* head, int left, int right) { // if(head->next == nullptr) return head; // if(left == right) return head; // //getting the starting point // int n = right - left; // starting = head; // while(--left > 0){ // pre = starting; // starting = starting->next; // } // // cout &lt;&lt; starting->val &lt;&lt; endl; // reverseList(0,n,starting); //reverse list between left and right // if(pre != nullptr) pre->next = first; // else head = first; // last->next = afterBreak; if(left == 1){ //found //reverse the list return reverseList(right,head); //reverse the list and return the new head which node is the right node } head->next = reverseBetween(head->next,left - 1,right - 1); //keep finding the starting point return head; } ListNode* reverseList(int right,ListNode* head){ if(right == 1){ theNodeAfter = head->next; return head; } ListNode* last = reverseList(right-1,head->next); head->next->next=head; head->next=theNodeAfter; // return last; } // void reverseList(int i ,int n,ListNode* head){ // if(i == n){ // afterBreak = head->next; // head->next = nullptr; // first = head; // last = head; // return; // } // reverseList(i+1,n,head->next); // head->next =nullptr; // last->next = head; // last = last->next; // } };</content></entry><entry><title>[Leetcode DP] K Inverse Pairs Array(Hard)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode629/</url><categories/><tags/><content type="html"> 這題主要是學習DP思想，做個小記錄
LeetCode 629 - K Inverse Pairs Array For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &lt;= i &lt; j &lt; nums.length and nums[i] > nums[j].
Given two integersn and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7.
example:
Input: n = 3, k = 0 Output: 1 Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. Input: n = 3, k = 1 Output: 2 Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. How can we solve this problem? 題解 這題就是說給定一個數字n,從[1,n]中所能組成inverse pair為k組的有多少種組合方法。
INVERSE PAIR 的定義：
i &lt; j 且 num[i] > nums[j]
如 [2,1] 的INVERSE PAIR為1; 相反[1,2]的INVERSE PAIR 為 0
解法 這題我們需要使用到DP(動態規劃)
DP規劃:
題目很明確的問了我們在n array 中所能組成K個inverse pair有多少個，所以DP[i][j]表示的是i個數字在array中,組成j。 定義DP[n+1][k+1] 計算DP的值
假設已知dp[4][j], j:0....k 加入4呢? [x,x,x](1-3的任意組合) + 4 dp[4][j] => 加入4到array 中為j個 inverse pair</content></entry><entry><title>[Leetcode DP] Counting Bits(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes338/</url><categories><category>leetcode</category></categories><tags><tag>bit operation</tag><tag>dynamic programming</tag></tags><content type="html"> LeetCode 338 - Counting Bits Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1&rsquo;s in the binary representation of i.
example:
Input: n = 2 Output: [0,1,1] Explanation: 0 --> 0 1 --> 1 2 --> 10 Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 --> 0 1 --> 1 2 --> 10 3 --> 11 4 --> 100 5 --> 101 How can we solve this problem? 這題要我們解決的問題是給定一個數字n,回傳0 - n中每個數字包含了多少個為1的bits。例如: n=2 => 00,01,10,回傳的結果便會是[0,1,1]。
Bit Operation approach 這裡我們可以透過bit operation AND 來解決這個問題。從Truth Table中: A B Y(AND) 0 0 0 0 1 0 1 0 0 1 1 1 我們可以到只有1AND1才會是True,所有我們只需要對每一個bit與當前counter的值做AND,如果為1就bitCounter++就可以計算出每一個值的bits的數目。
因為一個Int類型為4BYTE,包含了32個bits,所以對於[0,n]中每一個數字都必須做32次的LOOP,因此Time Complexity是O(32N)。
Solution: class Solution { public: vector&lt;int> countBits(int n) { for(int i = 0;i&lt;n+1;i++){ int temp = 0; for(int j = 0;j&lt;=31;j++){ if( (1 &lt;&lt; j) &amp; i) temp++; } res[i]=temp; } return res; } }; Dynamic Programming approach 我們可以先觀察一下每個數字的Binary,以n=8為例: 從圖中我們可以看得到只有1個bit為1的數字都是2i,而我們所需要計算的[2i , 2i+1-1]之間的數字的數目即可。 但是,我們要怎麼計算呢?
首先,我們需要知道怎麼計算[2i , 2i+1-1]裡面的bits的數目,然後我們在觀察一下Binary: 如下圖: 我們可以發現[2i , 2i+1-1]都會想相隔2i-1個，也就是說我們只需要定義一個變數j作為offset 就可以移動到需要計算數字的位置( 0 &lt;= j &lt;= 2i-1 )。例如: i=2(22 = 4),2+0(2),2+1(3)。
接下來,我們可以透過DP來幫助我們計算。
定義BASE CASE:
DP[0] = 0 //number 0 不包含任何1&rsquo;s
根據目前2i,求出DP[2i+j] = DP[j],直到計算到(n)
注意: i 會根據i是否到達2i,最後進行Left-Shift(Double自己)
注意: j 作為[0,2i)的指標
例如:
DP[1] = DP[0] + 1 //比DP[0] 多一Bits
DP[2] = DP[0] + 1 //比DP[0] 多一Bits => 也可以視為在2的區間的1, DP[1] = DP[2] = 1
DP[3] = DP[1] + 1 //比DP[1] 多一Bits DP[4] = DP[0] + 1 //比DP[1] 多一Bits
Solution: class Solution { public: vector&lt;int> countBits(int n) { //Trying to use DP vector&lt;int> dp(n + 1); //from 0 to n dp[0] = 0; //base case int bits = 1; //2^0 = 1 int i = 0; while(bits &lt;= n){ //bits will be pow of 2 ->1,2,4,8,16,24 while(i&lt;bits &amp;&amp; i + bits &lt;= n){ dp[i + bits] = dp[i] + 1; i++; } i = 0; bits = bits &lt;&lt; 1; //double bits value // cout &lt;&lt; bits; } return dp; } };</content></entry><entry><title>[Leetcode] Kth Largest Element in an Array(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes215/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>array</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 1268 - Search Suggestions System Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
example:
Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 How can we solve this problem? 這題要我們解決的問題是回傳在sorted array(Input Array沒有排序)中第kth大的元素。最簡單的解法是直接排序,然後回傳kth元素即可。但是, 這裡我們也可以使用Priority Queue(Heap)來幫我們解決這個問題。因為Priority Queue的特性,越大的值(MaxHeap)/越小的值(MinHeap)會越接近root,也就是說最大值(MaxHeap)/最小值(MinHeap)會在root。所以我們可以運用MinHeap來幫助的我們解決這個問題,只要Priority Queue裡面的元素多於K個我們就會把top的值移除，因更小的值會在前面,每次pop的值都會是當前最小的值,直到最後，省下來的值的root/top就會是我們的第K個最大的值，而priority queue中最後一個值便會是Input中最大的值。
Solution: class Solution { public: int findKthLargest(vector&lt;int>&amp; nums, int k) { priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; for(int i = 0;i&lt;nums.size();i++){ q.push(nums[i]); if(q.size() > k) q.pop(); } return q.top(); } };</content></entry><entry><title>[Leetcode] Furthest Building You Can Reach(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcodes1642/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>heap</tag><tag>priority queue</tag><tag>greedy</tag></tags><content type="html"> LeetCode 1642 - Furthest Building You Can Reach You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.
You start your journey from building 0 and move to the next building by possibly using bricks or ladders.
While moving from building i to building i+1 (0-indexed),
If the current building&rsquo;s height is greater than or equal to the next building&rsquo;s height, you do not need a ladder or bricks. If the current building&rsquo;s height is less than the next building&rsquo;s height, you can either use one ladder or (h[i+1] - h[i]) bricks. Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally. example:
Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 Output: 4 Explanation: Starting at building 0, you can follow these steps: - Go to building 1 without using ladders nor bricks since 4 >= 2. - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7. - Go to building 3 without using ladders nor bricks since 7 >= 6. - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9. It is impossible to go beyond building 4 because you do not have any more bricks or ladders. Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 Output: 7 Input: heights = [14,3,19,3], bricks = 17, ladders = 0 Output: 3 How can we solve this problem? 這個要我們解決的問題是給定一定數量的磚塊brick和梯子ladder,問我們最遠能到達哪一棟建築(array index)。 我們主要注意的是題目給定的幾個限制條件。
如果i+1的建築比i建築矮,我們可以不用任何磚塊(bricks)或者梯子ladders 如果i+1的建築比i建築搞，我們必須使用一個梯子ladders或者(h[i+1] - h[i])個磚塊(bricks) 從這裡我們可以看到梯子ladders無論建築有多高，我們都可以到達。相反磚塊(bricks)則需要數量。所以，我們要解決這個問題會優先考慮使用梯子ladders。如果梯子ladders 使用完畢，我們可以將前面2個建築之間高度最小的梯子ladders回收,使用磚塊(bricks)取代。如果磚塊(bricks)也不夠或者超出提供的數量，就代表我們最遠可以到達的建築為i-1(因為i建築,我們沒有足夠的磚塊brick和梯子ladder)。如果梯子的數量跟建築的數量一樣多,直接回傳最後一棟(n-1)即可。
Solution: class Solution { public: int furthestBuilding(vector&lt;int>&amp; h, int bricks, int ladders) { //Using all ladders first //if there is no other ladders,we try to use bricks(mininum one) instead of a ladder //if there have enough ladders //just return n-1(index) priority_queue&lt;int, vector&lt;int>, greater&lt;int>> laddersUsed; //min heap //O(n*log l(min Head insert)) for(int i = 1;i&lt;h.size();i++){ //use all ladders int climbingHeigh = h[i] - h[i-1]; if(climbingHeigh &lt;= 0) continue; //we can climb it laddersUsed.push(climbingHeigh); //our ladder is enough? if(laddersUsed.size() &lt;= ladders) continue; //our ladder is not enough //try to use bricks to instead if our bricks is not enough too,return previous index(neither bricks nor ladders can reach ith building) bricks -= laddersUsed.top(); laddersUsed.pop(); if(bricks &lt; 0) return i-1; } return h.size() - 1; } //Time Exceed // int dfs(vector&lt;int>&amp; h,int i,int bricks, int ladders){ // if(bricks &lt; 0 || ladders &lt; 0) return i-1; // // if(bricks == 0 &amp;&amp; ladders == 0) return i; // if(i == h.size()-1) return i; // int res = 0; // if(h[i] > h[i+1]) { // res = solution(h,i+1,bricks,ladders); // }else{ // //either bricks ladders // int bricksCase = solution(h,i+1,bricks - (h[i+1]-h[i]),ladders); // int laddersCase = solution(h,i+1,bricks,ladders-1); // res = max(bricksCase,laddersCase); // } // return res; // } };</content></entry><entry><title>TrieTree(前綴樹/字典樹)</title><url>https://ryantokmanmokmtm.github.io/notes/trietree/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>data structure</tag></tags><content type="html"> Introduction 什麼是TrieTree? Trie稱為前綴樹或字典樹,是有序樹的一種,Node的key通常為String類型。Trie Tree與Binary-Searching Tree不同的點是,Trie Tree的Key並不會直接保存在Node中,而是它在Tree中的位置所決定的。一個Node中的所有的childrens都有相同的Prefix(前綴)。假設有個Node的key 為T,它的children將會是Time, Tim, Test等,因為他們都會相同的Prefix(前綴)T。
Trie Tree 的應用 字符前綴匹配 - 網頁URL,搜尋等 搜索關鍵字時,返回前綴最相似的可能結果 Trie Tree 結構圖 Trie Tree Template class TrieNode{ public: TrieNode(){ //suppose we are considering a string consist with a-z //at most 26 childrens for a node child = vector&lt;TrieNode*>(26); } vector&lt;TrieNode*> child; // bool isWord = false; //indicate current word is a word void AddNode(string&amp; str){ TrieNode*root = this; for(int i = 0;i&lt;str.length();i++){ //adding a node that key is str[i] if(!root->child[str[i] - 'a']) root->child[str[i] - 'a'] = new TrieNode(); root = root->child[str[i] - 'a']; } } //Other function define here... //Find a word etc... }; 參考資料 https://zh.wikipedia.org/wiki/Trie</content></entry><entry><title>[Leetcode] Short Encoding of Words(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode802/</url><categories/><tags><tag>string</tag><tag>array</tag><tag>TrieTree</tag></tags><content type="html"> 820 - Short Encoding of Words A valid encoding of an array of words is any reference string s and array of indices indices such that:
words.length == indices.length The reference string s ends with the '#' character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i]. Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.
example:
Input: words = ["time", "me", "bell"] Output: 10 Explanation: A valid encoding would be s = "time#bell#" and indices = [0, 2, 5]. words[0] = "time", the substring of s starting from indices[0] = 0 to the next '#' is underlined in "time#bell#" words[1] = "me", the substring of s starting from indices[1] = 2 to the next '#' is underlined in "time#bell#" words[2] = "bell", the substring of s starting from indices[2] = 5 to the next '#' is underlined in "time#bell#" Input: words = ["t"] Output: 2 Explanation: A valid encoding would be s = "t#" and indices = [0]. How can we solve this problem? 這題看上去好像很難理解它要我們解決什麼問題。但是我們可以從例子中可以觀察到他就只是單純用#來分隔每個子串。例如:time,me,bell會以這樣的方式進行Encoding,time#me#bell。但是問題要找出我們最短的是Encoding 長度為多少，也就是有重疊的Word我們無需額外加入到子串中，就剛才的例子我們可以看得出來time和me都包含了me。所以,我們Encoding會從time#me#bell縮短為time#bell#
哪我們要怎麼知道是否不用額外加入到字串中呢? 題目中有給出幾個條件(不符合條件需插入至String結尾):
對於任何words[j],從string中的indices[i] 到#前,與words[j]相同,也就是與words[j]是string的後綴(suffix)。例如：time和me, me是time的後綴。 words[i]的長度等於indices的長度。也就是words[i]-indices會等於words[j]。例如words[i]為4,indices為1,words[j]為2。4-1 != 2，也就是代表words[j]不是words[i]的後綴。 Solution: 我們可以透過Tire Tree來解決這個問題。因為我們要知道words有沒有相同後綴(suffix),所以建構Tree的時候,需要放過來插入。直到 leaf(葉子) 就會知道當前有相同後綴(suffix)的長度為多少，最後加總加一起，就是我們要的結果。
class TrieNode{ public: TrieNode(){ node = vector&lt;TrieNode*>(26); } vector&lt;TrieNode*> node; }; int AddWord(TrieNode* root,string&amp; w){ int res = -1; //if some words have the same suffix,it will return 0 ,-1+'#' = 0 for(auto i = w.rbegin();i&lt;w.rend();i++){ if(!root->node[*i - 'a']){ root->node[*i - 'a'] = new TrieNode(); res = w.length(); } root = root->node[*i - 'a']; } return res + 1; //extra } class Solution { public: int minimumLengthEncoding(vector&lt;string>&amp; words) { int res = 0; sort(words.begin(),words.end(),[&amp;](string&amp; a, string&amp; b){ return a.length() > b.length(); }); TrieNode* root = new TrieNode(); for(int i = 0;i&lt;words.size();i++) res += AddWord(root,words[i]); // findShortWords(0,root,res); return res; } }; 另外一種解法是我們只需要知道哪些words[j]跟words[i]有共同的suffix且符合條件。
過濾掉重複的words,並生成unique的list 大到小排序(根據字串的長度),因為我們要知道words[i]是否包含了words[j]。如果words[i].length() &lt; words[j].length()就一定不會包含。 計算長度: 看看words[j]有沒有符合條件 words[j]可能在words[i]不只出現過一次。所以我們需要找出所有可能。直到找出符合條件的或者沒有找到符合條件的。例如:timt(i),t(j), j在i出現了2次,而且有一個是符號條件的,也就是indices為3的t。 class Solution { public: int minimumLengthEncoding(vector&lt;string>&amp; words){ set&lt;string> unique(words.begin(),words.end()); //O(n) vector&lt;string> list; for(auto word : unique) list.push_back(word); //O(n) //sorting by word size //O n log n sort(list.begin(),list.end(),[&amp;](string&amp; a,string&amp; b){ return a.length() > b.length(); }); vector&lt;int> v(list.size(),0); int res = 0; //O n*n-1 = n^2 for(int i = 0;i&lt;list.size();i++){ if(v[i]) continue; for(int j = i+1;j&lt;list.size();j++){ int index = list[i].find(list[j]); if(index == -1) continue; //not found,go to next one if(index != -1 &amp;&amp; list[i].length() == index + list[j].length()){ v[j] = 1; }else{ while((index = list[i].find(list[j],index)) != -1){ if(list[i].length() == index + list[j].length()) { v[j] = 1; break; } index ++; } } } res += list[i].length() + 1; //adding extra # } } };</content></entry><entry><title>[Leetcode] Longest Palindromic Substring(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode5/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>dynamic programming</tag></tags><content type="html"> LeetCode 5 - Longest Palindromic Substring Given a string s, return the longest palindromic substring in s.
example
Input: s = "babad" Output: "bab" Explanation: "aba" is also a valid answer. Input: s = "cbbd" Output: "bb" How can we solve this problem? 要解決這題，我們必須要先知道什麼是Palindrome。可以參考這篇文章Palindromic string迴文。而這題要我們找出在給定string中,找到最長的Palindrome。我們可以透過以每個單一字元(index i)以及倆個字元(index i,index i+1)為中心點，並擴展left,right找出他們的局部的最長Palindrome為多少，然後根據這個長度計算starting point i以及記錄長度len,最後以starting point和len得出字串中str[startingPoint,len]為解。
Solution: class Solution { public: string longestPalindrome(string s) { /* Using an easy solution "babad" finding all posible palindrome string starting at index i(mid point) odd case: i-1 i i+1 ? Palindrome i-2 i-1 i i+1 i+2 ?Palindrome what about even case.We're simply starting at index i and i+1 i-1 [i,i+1] i+2 ?Palindrome */ int n = s.length(); int len = 0; int startPoint = 0; //O(n * n(finding Palindrome)) for(int i = 0;i&lt;n;i++){ int cur = max(getLen(s,i,i,n),getLen(s,i,i+1,n)); // which one is longest? odd or even if(cur > len){ //update our len and starting point len = cur; startPoint = i - (len-1)/2; //(len-1) for even case //suppose the len is 3 and the index is 1 ,then the starting point will be 1 - (3-1)/2 => 0-> len str[0...2] //suppose the len is 4 and the index is 1 ,then the starting point will be 1 - (4-1)/2 => 0-> len str[0...2] } } return s.substr(startPoint,len); } //str[i..j] is our middle point of Palindrome int getLen(string&amp;str,int i,int j,int n){ //left(i) right(j) while(i>=0 &amp;&amp; j&lt;n &amp;&amp; str[i] == str[j]){ i--; j++; } //string at i+1 and getting //|y|x2|x1|x|x1|x2|y| => the length of this string is l - r + 1 -(out of bounds of both i and j => 2) => l-r-1 return j-i-1; //string at i+1(is decreased from the loop),total } };</content></entry><entry><title>Palindromic String(迴文字串)</title><url>https://ryantokmanmokmtm.github.io/notes/palindromicstring/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>string</tag><tag>dynamic programming</tag></tags><content type="html"> Introduction 什麼是Palindromic String 迴文字串 所謂的Palindromic String(迴文字串) 就是以一個字元為中間，而它的左邊以及右邊的組成字元相同。
例子:
abcdcba 以d為中心的左跟右的字元一樣。
cdc左跟右都為c
bcdcb 左跟右都為b
abcdcba 左跟右都為a
要怎麼知道String是否為什麼是palindrome(迴文) 要知道String是否palindrome，我們先得知道Palindromic的規則:
單一的字元都是Palindromic，例如: a,b,g&hellip; 某字元的左右字元相同,例如: xax,xbx,xgx&hellip; 某字元自己跟右邊或者左邊相同也是一個也使一個palindrome。例如aa,bb 如果某子串為palindrome,而左跟右字元相同，它也會是一個palindrome。例如palindromeaba,它的左右2邊都為字元x,xabax也使一個palindrome; 相反，左跟右字元不相同,則只有子字串為palindrome。 判斷是否palindrome string 我可以從子串的中心點(middle point)開始往外擴展i,j,如果i跟j位置的為相同字元,則繼續往外擴。如果過程中有i,j位置的字元不相同,我們就可以知道它不是一個palindrome。
在尋找Palindrome的時候，我們必要要考慮到odd和evencase。
odd case : 會以odd基數的方式擴展。 例如: a -> bab -> cbabc&hellip; even case: 會以even偶數的方式擴展 例如: aa -> baab -> cbaabc&hellip; 什麼時候會出現這種情況呢? 例如這個例子:baab。如果只使考慮到odd case,他會被認為不是一個Palindrome。baa,aab&hellip;都不是合法的Palindrom。所以,我們必須考慮到even case。aa,baab是合法的Palindrom。
Palindrome Template //O(n) bool isPalindrome(string str,int i,int j){ while(i>=0 &amp;&amp; j &lt; str.length()){ if(str[i] != str[j]) return false; i--; j++; } return true; } //中心點為Odd(i) isPalindrome(str,i,i); //中心點為even(i,i+1) isPalindrome(str,i,i+1);</content></entry><entry><title>Longest Common SubString(最長公共子序列)</title><url>https://ryantokmanmokmtm.github.io/notes/lcm/</url><categories><category>leetcode template</category><category>leetcode note</category><category>coding skill</category></categories><tags><tag>dynamic programming</tag></tags><content type="html"> Introduction 什麼是最長公共子序列? 給定2個字串string A和string B,2個字串中所共同擁有的最長的子字串。
例如:
StringA:leetcodeStringB:ecbod他們的最長公共子序列便是`ecod`解釋:StringA包含了__e_cod_=>ecodStringB包含了ec_od=>ecod要怎麼找到最長公共子序列LCM呢? 我們需要定義一個數組用於保存當前情況下的最優解,也就是使用DP的方式。我們需要以每個字符最為考量,並一一匹配，最後得出整體最優解。 LCM Code Template int longestCommonSubStr(string &amp;s1, string &amp;s2){ int n = s1.length(); int m = s2.length(); vector&lt;vector&lt;int>> dp(n+1,vector&lt;int>(m+1,0)); for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=m;j++){ if(s1[i-1] == s2[j-1]) dp[i][j] = 1 + dp[i-1][j-1]; //the LCM of previous size + current matched else dp[i][j] = max(dp[i-1][j],dp[i][j-1]); //strA[0..i-2] str[0...j-1] or strA[0..i-1] str[0...j-2] check which one have the longest LCM } } return dp[n][m]; } 參考資料 经典动态规划：最长公共子序列</content></entry><entry><title>MetaHuman虛擬數字人初探</title><url>https://ryantokmanmokmtm.github.io/post/Mataverse-MataHuman/</url><categories><category>mateverse</category><category>modeling</category></categories><tags><tag>matehuman</tag></tags><content type="html"> 因為元宇宙(Metaverse)這個概念火熱,所有我就趁著這個機會了解一下在元宇宙領域中本人覺得比較有趣的東西。也就是這篇文章所要分享給各位的MetaHuman(虛擬數字人/虛擬數位人)
什麼是MetaHuman(虛擬數字人/虛擬數位人)呢? 所謂的MetaHuman(虛擬數字人)是具有數字化形象的虛擬人物，並且具備特定的相貌、性格和性別等人物特征、具備語音，面部表情和肢體動作表達的能力以及擁有人類的思想會具有外界環境與人交流的互動能力。 這裡只是簡略的介紹一下。如果各位對虛擬數字人技術或者發展剛興趣的,可以參考這份虛擬數字人白皮書
簡單數字人實作 注:本實作之數字人透過輸入自定義音頻生成，並無溝通等能力
使用工具:
Reallusion Character Creator Reallusion IClone 實作步驟也十分的簡單:
我們將透過Reallusion Character Creator製作我們數字人的外觀,然後再將數字人傳入Reallusion IClone做動畫,也就是透過IClone的音頻生成數字人動畫的功能製作動畫。
Step 1:
進入Reallusion Character Creator製作角色(以博主自定義的角色為例)，如下圖: Step 2:
將剛才在CC(Character Creator) 製作的角色匯入到IClone中,如下圖:
Character Creator中: File->Export->Send to IClone 匯入音頻文件
Modify->Facial->Create Script->Audio File 預覽動畫結果，並渲染動畫 Demo展示 燈光一展示:
燈光二展示
結論 有沒有發現很簡單又很好玩呢!我們透過Reallusion工具讓我們能在很短的時間內就可以完成一個屬於自己的MetaHuman。除此之外Reallusion還提供很多很強大的功能，例如:圖片生成3D角色模型,手機臉部動作捕捉,與Unreal Engine 5的MetaHuman工具連動等等，有機會的話再跟大家分享。
參考資料:
Reallusion</content></entry><entry><title>[Leetcode] Combination Sum III(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode216/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag><tag>recursion</tag><tag>back-tracking</tag></tags><content type="html"> LeetCode 216 - Combination Sum III Find all valid combinations of k numbers that sum up to n such that the following conditions are true:
Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. example
Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination. How can we solve this problem? 這題主要關注的點是數字範圍為[1,9]，每個結果中，數字只能使用一次，而且數字必須是順序排列。例如:2,3,4,1,2,5。解決這題我們可以用back-traking大法。只要我們當前的Sum大於n我們就直接退回back track回上一步,因為數值只會越來越大，並不是我們想要的。如果Ans我們所需的k個就直接判斷是否等於n，如果是就直接加入到我們的result即可。
Solution: class Solution { vector&lt;vector&lt;int>> res; vector&lt;int> tmp; public: vector&lt;vector&lt;int>> combinationSum3(int k, int n) { solution(n,k,0,1); return res; } void solution(int n,int k,int sum,int start){ if(k==0){ if(sum == n) res.push_back(tmp); return; } if(sum > n) return; for(int i = start;i&lt;=9;i++){ tmp.push_back(i); solution(n,k-1,sum + i,i+1); tmp.pop_back(); } } };</content></entry><entry><title>[Leetcode] Letter Combinations of a Phone Number(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode17/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>recursion</tag><tag>back-tracking</tag></tags><content type="html"> LeetCode 17 - Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
example
Input: digits = "23" Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"] Input: digits = "" Output: [] Input: digits = "2" Output: ["a","b","c"] How can we solve this problem? 這題是要我們拿到Input的數字所能組合出所有字串。解法也很簡單，我們可以透過Map記錄每個數字代表來那些字符，然後再透過Back-tracking技巧來幫助我們組合字串。你有可能會問什麼是Back-tracking。簡單來說就是一個Recursive Function,但他會迴避一些不正常的數值。比如:&ldquo;abc&rdquo;,而"abc"可能不是我們要的。因此退回上一步的"ab",並嘗試其他數值/結果。
Solution: class Solution { unordered_map&lt;char,string> temp = { {'2',"abc"}, {'3',"def"}, {'4',"ghi"}, {'5',"jkl"}, {'6',"mno"}, {'7',"pqrs"}, {'8',"tuv"}, {'9',"wxyz"} }; public: vector&lt;string> letterCombinations(string digits) { vector&lt;string> res; if(digits.length() == 0) return res; solution(res,0,digits,""); return res; } void solution(vector&lt;string>&amp; res,int index,string &amp;digits,string phone){ if(index == digits.length()){ res.push_back(phone); return; } auto numList = temp[digits[index]]; for(int i = 0;i&lt;numList.length();i++){ phone += numList[i]; solution(res,index+1,digits,phone); phone.pop_back(); } } };</content></entry><entry><title>[Leetcode] Flatten Nested List Iterator(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode341/</url><categories><category>leetcode</category></categories><tags><tag>design</tag><tag>recursion</tag><tag>iteration</tag></tags><content type="html"> LeetCode 341 - Flatten Nested List Iterator You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.
Implement the NestedIterator class:
NestedIterator(List&lt;NestedInteger> nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. Your code will be tested with the following pseudocode:
initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res If res matches the expected flattened list, then your code will be judged as correct.
example
Input: nestedList = [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Input: nestedList = [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. How can we solve this problem? 這一題就是一題設計的題目,可以想象成是一個FileSystem，裡面可能存的是文件(Integer)或者是文件夾(List)。因此，我們可以發現他就是一顆Tree。所以，我們只要從左到右拿到Integer,並順序輸出即可。
如圖:
Solution(Recursion): 我們可以在initial透過Recursive Function來遍歷Input,並把所有Integer先Push到Array/List裡面。然後在定義一個pointer用於存取Next的值即可。
/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger> &amp;getList() const; * }; */ //calling hasNext -> next class NestedIterator { vector&lt;int> ans; // vector&lt;NestedInteger> list; int cur = 0; void getValue(vector&lt;NestedInteger>&amp; data){ for(int i = 0;i&lt;data.size();i++){ if(data[i].isInteger()) ans.push_back(data[i].getInteger()); else getValue(data[i].getList()); } } public: NestedIterator(vector&lt;NestedInteger> &amp;nestedList) { getValue(nestedList); } int next() { return ans[cur++]; } bool hasNext() { return cur &lt; ans.size() ? true:false; } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Solution(Iteration): 這個解法是透過在Calling hasNext()的時候將當前container的最前面的那個element展開來(如果是一個list)，並把展開來的element放到container最前面，從而確保來container的最前面的element是Integer,呼叫next()時，都會return Int。
/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger> &amp;getList() const; * }; */ //calling hasNext -> next class NestedIterator { // vector&lt;int> ans; vector&lt;NestedInteger> list; public: NestedIterator(vector&lt;NestedInteger> &amp;nestedList) { list = nestedList; } int next() { //here we always return the first one // cout &lt;&lt; storage.size() &lt;&lt; endl; int res = storage.begin()->getInteger(); // cout &lt;&lt; res &lt;&lt;endl; storage.erase(storage.begin()); return res; } bool hasNext() { //we check our storage here //if the first elements is not a integer ,we try to get the interget from the list and append to our storage while(!storage.empty() &amp;&amp; !storage.front().isInteger()){ //get the first one from the storage vector&lt;NestedInteger> data = storage.front().getList(); storage.erase(storage.begin()); //append to the front of the storage that retrieved from the list for(int i = data.size()-1;i>=0;i--) storage.insert(storage.begin(),data[i]); } // if(storage.front().isInteger()) cout &lt;&lt; storage.front().getInteger(); return !storage.empty(); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */</content></entry><entry><title>[Leetcode] 132 Pattern(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode456/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 456 - 132 Pattern Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].
Return true if there is a 132 pattern in nums, otherwise, return false. example
Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Input: nums = [3,1,4,2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2]. Input: nums = [-1,3,2,0] Output: true Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. How can we solve this problem? 這題就是要我們找出List有沒有符合132 Pattern。那怎麼才算是132 Pattern呢。從題目定義可以看出在List中任意的nums[i] &lt; nums[k] &lt; nums[j]，也就是說nums[k]為最大,nums[j]為第二大,nums[i]`為第三大。
那要怎麼找到是不是符合呢?
假設我們現在的位置是nums[j],我們是否能在找到[0 - j)這個範圍內找到nums[k]以及nums[i]且符合nums[i] &lt; nums[k] &lt; nums[j]就好了呢?
哪我們應該要怎麼做呢?
因為nums[i]都是會是132 pattern當中最小的的值。因此每當iterate時，記錄當前值的左邊的最小的值(當前這個值可能會是k，最小值可能會是i)。當我要判斷一個值是不是j時，我們只需要拿到比他大的值，然後再透過記錄在此值得最小值，跟j做比較是不是符合nums[i] &lt; nums[j]這個條件，我們就可知道當前的j是不是我們要找的。
解題步驟如下:
我們要記錄每個值的左手邊的最小值，用於判斷是不是nums[i] 我們要用定義一個pointer暫存目前的最小值 當我們要判斷當前的值是否會構成132 Pattern,就從先前的記錄中獲取比較當前值還要大的記錄，並且透過記錄中的最小值判斷是不是也小於j,從而得出結論。 Solution: class Solution { public: bool find132pattern(vector&lt;int>&amp; nums) { //i &lt; k &lt; j //if there exist one return true return solution(nums); } // bool burstForce(vector&lt;int>&amp; nums){ // int n = nums.size(); // for(int i = 0;i&lt;n;i++){ // for(int j = i+1;j&lt;n;j++){ // for(int k = j + 1;k&lt;n;k++) // if(nums[i] &lt; nums[j] &amp;&amp; nums[j] > nums[k] &amp;&amp; nums[i] &lt; nums[k]) return true; // } // } // return false; // } bool solution(vector&lt;int>&amp; nums){ //current k int curMin = nums[0]; stack&lt;pair&lt;int,int>> s; //&lt;num,minBeforeNum> for(int i = 1;i&lt;nums.size();i++){ //nums[i] repersent the j //and top will be our k and check min before k while(!s.empty() &amp;&amp; nums[i] >= s.top().first){ //finding the k before j s.pop(); } //checking the top elements of the stack if(!s.empty() &amp;&amp; s.top().second &lt; nums[i]) return true; //checking //push to stack s.push({nums[i],curMin}); curMin = min(nums[i],curMin); } return false; } };</content></entry><entry><title>[LeetCode] Remove All Adjacent Duplicates in String II(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1209/</url><categories><category>leetcode</category></categories><tags><tag>string</tag><tag>stack</tag></tags><content type="html"> LeetCode 1209 - Remove All Adjacent Duplicates in String II You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.
example
Input: s = "abcd", k = 2 Output: "abcd" Explanation: There's nothing to delete. Input: s = "deeedbbcccbdaa", k = 3 Output: "aa" Explanation: First delete "eee" and "ccc", get "ddbbbdaa" Then delete "bbb", get "dddaa" Finally delete "ddd", get "aa" Input: s = "pbbcggttciiippooaais", k = 2 Output: "ps" How can we solve this problem? 這題就是要我們刪除掉在String裡面某些相鄰且相同並重複了k次的Characters。例如: aeee,k=3，輸出a。如果我們要解決這個問題就要知道目前string裡面有哪些subString符合條件，但是這裡要注意一個問題就是有些Substring被移除後，會使前(刪除Str)後2個substring符合條件。例如:aeeeaa,但我們刪除eee後,aaa也會符合條件，因此會被移除。
哪我們要怎麼知道哪些characters符合條件呢?
這裡我們可以使用Stack/Array來幫組我們解題。為什麼是用Stack? 因為我們只需要關注當前str[i]是否與前一個str[i-1]一致,如果是一致的我們會加入到Stack.top的Counter裡面。只要Counter的值為k我們就知道是符合條件的String，移除即可。最後，把Stack/Array裡面剩餘的元素串接就可以得出最後答案(注:Stack元素串接需要Reverse結果)。
Solution: class Solution { public: string removeDuplicates(string s, int k) { if(s.length() &lt; k) return s; string res; vector&lt;pair&lt;char,int>> counter; //O(n) for(auto str : s){ //how many same character if(counter.empty() || counter.back().first != str) counter.push_back({str,1}); else{ counter.back().second++; } if(counter.back().second == k) counter.pop_back(); } // for(auto e:vc) cout &lt;&lt; e; //O(i*k &lt;= n ) => O(n); for(int i = 0;i&lt;counter.size();i++){ for(int j = 0;j&lt;counter[i].second;j++) res+=counter[i].first; } cout &lt;&lt; res &lt;&lt;endl; return res; } };</content></entry><entry><title>[Leetcode] Implement Stack using Queues(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode225/</url><categories><category>leetcode</category></categories><tags><tag>stack</tag><tag>queue</tag><tag>design</tag></tags><content type="html"> LeetCode 225 - Implement Stack using Queues Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).
Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes:
You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&rsquo;s standard operations. example
Input ["MyStack", "push", "push", "top", "pop", "empty"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False How can we solve this problem? 這題就是要我們用Queue來模擬Stack。做這題之前我們要先知道Queue和Stack的差異。
Queue是First In First Out, 也就是先進去的element會先被拿出來 Stack是First In Last Out, 也就是先進去的element最後才會被拿出來 push(int x):
如果要用Queue來模擬Stack就要注意在Queue中的最後一個元素會是Stack的第一個元素。所以，這題我們可以用比較簡單粗暴的方式來解決。因為我們已經知道後進(Last In)Stack的值會是第一個元素。因此,我們可以直接用一個variable保存最後插入進Queue的element即可。
pop()
如果我們要移除element，就必須要將Queue的最後一個元素搬到最前面，同時因為最前面的元素會被移除，所以我們用於保存最後插入進Queue的variable所記錄的值也必須被改變，變成Queue的倒數第二個element。因此我們要先將Queue中最後的2個element搬到最前面，第一個便是我們stack的top,而第二個是我們要pop的element。最後，我們記錄完top的值後，插入到Queue的尾巴，並返回要Queue的front即可。
clear(): 只需將空的Queue取代成當前不是空的Queue即可。
empty():
只需檢查Queue是否為empty()即可。
Solution: class MyStack { public: queue&lt;int> q; int t; // queue&lt;int> q2; MyStack() { } //O(N) void push(int x) { // q2.push(x); // while(!q.empty()){ // q2.push(q.front());q.pop(); // } // q = q2; // clear(q2); q.push(x); t = x; } //O(1) int pop() { // if(empty()) return -1; // int value = q.front();q.pop(); //get the last 2 elements int size = q.size(); while(size-- > 2) { q.push(q.front()); q.pop(); } //getting the 2th top value in stack t = q.front(); q.push(q.front()); //push it at the back of the queue q.pop(); //getting the 1th top value in stack int popVal = q.front(); q.pop(); return popVal; } void clear(queue&lt;int>&amp; q){ queue&lt;int> empty; swap(empty, q); } int top() { // if(empty()) return -1; // return q.front(); return t; } bool empty() { return q.empty() ? true : false; } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */</content></entry><entry><title>[Leetcode] Max Number of K-Sum Pairs(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1679/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>map</tag><tag>two-pointer</tag></tags><content type="html"> LeetCode 1679 - Max Number of K-Sum Pairs You are given an integer array nums and an integer k.
In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.
Return the maximum number of operations you can perform on the array.
example
Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations. Input: nums = [3,1,3,4,3], k = 6 Output: 1 Explanation: Starting with nums = [3,1,3,4,3]: - Remove the first two 3's, then nums = [1,4,3] There are no more pairs that sum up to 6, hence a total of 1 operation. How can we solve this problem? 這題就是要移除Array中2個elements加起來等於k的操作有幾次。
第一個解法，我們可以使用sorting以及two-pointer approach來解決。先將array排序，然後設置i為0,j為n-1,直接使用iteration找出nums[i]+nums[j] = k的數，然後answer+1即可。
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { //sort sort(nums.begin(),nums.end()); //O n log n int ans = 0; int i = 0,j = nums.size()-1; while(i &lt; j){ if(nums[i] + nums[j] == k) { ans++; i++; j--; }else if(nums[i] + nums[j] > k)j--; else i++; } return ans; } }; 第二種解法是透過map來記錄。首先，會透過x = k - nums[i]得出一個數，如果這個數不存在map裡面或者map[x] &lt;= 0就代表沒有，就把目前的nums[i]加入到map。如果存在，就將answer+1並且從map中移除map[x]的數量(map[x]--)。
Solution: class Solution { public: int maxOperations(vector&lt;int>&amp; nums, int k) { unordered_map&lt;int,int> temp; int ans = 0; for(int i = 0;i&lt;nums.size();i++){ int sum = k - nums[i]; if(temp[sum] > 0){ //exist this value; //for example:[3,1,3,4,3] //3,1,3(we are here) 6-3=3 and 3:1 and we found a pair(3,3)=6 ,and remove the existing value ans++; temp[sum]--; }else temp[nums[i]]++; } return ans; } };</content></entry><entry><title>[Leetcode] Shortest Unsorted Continuous Subarray(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode581/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 581 - Shortest Unsorted Continuous Subarray Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.
Return the shortest such subarray and output its length.
example:
Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Input: nums = [1,2,3,4] Output: 0 Input: nums = [1] Output: 0 How can we solve this problem? 這題比較難懂一點點，這裡先做一下題目的解釋。這題主要先問的是在輸入的Array裡面找到一個最小需要排序的Sub-array。
從例子[2,6,4,8,10,9,15]中，我們可以很明顯的看到[6,4,8,10,9]並不是ascending order(順序),而這個sub-array要進行排序的話，所有elements都需要進行排序，所以，他的length是5。
再舉另外一個例子[1,3,2,3,3]，這個Array我們可以看到[3,2,3,3]並不是順序的，但是在這個sub-array裡面,只有[3,2]需要排序,所以，他的結果會是2。
那我們應該要怎麼解呢? 一個最簡單的解法是定義一個額外的array，而這個array的element跟原來的一樣，但是已經被排序過的。因此，只要比較原本的array和排序過的array有幾個element的位置不一樣就知道結果了。但Time Complexity是是O(n log n) - 排序的時間，而Space Complexity則是O(n)
Solution: vector&lt;int> temp = nums; sort(temp.begin(),temp.end()); //n log n int start = nums.size() - 1; int end = 0; //finding the starting point which is not as same as the sorted array //finding the ending print which is not as same as the sorted array for(int i =0;i&lt;nums.size();i++){ if(nums[i] != temp[i]){ start = min(i,start); // end = max(end,i); } } return end - start >= 0 ? end - start + 1 : 0; 另外一種解法是通過Two-pointer approach來解。我們先要找到左手邊有問題的地方的最小值(1,4,7,5,3,6 最小值為3)以及右手邊有問題的地方的最大值(1,4,7,5,3,6 最大值為7)。然後,要找出左手邊第一個被影響的index(nums[index] > 最小值)。同理也要找出右手邊第一個被影響的最index(nums[index] &lt; 最大值)。這樣我們就能找出有問題的區間[left,right]，在根據left,right得出最終結果。 Solution: 解法二:
int start = INT_MAX; int end = INT_MIN; for(int i = 1;i&lt;nums.size();i++){ if(nums[i] &lt; nums[i-1]) start = min(nums[i],start); } for(int i = nums.size() - 2;i>=0;i--){ if(nums[i] > nums[i + 1]) end = max(nums[i],end); } int left,right; //scanning the value from the left to the right that is less than maximum value for(left = 0;left&lt;nums.size();left++){ //finding the descending point if(start &lt; nums[left]) break; } //scanning the value from the right to the left that is less than minimum value for(right = nums.size() - 1;right >= 0;right--){ if(end > nums[right]) break; } //we need to find out the right-most point return right - left >= 0 ? right - left + 1 : 0;</content></entry><entry><title>[Leetcode] Sort Array By Parity(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode905/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 905 - Sort Array By Parity Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
Return any array that satisfies this condition.
example:
Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Input: nums = [0] Output: [0] How can we solve this problem? 這個問題很簡單，就是把偶數移動到Array的前面，基數移動到後面。我們這裡可以使用Two-pointer approach, i為尋找前面的基數，而j 為尋找後面的偶數，只要nums[i]為基數,nums[j]為偶數就進行交換。
=j`就結束 -- Solution: class Solution { public: vector&lt;int> sortArrayByParity(vector&lt;int>&amp; nums) { int i = 0; int j = nums.size() - 1; //O(n) while(i &lt; j){ //i is even skip //j is odd skip //i is odd and j is even swap if(nums[i] % 2 == 0) i++; else if(nums[j] % 2 == 1) j--; else swap(nums[i++],nums[j--]); } return nums; } };</content></entry><entry><title>[Leetcode] Backspace String Compare(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode844/</url><categories><category>leetcode</category></categories><tags><tag>string</tag></tags><content type="html"> LeetCode 844 - Backspace String Compare Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
example:
Input: s = "ab#c", t = "ad#c" Output: true Explanation: Both s and t become "ac". Input: s = "ab##", t = "c#d#" Output: true Explanation: Both s and t become "". Input: s = "a#c", t = "b" Output: false Explanation: s becomes "c" while t becomes "b". How can we solve this problem? 這題主要要什麼比較2個String移除於#前的字符後是否為相同的String，就相當於Backspace(#) 字符。 這題有2種解法:
要使用到額外的空間，保存2個移除字符後的String再進行比較。 透過pointerr的方式來決定哪個位置是要被移除的，然後將之後的字符將其進行取代，最後在比較倆者在r長度內的字符是否相同，即可。可見下圖為例: Solution: class Solution { public: bool backspaceCompare(string s, string t) { int slen = s.length(); int tlen = t.length(); int i = 0; int rpSStrIndex = 0; while(i &lt; slen ){ if(s[i] == '#') { if(rpSStrIndex > 0) rpSStrIndex--; } else s[rpSStrIndex++] = s[i]; i++; } i = 0; int rpTStrIndex = 0; while(i &lt; tlen){ if(t[i] == '#' ){ if(rpTStrIndex > 0) rpTStrIndex--; } else t[rpTStrIndex++] = t[i]; i++; } cout &lt;&lt; rpSStrIndex &lt;&lt; rpTStrIndex; //there length is not same if(rpSStrIndex != rpTStrIndex) return false; //compare each string between replaced Index for(i = 0;i&lt;rpSStrIndex;i++){ if(s[i] != t[i]) return false; } return true; } };</content></entry><entry><title>[Leetcode] Trim a Binary Search Tree(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode669/</url><categories><category>leetcode</category></categories><tags><tag>binary Search Tree</tag><tag>binary Tree</tag><tag>recursion</tag></tags><content type="html"> LeetCode 669 - Trim a Binary Search Tree Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.
Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.
example
Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] How can we solve this problem? 這題就是要我們將一顆BST的少於low的部分以及大於heigh的部分移除。這題打算使用遞歸來解決。我們只要將比low小的Node的右子樹接到他的父節點，並取代比low還小的Node，而比heigh大的Node的左子樹接到他的父節點，並取代比heigh還大的Node即可。
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* trimBST(TreeNode* root, int low, int high) { //space : O(tree node size for all nodes value are between low and height) //time : O(tree node size for all nodes) return TrimBST(root,low,high); } TreeNode* TrimBST(TreeNode* root,int low,int height){ if(!root) return nullptr; //if the root value is less than height ,go right sub-tree //if the root value is greater than low ,go left sub-tree if(root->val &lt; low){ // root->left = nullptr; return TrimBST(root->right,low,height); }else if(root->val > height){ // root->right = nullptr; return TrimBST(root->left,low,height); } //left root->left = TrimBST(root->left,low,height); //right root->right = TrimBST(root->right,low,height); // cout &lt;&lt; root->val &lt;&lt; "\n"; return root; } };</content></entry><entry><title>[Leetcode] Search in a Binary Search Tree(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode700/</url><categories><category>leetcode</category></categories><tags><tag>binary search tree</tag><tag>recursion</tag><tag>binary Tree</tag></tags><content type="html"> LeetCode 700 - Search in a Binary Search Tree You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
example
Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Input: root = [4,2,7,1,3], val = 5 Output: [] How can we solve this problem? 在解決問題之前，我們需要知道什麼是Binary Search Tree。根據BST的定義:
Binary Search Tree 基於Binary Tree left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value Binary Search Tree的key/value都是unique的 現在我們知道什麼是BST了。這個問題是要在BST中找val，我們通過以下幾個條件以及遞歸幫我們求解:
left sub-tree的所有Node value 都小於root value right sub-tree的所有Node value 都大於root value 如果val是小於root,就移動到左子樹(left sub-tree)，否者移動到右子樹(right sub-tree),直到找到val並返回root的pointer或者沒有找到返回null
Solution: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* searchBST(TreeNode* root, int val) { if(root == nullptr) return root; //check val if(root->val > val){ //go to left return searchBST(root->left,val); // }else if(root->val &lt; val){ return searchBST(root->right,val); }else{ return root; } } };</content></entry><entry><title>[Leetcode] Shift 2D Grid(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode1260/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>math</tag></tags><content type="html"> LeetCode 1260 - Shift 2D Grid Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times.
example
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] How can we solve this problem? 其實這個問題很簡單，我們只需要關心grid的最後得column，因為最後一個Column被right-shift到第一個Column的時候，最後一個element會被移動到0th。其餘的column只要right-shift by 1 step即可。 我們可以參考以下數學公式:
n是row size 以及 m 是 column size
left-shifting : currentColum + k % n, moving by k step shifting row : (j + k) / n), if it is in the last column, (j + k) / m will be 1. Otherwise will be 0 total row shifting step : (i + (j + k) / n)) % m. For example, suppose n = 3 , j = 2 , m = 3 and i = 2: (2 + ((2+1)/3)) % 3 = 0 so that it will move to [0][0] Solution: class Solution { public: vector&lt;vector&lt;int>> shiftGrid(vector&lt;vector&lt;int>>&amp; grid, int k) { //just be careful the last element on [m-1][n-1] //n - k int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); for(int i = 0 ;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ //here we need to know how many time does the colums j pass the col 0,then we need to movie the i of that time // (j + k) % m => total time walk passed int moveJ = (j + k) % m; //if current moving j is the last one int walkPassedZeorTimes = (j + k)/m; int moveI = (i + walkPassedZeorTimes) % n; res[moveI][moveJ] = grid[i][j]; } } return res; } };</content></entry><entry><title>[Leetcode] Spiral Matrix II(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode59/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 59 - Spiral Matrix II Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
example
Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Input: n = 1 Output: [[1]] How can we solve this problem? 這題跟Spiral Matrix做法差不多，我們不難發現他的移動模式就是(右→下↓左←上)，我們只需要通過幾個變數來限制移動的步數。另外，這題需要我們返回一個n2的array，所以，需要額外定義一個counter來記錄每次插入的數值為多少，因此，只要counter 到達n2的大小就知道是否完成插入所需的值。
YES! You Can! Let me explain how it works. According to the example, we can find out its moving pattern(`top-left to top-right`,`top-right to bottom-right`,`bottom-right to bottom-left` and `bottom-left to top left`), it always follows these 4 moving patterns, so that we can define a boundary of row and column to limit pointer moving to has inserted a number. Until reaching n2, it will break the loop and return the answer. -- Solution: 2, then return the answer -- class Solution { public: vector&lt;vector&lt;int>> generateMatrix(int n) { //total step n^2 vector&lt;vector&lt;int>> res(n,vector&lt;int>(n,0)); int c = 1; int upperRow = 0,lowerRow = n - 1; int upperCol = 0,lowerCol = n - 1; while(c &lt;= n*n){ //moving left if(upperCol &lt;= lowerCol){ //n step for(int i = upperCol;i&lt;=lowerCol;i++){ res[upperRow][i] = c++; } } upperRow ++; //moving down //moving down if(upperRow &lt;= lowerRow){ for(int i = upperRow;i&lt;=lowerRow;i++){ res[i][lowerCol] = c++; } } lowerCol--; //moving right if(lowerCol >= upperCol){ for(int i = lowerCol;i>=upperCol;i--){ res[lowerRow][i] = c++; } } lowerRow --; //moving up if(lowerRow >= upperRow){ for(int i = lowerRow;i>=upperRow;i--){ res[i][upperCol] = c++; } } upperCol ++; } return res; } };</content></entry><entry><title>[Leetcode] Game of Life(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode289/</url><categories><category>leetcode</category></categories><tags><tag>array</tag></tags><content type="html"> LeetCode 289 - Game of Life According to Wikipedia&rsquo;s article: &ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&rdquo;
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.
example
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] How can we solve this problem? 要解決這個，我們需要知道目前的cell的狀態(活/死)。要知道目前cell的狀態，我們可以用過條件判斷他身邊的cells(最多9個細胞)即可。
Solution: class Solution { public: void gameOfLife(vector&lt;vector&lt;int>>&amp; board) { int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int>> res(n,vector&lt;int>(m,0)); //O(N^2 for checking each cells) : time //O(N^2 for storing new cells states) : space for(int i = 0;i&lt;n;i++){ for(int j = 0;j&lt;m;j++){ int total = checkState(board,i,j,n,m); if(board[i][j] == 1) res[i][j] = (total &lt; 2 || total > 3 ) ? 0 : 1; else res[i][j] = total == 3 ? 1 : 0; } } board = res; } int checkState(vector&lt;vector&lt;int>>&amp; board,int i,int j,int n,int m){ // //neighbors bounds // int rowStart = (i - i) &lt; 0 ? 0 : i - 1; // int rowEnd = (i + 1) > n - 1 ? n - 1 : i + 1; // int colStart = (j - 1) &lt; 0 ? 0 : j - 1; // int colEnd = (j + 1) > m - 1 ? m - 1 : j + 1; int livesCells = 0; //top left if(i - 1 >= 0 &amp;&amp; j -1 >= 0){ livesCells += board[i-1][j-1]; } //top if(i - 1 >= 0){ livesCells += board[i-1][j]; } //top right if(i - 1 >= 0 &amp;&amp; j + 1 &lt; m){ livesCells += board[i-1][j + 1]; } //left if(j - 1 >= 0){ livesCells += board[i][j - 1]; } //right if(j + 1 &lt; m){ livesCells += board[i][j + 1]; } //bottom left if(i + 1 &lt; n &amp;&amp; j - 1 >= 0){ livesCells += board[i+1][j-1]; } //bottom if(i + 1 &lt; n ){ livesCells += board[i+1][j]; } //bottom right if(i + 1 &lt; n &amp;&amp; j + 1 &lt; m){ livesCells += board[i+1][j+1]; } return livesCells; } };</content></entry><entry><title>[Leetcode] Baseball Game(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode682/</url><categories><category>leetcode</category></categories><tags><tag>array</tag><tag>stack</tag></tags><content type="html"> LeetCode 682 - Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&rsquo; scores.
At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:
An integer x - Record a new score of x. &ldquo;+&rdquo; - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. &ldquo;D&rdquo; - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. &ldquo;C&rdquo; - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. example
Input: ops = ["5","2","C","D","+"] Output: 30 Explanation: "5" - Add 5 to the record, record is now [5]. "2" - Add 2 to the record, record is now [5, 2]. "C" - Invalidate and remove the previous score, record is now [5]. "D" - Add 2 * 5 = 10 to the record, record is now [5, 10]. "+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Input: ops = ["5","-2","4","C","D","9","+","+"] Output: 27 Explanation: "5" - Add 5 to the record, record is now [5]. "-2" - Add -2 to the record, record is now [5, -2]. "4" - Add 4 to the record, record is now [5, -2, 4]. "C" - Invalidate and remove the previous score, record is now [5, -2]. "D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. "9" - Add 9 to the record, record is now [5, -2, -4, 9]. "+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. "+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. How can we solve this problem? 這題就是一個簡單的籃球比賽模擬。我們只要關心遊戲rule，並透過額外的container(array/stack)進行分數保存即可。
Solution: class Solution { public: int calPoints(vector&lt;string>&amp; ops) { //ops : + D C x // vector&lt;int> s; //or using a stack stack&lt;int> sk; //O(n) //O(n) for(auto i : ops) { if(i == "+"){ int a = sk.top(); sk.pop(); int b = sk.top(); sk.push(a); sk.push(a+b); }else if(i == "D"){ sk.push(sk.top() * 2); }else if(i == "C"){ sk.pop(); }else{ sk.push(stoi(i)); } } int res = 0; //O(n) while(!sk.empty()){ res += sk.top();sk.pop(); } return res; } };</content></entry><entry><title>[Note]Creational Singleton Pattern</title><url>https://ryantokmanmokmtm.github.io/post/creational-singleton-pattern/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Singleton Pattern(單例模式)呢? 定義:一個Class在系統中只會存在一個實例(instance),整個系統中只提供1個可使用的instance,以確保唯一性,並節省系統資源。
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
class的建構子(constructor)對外隱藏,外部無法通過constructor進行實例化，但會提供一個靜態(static)方法，以獲取這個class的唯一實例。 TaskManager
//Constructor 對外隱藏，並提供一個靜態Static 讓外部只透過這個存取 class TaskManager{ private: TaskManager(); void displayProcess(); void displayServices(); static TaskManager* taskManager = nullptr; //保存唯一Instance public: //外部只能透過靜態Static 方法存取 並new一個TaskManger的Instance 如果是null的 //此方法為工廠 static TaskManager* getInstance(){ if(taskManager == nullptr){ taskManager = new TaskManager(); } return TaskManager; } } LoadBalance
//LoadBalance 🌰 //用於計算服務器負載，所以必須使用單例 class LoadBalance{ public: static LoadBalance* getInstance(){ if(loadBalance == nullptr){ loadBalance = new LoadBalance(); } return LoadBalance; } private: static LoadBalance* loadBalance; LinkedList* serverList = nullptr; LoadBalance(); void addServer(std::string server){ serverList->add(server);//add a server } std::string getServer(){ int i = random()% serverList->length(); //random get server return serverList->get(i); } } int main(){ LoadBalance *balancer1,*balancer2,*balancer3,*balancer4; balancer1 = LoadBalance::getInstance(); //獲取LoadBalance，這裡會先new 再return balancer2 = LoadBalance::getInstance(); //獲取LoadBalance balancer3 = LoadBalance::getInstance(); //獲取LoadBalance balancer4 = LoadBalance::getInstance(); //獲取LoadBalance //以上4個balancer 都應該為同一記憶體 if(balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) printf("Balancer is nnique"); //add server balancer1->addServer("server1"); balancer1->addServer("server2"); balancer1->addServer("server3"); balancer1->addServer("server4"); for(int i = 0;i&lt;10;i++){ printf("server %d",balancer1->getServer()); } return; } Singleton的問題 因為外部不能實例化，哪應該什麼時候實例化它呢?
從上面例子可以觀察到，第一次使用到getInstance()的時候,會先判斷是否為空,是的話會先實例化並保存pointer,然後再返回Instance。
如果在多線程(Multi-threading)下，同時call getInstance() 會這樣呢?
沒錯!就會導致違反了Sington的目的，導致系統錯誤的嚴重後果。
假如TA和TB 2個Thead 同時call getInstance(),此時這個instance是為null，所以他們都會同時滿足if(instance == null),並進行new instance,導致系統記憶體中會有2個Instance.
哪要如何解決呢?
以下提供了2個方法來解決
餓漢式 在定義class的時候就先把static variable先給實例化，因此，在加載時候就已經被實例化了。 可以想象成不管要不要用(吃)，先實例化了再說(把食物買了再說) (就怕自己會餓死 xD 問題: 可能會浪費資源，因為有可能會出現不使用的情況出現。 懶漢式 要使用的時候，先檢測是否存在，再實例化(就是上面例子一樣) 問題 1: 在多線程的情況下，會變得不安全。為了確保線程安全，就必須要用到Mutex進行保護(會增加開銷) 問題 2: 雖然有加上鎖，但是有可能線程會一起進入if 判斷，等一個thread解鎖了，另外一個還是會重新new 新的一個。因此，要在裡面加多一個if來判斷是否為null。這個稱為double-Check Locking 能克服餓漢式 以及 懶漢式的方法:
在Class內部定義static class來進行實現
因為static Singleton* instance 並不是Class Singleton的成員(Member)，所以在加載時候，不會被實例化，只有呼叫了getInstance 的時候才會被實例化。
class Singleton { private: Singleton() {} static class HolderClass { private: static Singleton* instance = new Singleton(); } public: static Singleton getInstance() { return HolderClass::instance } } } 優點 為系統提供了唯一的Instance 因只有一個Instance,能節省系統資源 在Singleton 模式中，除了唯一的，也可以提供指定數量的Instance，以解決分享過多造成的性能問題 缺點 難以擴展，因為Singleton 不是由 Abstract Class實現 違背原則 有點違反單一職責原則(Single-responsibility Principe) 因又是工廠的角色(new instance),又是Product的角色(返回Static 獲取實例) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Leetcode] Top K Frequent Elements(Medium)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode347/</url><categories><category>leetcode</category></categories><tags><tag>map</tag><tag>priority queue</tag><tag>array</tag></tags><content type="html"> LeetCode 347 - Top K Frequent Elements Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
example
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1] How can we solve this problem? 這一題需要我們返回K個數量最多的element。所以，我們可以使用map記錄我們array中element的個數，然後在把他們以&lt;frequency,element>存到priority queue/max queue，最後只要返回priority queue中的k個element即可。
Solution: class Solution { public: vector&lt;int> topKFrequent(vector&lt;int>&amp; nums, int k) { vector&lt;int> res; unordered_map&lt;int,int> map; priority_queue&lt;pair&lt;int,int>> q; for(auto i : nums) map[i]++; //counter numbers for(auto it : map) q.push({it.second,it.first}); //according to the second for priority while(k-- > 0) { res.push_back(q.top().second); q.pop(); } return res; } };</content></entry><entry><title>[Leetcode] Kth Largest Element in a Stream(Easy)</title><url>https://ryantokmanmokmtm.github.io/leetcodes/leetcode703/</url><categories><category>leetcode</category></categories><tags><tag>heap</tag><tag>priority queue</tag></tags><content type="html"> LeetCode 703 - Kth Largest Element in a Stream Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. example:
Input ["KthLargest", "add", "add", "add", "add", "add"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 How can we solve this problem? 首先，我們要知道這個問題在問什麼。很簡單，這個問題問的是array中k個大元素。舉例 [1,2,3,4,5 ] k=3，需要我們求出三個最大的element，所以會是[3,4,5]。因此。我們只需要關心最大的K的element即可，其他都可以拋棄掉。
th largest element in the array, so we just need to know what the largest kth elements are. For example `[1,2,3,4,5 ] k=3`, the largest 3 elements are `[3,4,5]` right?. Therefore, we just need to consider the top k elements in the array and the other elements will be discarded. -- Solution: class KthLargest { private: priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q; int k; public: KthLargest(int k, vector&lt;int>&amp; nums) { for(auto e : nums) { q.push(e); if(q.size() > k) q.pop(); } this->k = k; } int add(int val) { q.push(val); if(q.size() > k) q.pop(); return q.top(); } };</content></entry><entry><title>長庚大學-畢業專題獎項</title><url>https://ryantokmanmokmtm.github.io/achievement/my-first-reward/</url><categories><category>CGU</category><category>Reward</category></categories><tags/><content type="html"> Reward 這是我跟組員們一起討論、辛苦了多個日夜，能一起做寫程式，分享知識的感覺真的很棒>&lt;。雖然不知道以後還沒有機會一起合作，但還是非常感謝他們願意陪我躲在實驗室裡面一整天(╥╯^╰╥)。希望他們能好好生活，好好學習！
My Teammates</content></entry><entry><title>[Note]Creational Abstract Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-abstract-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Abstract Factory(抽象工廠)呢? 定義: 又稱為Kit模式。提供一個創建系列相關或者互相依賴的Interface，而無需指定其具體的class
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過定義不同組件的Abstraction類,並把Abstraction類組合在一起。通過繼承抽象工廠的方式，定義不同的工廠類，生成不同的Product。 由以下例子可見，有2組不同的UI分別是Summary以及Spring，他們都分包實現了Abstraction 類，然後在透過實現各自的工廠類，生成Summary以及Spring的Product //🌰UI //Button TextField ComboBox //Abstract Class UI class Button{ public: virtual void display() = 0; } class TextField{ public: virtual void display() = 0; } class ComboBox{ public: virtual void display() = 0; } //Abstract Class Factory //用於把不同類型的UI/主題Group 在一起 class UIFactory { public: virtual Button* createButton() = 0; virtual TextField* createTextField() = 0; virtual ComboBox* createComboBox() = 0; } //Spring class SpringButton : public Button{ public: void Draw(){ //Draw Spring style Button } } class SpringTextField : public TextField{ public: void Draw(){ //Draw Spring stype TextField } } class SpringComboBox : public ComboBox{ public: void Draw(){ //Draw Spring stype ComboBox } } //Summer class SummerButton : public Button{ public: void Draw(){ //Draw Summer style Button } } class SummerTextField : public TextField{ public: void Draw(){ //Draw Summer style TextField } } class SummerComboBox : public ComboBox{ public: void Draw(){ //Draw Summer style ComboBox } } //Factory class SpringFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SpringButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SpringTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SpringComboBox(); return ComboBox; }; } //SummerFactory class SummerFactory : public UIFactory{ public: Button* createButton(){ //To init the button and some setting Button* button = new SummerButton(); return button; }; TextField* createTextField(){ //To init the TextField and some setting TextField* textField = new SummerTextField(); return textField; }; ComboBox* createComboBox(){ //To init the ComboBox and some setting ComboBox* comboBox = new SummerComboBox(); return ComboBox; }; } int main(){ //就是透過工廠生成接口生成不同的工廠 //再透過不同的工廠調用其生產的product //Summer 工廠 UIFactory* factory = new SummerFactory(); Button* button = factory->createButton(); TextField* textField = factory->createTextField(); ComboBox* comboBox = factory->createComboBox(); button->draw(); //畫出Summer Style的Button textField->draw(); //畫出Summer Style的textField comboBox->draw(); //畫出Summer Style的comboBox return; } 優點 解決工廠模式中每個產品都使用一個工廠的生產的問題 新增產品很方便，擴展產品以及工廠即可(增加統一產品族) 擁有工廠模式的優點 缺點 如果要新增產品等級結構必須修過工廠抽象類，違反Open-Close 原則(增加產品等級結構) 唯一缺點就是開閉原則的傾斜性 何謂開閉原則的傾斜性呢? 就是在新增產品族(不同類型，相同產品)的時候可以符合開閉原則,但是在新增產品等級結構(同一類型，新增產品/不同的產品類型/等級)時候,必須修改抽象類。這個問題無法解決，只能透過設計避免。 例子 新增A的產品族，只需實現工程類以及實現產品類型，即可新增一個新的工廠用於生成新產品(符合Open-Close) 新增A的類型(如一個新的UI原件:IMG),這樣就必須要修改abstract class以及concrete class的內部(違反Open-Close) 抽象工廠模式跟工廠模式的區別 模式 區別 工廠模式(Factory Pattern) 每一組相關的Product都由同一個具體工廠生產 抽象工廠模式(Factory Pattern) 每個產品族(product)都由同一個具體工廠生產 例如:
電器(同牌子/同一產品族)/電器(同電器(如都是冰箱)/同一產品等級結構)
產品等級結構: 產品的繼承結構,例如:同一種類的產品(如:同一電器但不同牌子)產品族:同一工廠生產的，位於不用產品等級結構的一組產品,例如:同一族群的產品(如:同一牌子的不同電器) 抽象工廠模式(abstract factory pattern)使用場合 當一個工廠的可以創立出屬於不同產品的等級結構的一個產品族中的所有對象時,此時使用抽象工廠模式更有效率和簡單
系統不應該依賴具體的細節(如何創建,表達細節等&hellip;)，依賴於抽象(所有工廠模式都一樣) 系統中多於一個產品族時，而每次只會使用到某一個產品族。可通過配置文件動態修改產品族 約束:屬於同一產品族的產品將在一起使用(同一類)，而這些產品可以沒有任何關係，但有相同約束(同一工廠) 產品等級結構穩定，在設計完成後不會在系統更改/刪除產品等級結構(開閉原則的傾斜性) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Simple RateLimiter Example Based on IP</title><url>https://ryantokmanmokmtm.github.io/post/simple-rateLimiter-example-based-on-IP/</url><categories><category>golang</category><category>backend</category><category>note</category><category>system design</category></categories><tags><tag>gin</tag><tag>rate limiter</tag></tags><content type="html"> 基於Gin實作Rate Limiter 假設我們有2個APIs,而每個API都需要消耗1個Tokens
uri method desc /api/posts/{id} GET return a simple demo message /ping GET return pong 我們先設置一下rate limiter桶子的容量只能放下一個tokens,而tokens則會每秒生產5個。存取API時,若沒有Token可以用，就需要等待token下一次生產並放到桶子裡，才能繼續進行下去。
var ( Rate = rate.Every(time.Millisecond * 200) //1s x 10 token ReqLimiter = rate.NewLimiter(RateLimiterRate, 1) ) Post API Controller exapmle type PostCase struct { } func (p *PostUseCase) GetPost(ctx *gin.Context) { //get params id id := ctx.Param("id") //from the path //use a token if err := limiter.ReqLimiter.Wait(ctx); err != nil { ctx.JSON(http.StatusRequestTimeout, gin.H{}) return } //wait for a token is available or return ctx.JSON(http.StatusOK, gin.H{ "msg": "succeed:" + id, }) } Ping API Controller exapmle type HealthCheck struct { } func (hc *HealthCheck) Pong(ctx *gin.Context) { limiter.ReqLimiter.Wait(ctx) ctx.JSON(http.StatusOK, gin.H{ "msg": "Pong", }) } 基於ClientIP 的Rate limiter 由於上面的的例子都是所有人公用一個Rate Limiter，因此，我們這裡簡單實作一個基於IP的Rate Limiter,相同IP下會公用一個Rate Limiter。
實作思路如下:
定義Map用於保存不同IP下的Rate Limiter 定義Rate Limiter的結構 定義一個移除Rate Limiter的function 用於移除不在線的用戶(只會跑一次) 保存Limiter的結構 包含了2個成員(Member):
Limters: 主要是用於保存不同IP下的Limiter(storage) Lock : 因為有可能會有很多人同時存取這個Map,為了防止Race condition,因此需要使用Mutex進行保護 type Limiters struct { Limiters map[string]*Limiter Lock sync.Mutex } 定義Rate Limiter的結構 包含了3個成員(Member):
Limter : 一個rate limiter的實例 LastAccess : 上次存取這個limiter的時間 type Limiter struct { limiter *rate.Limiter lastAccess time.Time } 定義獲取Rate Limiter的Function 這個function主要做的事情是獲取Client IP的Rate limiter(如果存在)。如果不存在,會新建一個新的Rate Limiter，並保存到Map(storage)中。
func (ls *Limiters) GetLimiter(r rate.Limit, b int, key string) *Limiter { ls.Lock.Lock() defer ls.Lock.Unlock() if limiter, ok := ls.Limiters[key]; ok { return limiter } newLimiter := &amp;Limiter{ limiter: rate.NewLimiter(r, b), lastAccess: time.Now(), //key: key, } ls.Limiters[key] = newLimiter return newLimiter } 定義一個定期檢查Rate Limiter的function 這個function的主要作用的是在設定的時候到達時，會檢查是否有用戶的沒有存取/訪問的時間已超過設定的時間。如果已超過便會從Limiters的Map中移除，以免資源的浪費
func (ls *Limiters) ClearNotUseLimiter(sec time.Duration) { for { time.Sleep(sec) //for now just set 1-minutes for testing //for all limiter for key, l := range ls.Limiters { if time.Now().Sub(l.lastAccess) > sec { ls.Lock.Lock() delete(ls.Limiters, key) log.Printf("limiter for ip:%v is removed", key) ls.Lock.Unlock() } } } } 實作例子 因為每個Request被處理前，必須先確保此用戶(Client IP)沒有超過限制的Request的數目。所以,每個進來的Request都會先經過Middleware做預處理，獲得token後，才能進到處理的程序。
Limiter Middleware 這個Middleware中會透過Request Header(context)裡附帶的Client IP 獲得一個Limiter,並透過此Limiter檢查是否可以獲取Token，如果存取為False會直接response 一個錯誤訊息TooManyRequest
func RateLimiter() gin.HandlerFunc { return func(ctx *gin.Context) { clientIP := ctx.ClientIP() res := app.NewResponse(ctx) if clientIP == "" { res.ErrorResponse(errCode.ClientError.WithDetail("Client agent info not found or error")) ctx.Abort() } //log.Println(clientIP) //limiter : 10 request for each user and a token will generate after 1s l := newLimiters( //1s to generate a token rate.Every(global.AppSetting.LimiterTokenTime), global.AppSetting.LimiterBucketSize, //there are total 10 buckets clientIP) if !l.Allow() { res.ErrorResponse(errCode.TooManyRequest) ctx.Abort() } ctx.Next() } } 獲取Rate Limiter的function如下圖所示。細心的朋友可以發現這個包含了1個onceTask.Do的東西，其實他就是一個go語言內置允許function只跑一次的情況。透過onceTask.Do就可以實現一個Function只跑一次，無論呼叫了幾次同一個function,這個function也會只跑一次，直到程序結束。
這個onceTask.Do所做的事只有1件，也就是檢測是否有用戶不活躍，不活躍的用戶會被移除。它另外一條goroutine中進行，並不會堵塞主goroutin
func newLimiters(r rate.Limit, b int, key string) *limiter.Limiter { onceTask.Do(func() { log.Println("run once") go global.Limiters.ClearNotUseLimiter(global.AppSetting.LimterClearTime) }) return global.Limiters.GetLimiter(r, b, key) } 以上便是基於IP實作Rate Limiter的簡單方法
參考資料:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Token Bucket algorithm introduction and play with golang rate Limiter</title><url>https://ryantokmanmokmtm.github.io/post/token-bucket-intro/</url><categories><category>golang</category><category>backend</category><category>note</category><category>algorithm</category><category>system design</category></categories><tags><tag>golang package</tag><tag>rate limiter</tag></tags><content type="html"> Token Bucket(令牌桶算法) 什麼是Token Bucket 呢? 簡單來說就是運用Token Bucket的系統會以一個設定的速率往桶子(Bucket)裡面丟令牌(Token)。如果請求(Request)需要被處理時，就必需得Bucket裡的Token。當桶子裡面的沒有Token可以分配/獲取時，也就是說Bucket現在是空的(Token已經被其他令牌拿完了)，系統則會拒絕這個請求的服務。
根據算法(Algorithm)的定義:
A token is added to the bucket every 1/r seconds. 一個Token會以每1/r秒加入到Bucket裡面。 The bucket can hold at the most b tokens. If a token arrives when the bucket is full, it is discarded. Bucket可以保存最多b個tokens。如果在bucket以及滿了的情況下，有一個token被加入到bucket，這個token會被丟棄 例子: 假設一個n bytes的packet(封包)送達 假設目前最少有n個token在桶子裡面，這n個token就會被拿出來，然後packet就會被送到網絡上(剛好n bytes 封包有n個tokens) 假設目前桶子裡面可存取的tokens少於n個，就不會有tokens被拿出來(因為需要n個tokens 才能傳送n bytes的封包)，這個封包會被考慮為不符合的封包/不合規的封包 Go 實現/使用Token Bucket Go 的time/rate package 提供了Limiter的實作，而這個Limiter便是實作了Token Bucket的方式來達到限流的目的。
今天我們就來學習一下這麼使用go 提供Limiter來實作Rate Limiter
要如何新增一個Limiter呢? func NewLimiter(r Limit, b int) *Limiter
他有2個參數:
r: rate的type是Limit(一個float64的值)，表示著每秒會產生多少個Token,也就是每1/r秒生產1個token到bucket裡 b: Token Bucket 的桶子的Capacity(容量) //r 設置100表示每秒會產生100個tokens到桶子裡面 1/100 s(1個) //b 設置為1表示桶子最多有1個token limiter := rate.NewLimiter(100,1) Limiter的使用方式 Limiter提供了多個Function: Allow,Reserve,Wait,AllowN,ReserveN,WaitN
最主要使用為以下的3個種Function(都會消耗一個Tokens):
Allow func (lim *Limiter) Allow() bool 是 AllowN(time.Now(), 1)的縮寫 它會消耗掉一個Tokens 如果有token的話會return true 否者會token不足 return false Reserve func (lim *Limiter) Reserve() *Reservation 是 ReserveN(time.Now(), 1)的縮寫 每次會消耗掉一個token 他主要的作用是保存event的資訊預約下一次的服務 Wait(用最多的function) func (lim *Limiter) Wait(ctx context.Context) (err error) 是 WaitN(ctx, 1)的縮寫 每次會消耗掉一個token 主要的作用就是等待直到被取消或者有足夠的Tokens Wait 會堵塞(block)直到有足夠的tokens才會往下執行 Allow func (lim *Limiter) Allow() bool func (lim *Limiter) AllowN(now time.Time, n int) bool Allow() 等價於(equivalent to) AllowN(time.Now(),1)
AllowN主要的作用
AllowN 表示的是在目前的時間點，是否能消耗n個token,如bucket存在n個token則 return true 否則 return false
是想要Drop或者Skip超過rate limit的events時使用 否則使用 Reserve 或者Wait取代 Use this method if you intend to drop / skip events that exceed the rate limit. Otherwise use Reserve or Wait.
//AllowN的例子: func AllowDemo() { //each token generated every 100ms with 5 bucket limiter := rate.NewLimiter(rate.Every(time.Microsecond * 100), 5) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ //each time we need 2 tokens if isAllowed := limiter.AllowN(time.Now(), 2); isAllowed { //bucket have enough tokens fmt.Println("Welcome!!!") fmt.Printf("user:%v is allowed in %v\n", counter, time.Now().Format(time.RFC3339)) } else { fmt.Printf("user:%v is not allowed.Please wait for 100ms and try again later\n", counter) //wait for 100ms time.Sleep(100 * time.Microsecond) } } } Reserve func (lim *Limiter) Reserve() *Reservation func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation Reserve() 等價於(equivalent to) ReserveN(time.Now(),1)
ReserveN的主要作用
ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
回傳一個Reservation 表面在event執行前需要等待多久，這個Reservation被limiter納入考量內
如果Reservation 的所需的token n超過bucket 的size時,Reservation 的OK()會return false
//Reserve例子: func ReserveDemo() { //each token generated every 200ms and each second will put at most 5 tokens to bucket limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 3) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ tokensNeeds := 2 reserve := limiter.ReserveN(time.Now(), tokensNeeds) if !reserve.OK() { //this event won't be completed due to the tokens its needs fmt.Printf("needed tokens %v is greater than the bucket size %v\n", tokensNeeds, limiter.Burst()) return } //wait for the reversing time fmt.Printf("Wait for %v ms...\n", reserve.Delay()) //if dely is 0 that means no need to wait~ time.Sleep(reserve.Delay()) //at least to wait for 200ms fmt.Printf("waiting is done and now is allowed to deal with some tasks...\n") fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC3339)) } } Wait func (lim *Limiter) Wait(ctx context.Context) (err error) func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) Wait(ctx) 等價於(equivalent to) wait(time.Now(),1)
waitN的主要作用
WaitN 每次需要消耗N個Tokens，如果Bucket沒有足夠的Bucket會堵塞，直到有足夠的Tokens(n)才會繼續往下只需。除非以下條件成立才會回傳錯誤:
所需消耗tokens n大於bucket的size Context 被取消 Context 已經超過設定的Deal line(等待時間超過了Deal line) //例子 func WaitDemo() { //at most 5 tokens will generate in a sec 200/1000=5 ctx := context.Background() limiter := rate.NewLimiter(rate.Every(time.Millisecond*200), 2) fmt.Printf("Limiter rates : %v and bucket size : %v \n", limiter.Limit(), limiter.Burst()) counter := 0 for { counter++ if err := limiter.WaitN(ctx, 2); err != nil { fmt.Println("error", err) return } //wait for 2 tokens. At most wait for 400ms fmt.Printf("User %v,time : %v\n", counter, time.Now().Format(time.RFC1123)) } } 設定Bucket 和 Rate 可透過func (lim *Limiter) SetBurst(newBurst int)設定 Bucket size
可透過func (lim *Limiter) SetLimit(newLimit Limit)設定 Limit/Rate
參考資料:
[go-pkg] time/rate package
rate Documentation</content></entry><entry><title>[Note]Creational-Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Factory(工廠)呢? 定義:建立一個接口,讓子類自己決定實現哪一個Factory,其重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
可透過子類繼承Factory的抽象類自主決定生產什麼樣的Product。 生產的Product在透過里氏替換原則(Lisko Subsititution princeple)替換成繼承與Logger的子類，即可換成的需要的Logger。 class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc... Logger* logger = new DatabaseLogger(); //init this logger etc... return logger } } //Client to use int main(){ Factory *factory = new FileLoggerFactory(); Logger *logger = factory->createLogger(); //return the Product that it is initialized Logger->wirteLog(); return; //如果想讓系統有更多靈活性和課擴展性，可以透過xml來進行配置，不需透過修過client的代碼 //只需更新xml中的設置，在代碼中新增新的Product 以及新增的Factory 並重新編譯便可 //除了默認的設置方法外，還想透過傳入String的方法來自定義設計，例如連接要DB，文件的路徑等等 //可以透過Override Abstruct class 的func來進行設置 /* class Factory{ public: virtual Logger* createLogger() = 0; virtual Logger* createLogger(string config) = 0; virtual Logger* createLogger(Object obj) = 0;//通過Obj裡面的成員進行設置等 } */ } 優點 Client無需知道Object的設置的細節，也無需知道實質Object的名稱，只需通過工廠即可 工廠(Factory)以及產品(Product)都是透過Polymorphism(多態)來實現，也是工廠模式的關鍵，工廠可以自主的決定要生產什麼產品，在內部進行設置產品(封裝在內部) 加入新的Product時無需修改Abstract class 以及 具體的工廠和產品的類，只要擴展新增即可，符合Open-Close principle 透過繼承抽象類使系統更容易擴展 缺點 新增產品時，要加入新的產品類以及工廠類，增加了系統的複雜度，而且需要從新編譯，增加了開銷 為了擴展性,加入了抽象類，Client都使用Abstract class 進行編程，增加了系統的抽象性和理解難度 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Creational-Simple Factory</title><url>https://ryantokmanmokmtm.github.io/post/creational-simple-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Simple Factory(簡單工廠)呢? 簡單而言就是: 由一個工廠來生產全部產品 定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object
簡單例子 注: 以下程式單純用於解釋，並不能實際執行
透過Factory 類的Static 方法調用方法，傳入參數生成相關的Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == "A"){ return new ProductA(); } else if(type == "B"){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct("A"); //get ProductA instance Product* B = Factory::getProduct("B"); //get ProductB instance } 優點 Client可以自行決定生產哪個Product Client免除直接建立Product的責任，只僅僅消費產品 Client無需關心具體的類名與相關設置參數 缺點 Factory 的職責太重。所有的Product 都由一個Object 生產，一旦不能正常工作，便會影響整個系統的運作 如有不同的Product會增加系統中的class的數目，增加了系統複雜度以及理解難度 擴展十分困難，添加需要修改Factory的邏輯。如果生存的Product較多時，可能會使其邏輯過於複雜，不利於系統的擴展與維護 違背原則 違背了Open-Close Principe 如果有新的Product 需要生成，就必修要修改Factory類 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Design Pattern Princeple</title><url>https://ryantokmanmokmtm.github.io/post/design-pattern-princeple/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>learning</tag><tag>note</tag></tags><content type="html"> 什麼是Design Pattern(設計模式)呢? 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，如何解決問題的一種方案
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。 設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
Design Pattern 有什麼原則呢? 原則(Princeple) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) Design Pattern 分成哪幾種呢? 主要分成3大類，一共23個
創建型模式(6個) 結構型模式(7個) 行為型模式(11個) 創建型模式(6個) 簡單工廠模式(Simple Factory Pattern) 工廠模式(Factory Pattern) 抽象工廠模式(Abstract Factory Pattern) 單例模式(Singleton Pattern) 原形模式(Prototype Pattern) 建立者模式(Builder Pattern) 結構型模式(7個) 適配器模式(Adapter Pattern) 橋接模式(Bridge Pattern) 組合模式(Composite Pattern) 裝飾模式(Decorator Pattern) 外觀模式(Facade Pattern) 享元模式(FlayWeight Pattern) 代理模式(Proxy Pattern) 行為型模式(11個) 職責鏈模式(Chain of Responsibility Pattern) 命令模式(Command Pattern) 解釋器模式(Interpreter Pattern) 迭代器模式(Iterator Pattern) 中介者模式(Mediator Pattern) 備忘錄模式(Memento Pattern) 觀察者模式(Observer Pattern) 狀態模式(State Pattern) 策略模式(Strategy Pattern) 板塊模式(Template Method Pattern) 訪問者模式(Visitor Pattern) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]What Is JWT(Json Web Token)-EN</title><url>https://ryantokmanmokmtm.github.io/post/jwt-note/</url><categories><category>backend</category><category>development</category><category>web develpment</category><category>note</category><category>english</category></categories><tags><tag>web develpment</tag><tag>token</tag></tags><content type="html"> What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:
Header Payload Signature JWT Header Header typically consists of two parts
type : what&rsquo;s the type of the token algorithm : what algorithm does this token use to sign/encrypt. such as SHA256,RAS or HMAC { "typ" : "jwt", "alg" : "HS256" } This information will be encoded by base64Url algorithm in order to generate the JWT Header
JWT payload In payload is typically saving some users information and other useful information.
Be carefulthat payload must not include any secret information due to base64Url algorithm is easy to be decrypted.
JWT Payload standard claims
{ "sub" :"",//subject "aud" :"",//audience "jti" :"",//jwt id "iat" :"",//Issued at "iss" :"",//Issuer - who is the publisher of the jwt "nbf" :"",//Not Before - JWT is not available before the time jwt set. // other user information that developer set //for example: "user_name" : "jackson_tmm", "email" : "admin@admin.com" } This information will be encoded by base64Url algorithm in order to generate the JWT Payload
Signature The Signature is used to authenticate whether information has been modified during transmission and authenticate the sender that sent this JWT.
To Generate JWT Token Following this function
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), your-256-bit-secret) And these three partes will be combined by a . as following format: xxx.yyy.zzz
//exmaple eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ How it work between Client and server sequenceDiagram Client-Server:POST /authentication {username:xxx..} Note over Client,Server: User logs in alt is authenticated Server-Client:HTTP Status:200 {"token":eyxxx.xx.x} Note over Server,Client: Loged in Succeed else Unauthorized Server-Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Loged in Failed end Client-Server: POST /user/profile {"Authorization":"Bear token"} Note over Server,Client: Get User Profile with token alt succeed Server--Client: HTTP Status:200 {"profile":eyxxx.xx.x} Note over Server,Client: Succeed and response a profile else Unauthorized Server--Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Unauthorized(token error) end</content></entry><entry><title>[CGU]Graduation Project</title><url>https://ryantokmanmokmtm.github.io/project/final-project/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> OTT Movies recommender system-IOS Client Project have been changed/updated
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database Demo Video
--</content></entry><entry><title>About me</title><url>https://ryantokmanmokmtm.github.io/about.html</url><categories/><tags/><content type="html"> 個人簡歷(中) Resume(EN) Introduction 你好~ 歡迎來到我的網站!
我是Jackson.tmm, 是一個從香港來到台灣讀大學的四年級學生。目前就讀於長庚大學-資訊工程學系(Computer Science And Information Engineering)。目前已經畢業了。我目前主要是研究學習後端開發的技術。
感興趣的領域如下:
電影動畫 3D建模技術 後端開發 UI設計 圖形學 2019年 - 基於IOS的微博UI Clone 2020年 -第一次學習IOS開發的Demo 2020年 - 基於IOS的Netfilx UI Clone 2020年 - 第一次學遊戲開發的作品 2020年 - 第一次學建模的作品 2020年 - 送給自己20歲的生日禮物的一顆排球模型 2020年 - 模擬水還是很好玩的(渲染了12小時 (◑‿◐) ) 2020年 - 燈籠魚(Lophiiformes)作品 2021年 - 第一次網絡課學習建模的作業 2021年 - 第一次網絡課學習建模的結課作品(還沒上貼圖>&lt;,有空就上) 2022年 - 電影資源社群平台App Interest 跑步，打球，說唱，唱歌，看電影，看動漫 遊戲設計，遊戲美術，3D建模 搞設計，寫程式 跟朋友分享、交流 特別喜歡宇宙/人類起源相關的奇怪知識 Current Plan 學更多有關後端開發，系統設計相關的技術 學好英文(看電影不要看字幕，能更外國人交流的程度) 考好雅思 跑去考多益了 哈哈哈 (目前660 目標800+) 做好自己,不比較,但一起學習一起進步 Contact Me: Email @Jacksontmm in Telegram</content></entry></search>