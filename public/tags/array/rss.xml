<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Array on Jackson.tmm</title><link>http://localhost:58072/tags/array/</link><description>Recent content in Array on Jackson.tmm</description><generator>Hugo</generator><language>zh-TW</language><lastBuildDate>Tue, 20 Sep 2022 14:47:44 +0800</lastBuildDate><atom:link href="http://localhost:58072/tags/array/rss.xml" rel="self" type="application/rss+xml"/><item><title>[Leetcode] Maximum Length of Repeated Subarray(Medium)</title><link>http://localhost:58072/leetcodes/leetcode718/</link><pubDate>Tue, 20 Sep 2022 14:47:44 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode718/</guid><description>&lt;h2 id="leetcode-718---maximum-length-of-repeated-subarray">LeetCode 718 - Maximum Length of Repeated Subarray
&lt;a class="header-anchor" href="#leetcode-718---maximum-length-of-repeated-subarray">&lt;/a>
&lt;/h2>&lt;p>Given two integer arrays ``nums1&lt;code>and&lt;/code>nums2`, return the maximum length of a subarray that appears in both arrays.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The repeated subarray with maximum length is [3,2,1].
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題要我們找出2個&lt;code>array&lt;/code>中最長的相同&lt;code>subarray&lt;/code>。這題有點類似於
&lt;a href="http://localhost:58072/notes/lcm" title="最長公共子序列" >
 最長公共子序列
 
&lt;/a>,但是不同的是&lt;code>子序列&lt;/code>不一樣的&lt;strong>連續的&lt;/strong>,而&lt;code>subarray&lt;/code>是必須要&lt;strong>連續的&lt;/strong>。哪我們只需要改寫一下&lt;code>最長公共子序列&lt;/code>,我們只需要更新&lt;strong>相等&lt;/strong>的元素即可。其餘的都不需要關心。&lt;/p></description></item><item><title>[Leetcode] Trapping Rain Water(Hard)</title><link>http://localhost:58072/leetcodes/leetcode42/</link><pubDate>Sun, 18 Sep 2022 14:29:08 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode42/</guid><description>&lt;h2 id="leetcode-42---trapping-rain-water">LeetCode 42 - Trapping Rain Water
&lt;a class="header-anchor" href="#leetcode-42---trapping-rain-water">&lt;/a>
&lt;/h2>&lt;p>Given &lt;code>n&lt;/code> non-negative integers representing an elevation map where the width of each bar is &lt;code>1&lt;/code>, compute how much water it can trap after raining.
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: height = [4,2,0,3,2,5]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 9
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題是給定一個&lt;code>array&lt;/code>代表著&lt;strong>高度&lt;/strong>，問我們一共可以裝多少水。這題的解題思路，假設當前是&lt;code>i&lt;/code>,那我當前這個&lt;code>i&lt;/code>是否可以裝水呢？我們是是不是要知道&lt;code>i&lt;/code>的左手邊的最高的柱子(&lt;code>x&lt;/code>)和最右手邊的最高的柱子(&lt;code>y&lt;/code>)，那跟柱子比較矮而且是不是大於現在這個&lt;code>i&lt;/code>。假設&lt;code>IFF x &amp;lt; y &amp;amp;&amp;amp; x &amp;gt; i&lt;/code>,哪&lt;code>i&lt;/code>可以裝的水就會是&lt;code>x - i&lt;/code>那麼多。所以說，我們必須要知道當前&lt;code>i&lt;/code>的左邊最高和&lt;code>i&lt;/code>的右邊最高是多少。哪要怎麼做呢？我們可以透過預處理的方式，預先計算左手邊(&lt;code>i之前&lt;/code>)最大值以及右手邊(&lt;code>i之後&lt;/code>)的最大值，然後在根據以上的方法即可解出答案。&lt;/p></description></item><item><title>[Leetcode] Palindrome Pairs(Hard)</title><link>http://localhost:58072/leetcodes/leetcode336/</link><pubDate>Sat, 17 Sep 2022 20:41:48 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode336/</guid><description>&lt;h2 id="leetcode-336---palindrome-pairs">LeetCode 336 - Palindrome Pairs
&lt;a class="header-anchor" href="#leetcode-336---palindrome-pairs">&lt;/a>
&lt;/h2>&lt;p>Given a list of &lt;strong>unique&lt;/strong> words, return all the pairs of the &lt;em>&lt;strong>distinct&lt;/strong>&lt;/em> indices &lt;code>(i, j)&lt;/code> in the given list, so that the concatenation of the two words &lt;code>words[i] + words[j]&lt;/code> is a palindrome.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: words = [&amp;#34;abcd&amp;#34;,&amp;#34;dcba&amp;#34;,&amp;#34;lls&amp;#34;,&amp;#34;s&amp;#34;,&amp;#34;sssll&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[0,1],[1,0],[3,2],[2,4]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The palindromes are [&amp;#34;dcbaabcd&amp;#34;,&amp;#34;abcddcba&amp;#34;,&amp;#34;slls&amp;#34;,&amp;#34;llssssll&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: words = [&amp;#34;bat&amp;#34;,&amp;#34;tab&amp;#34;,&amp;#34;cat&amp;#34;]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[0,1],[1,0]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The palindromes are [&amp;#34;battab&amp;#34;,&amp;#34;tabbat&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>在解這題之前我們先要知道有哪些情況是成立Palindrome。&lt;/p></description></item><item><title>[Leetcode] Maximum Score from Performing Multiplication Operations(Medium)</title><link>http://localhost:58072/leetcodes/leetcode1770/</link><pubDate>Fri, 16 Sep 2022 20:42:00 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1770/</guid><description>&lt;h2 id="leetcode-1770---maximum-score-from-performing-multiplication-operations">LeetCode 1770 - Maximum Score from Performing Multiplication Operations
&lt;a class="header-anchor" href="#leetcode-1770---maximum-score-from-performing-multiplication-operations">&lt;/a>
&lt;/h2>&lt;p>You are given two integer arrays &lt;code>nums&lt;/code> and &lt;code>multipliers&lt;/code> of size &lt;code>n&lt;/code> and &lt;code>m&lt;/code> respectively, where &lt;code>n &amp;gt;= m&lt;/code>. The arrays are &lt;strong>1-indexed&lt;/strong>.&lt;/p>
&lt;p>You begin with a score of &lt;code>0&lt;/code>. You want to perform &lt;strong>exactly&lt;/strong> &lt;code>m&lt;/code> operations. On the &lt;code>ith&lt;/code> operation (&lt;strong>1-indexed&lt;/strong>), you will:&lt;/p>
&lt;ul>
&lt;li>Choose one integer &lt;code>x&lt;/code> from &lt;strong>either the start or the end&lt;/strong> of the array &lt;code>nums&lt;/code>.&lt;/li>
&lt;li>Add &lt;code>multipliers[i] * &lt;/code>x` to your score.&lt;/li>
&lt;li>Remove x from the array &lt;code>nums&lt;/code>.
Return the maximum score after performing m operations.
example&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,2,3], multipliers = [3,2,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 14
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: An optimal solution is as follows:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [1], adding 1 * 1 = 1 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The total score is 9 + 4 + 1 = 14.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 102
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: An optimal solution is as follows:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The total score is 50 + 15 - 9 + 4 + 42 = 102.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題最主要的重點是對於每個&lt;code>multipliers[i]&lt;/code>,它只能挑選最左邊或者最右邊的值。所有，我們需要知道&lt;code>multipliers[i]&lt;/code>拿最左邊的值最後的結果比較大，還是拿最右邊後的結果比較大。為了避免重複計算而超時，所以我們需要使用&lt;code>dp&lt;/code>來幫助我們記錄當前最優解。&lt;code>注:因multipliers最多為m個，所有最多只能從nums拿m個數字&lt;/code>&lt;/p></description></item><item><title>[Leetcode] Pancake Sorting(Medium)</title><link>http://localhost:58072/leetcodes/leetcode969/</link><pubDate>Thu, 15 Sep 2022 00:31:46 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode969/</guid><description>&lt;h2 id="leetcode-969---pancake-sorting">LeetCode 969 - Pancake Sorting
&lt;a class="header-anchor" href="#leetcode-969---pancake-sorting">&lt;/a>
&lt;/h2>&lt;p>Given an array of integers &lt;code>arr&lt;/code>, sort the array by performing a series of &lt;strong>pancake flips&lt;/strong>.&lt;/p>
&lt;p>In one pancake flip we do the following steps:&lt;/p>
&lt;ul>
&lt;li>Choose an integer &lt;code>k&lt;/code> where &lt;code>1 &amp;lt;= k &amp;lt;= arr.length&lt;/code>.&lt;/li>
&lt;li>Reverse the sub-array &lt;code>arr[0...k-1]&lt;/code> (&lt;strong>0-indexed&lt;/strong>).
For example, if arr = &lt;code>[3,2,1,4]&lt;/code> and we performed a pancake flip choosing &lt;code>k = 3&lt;/code>, we reverse the sub-array &lt;code>[3,2,1]&lt;/code>, so arr = &lt;code>[1,2,3,4]&lt;/code> after the pancake flip at k = 3.&lt;/li>
&lt;/ul>
&lt;p>Return an array of the &lt;code>k&lt;/code>-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within &lt;code>10 * arr.length&lt;/code> flips will be judged as correct.
example&lt;/p></description></item><item><title>[Leetcode] Find Original Array From Doubled Array(Medium)</title><link>http://localhost:58072/leetcodes/leetcode2007/</link><pubDate>Thu, 15 Sep 2022 00:21:27 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode2007/</guid><description>&lt;h2 id="leetcode-2007---find-original-array-from-doubled-array">LeetCode 2007 - Find Original Array From Doubled Array
&lt;a class="header-anchor" href="#leetcode-2007---find-original-array-from-doubled-array">&lt;/a>
&lt;/h2>&lt;p>An integer array &lt;code>original&lt;/code> is transformed into a &lt;strong>doubled&lt;/strong> array changed by appending &lt;strong>twice the value&lt;/strong> of every element in original, and then randomly &lt;strong>shuffling&lt;/strong> the resulting array.&lt;/p>
&lt;p>Given an array &lt;code>changed&lt;/code>, return &lt;code>original&lt;/code> if &lt;code>changed&lt;/code> is a &lt;strong>doubled&lt;/strong> array. If &lt;code>changed&lt;/code> is not a &lt;strong>doubled&lt;/strong> array, &lt;em>return an empty array. The elements in &lt;code>original&lt;/code> may be returned in any order&lt;/em>.
example&lt;/p></description></item><item><title>[Leetcode] UTF-8 Validation(Medium)</title><link>http://localhost:58072/leetcodes/leetcode393/</link><pubDate>Tue, 13 Sep 2022 14:41:37 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode393/</guid><description>&lt;h2 id="leetcode-393---utf-8-validation">LeetCode 393 - UTF-8 Validation
&lt;a class="header-anchor" href="#leetcode-393---utf-8-validation">&lt;/a>
&lt;/h2>&lt;p>Given an integer array &lt;code>data&lt;/code> representing the data, return whether it is a valid &lt;strong>UTF-8&lt;/strong> encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).&lt;/p>
&lt;p>A character in &lt;strong>UTF8&lt;/strong> can be from &lt;strong>1 to 4 bytes&lt;/strong> long, subjected to the following rules:&lt;/p>
&lt;ol>
&lt;li>For a &lt;strong>1-byte&lt;/strong> character, the first bit is a &lt;code>0&lt;/code>, followed by its Unicode code.&lt;/li>
&lt;li>For an &lt;strong>n-bytes&lt;/strong> character, the first n bits are all one&amp;rsquo;s, the &lt;code>n + 1&lt;/code> bit is &lt;code>0&lt;/code>, followed by &lt;code>n - 1&lt;/code> bytes with the most significant &lt;code>2&lt;/code> bits being &lt;code>10&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>This is how the UTF-8 encoding would work:&lt;/p></description></item><item><title>[Leetcode] Bag of Tokens(Medium)</title><link>http://localhost:58072/leetcodes/leetcode948/</link><pubDate>Mon, 12 Sep 2022 18:01:44 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode948/</guid><description>&lt;h2 id="leetcode-948---bag-of-tokens">LeetCode 948 - Bag of Tokens
&lt;a class="header-anchor" href="#leetcode-948---bag-of-tokens">&lt;/a>
&lt;/h2>&lt;p>You have an initial &lt;strong>power&lt;/strong> of &lt;code>power&lt;/code>, an initial &lt;strong>score&lt;/strong> of &lt;code>0&lt;/code>, and a bag of &lt;code>tokens&lt;/code> where &lt;code>tokens[i]&lt;/code> is the value of the i&lt;sup>th&lt;/sup> token (0-indexed).&lt;/p>
&lt;p>Your goal is to maximize your total &lt;strong>score&lt;/strong> by potentially playing each token in one of two ways:&lt;/p>
&lt;ul>
&lt;li>If your current &lt;strong>power&lt;/strong> is at least &lt;code>tokens[i]&lt;/code>, you may play the i&lt;sup>th&lt;/sup> token face up, losing &lt;code>tokens[i]&lt;/code>&lt;strong>power&lt;/strong> and gaining &lt;code>1&lt;/code>a score.&lt;/li>
&lt;li>If your current &lt;strong>score&lt;/strong> is at least &lt;code>1&lt;/code>, you may play the i&lt;sup>th&lt;/sup> token face down, gaining &lt;code>tokens[i]&lt;/code> &lt;strong>power&lt;/strong> and losing &lt;code>1&lt;/code> &lt;strong>score&lt;/strong>.
Each token may be played &lt;strong>at most&lt;/strong> once and &lt;strong>in any order&lt;/strong>. You do &lt;strong>not&lt;/strong> have to play all the tokens.&lt;/li>
&lt;/ul>
&lt;p>Return &lt;em>the largest possible &lt;strong>score&lt;/strong> you can achieve after playing any number of tokens&lt;/em>.&lt;/p></description></item><item><title>[Leetcode] The Number of Weak Characters in the Game(Medium)</title><link>http://localhost:58072/leetcodes/leetcode1996/</link><pubDate>Fri, 09 Sep 2022 23:36:50 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1996/</guid><description>&lt;h2 id="leetcode-1996---the-number-of-weak-characters-in-the-game">LeetCode 1996 - The Number of Weak Characters in the Game
&lt;a class="header-anchor" href="#leetcode-1996---the-number-of-weak-characters-in-the-game">&lt;/a>
&lt;/h2>&lt;p>You are playing a game that contains multiple characters, and each of the characters has &lt;strong>two&lt;/strong> main properties: &lt;strong>attack&lt;/strong> and &lt;strong>defense&lt;/strong>. You are given a 2D integer array &lt;code>properties&lt;/code> where &lt;code>properties[i] = [attacki, defensei]&lt;/code> represents the properties of the i&lt;sup>th&lt;/sup> character in the game.&lt;/p>
&lt;p>A character is said to be &lt;strong>weak&lt;/strong> if any other character has &lt;strong>both&lt;/strong> attack and defense levels &lt;strong>strictly greater&lt;/strong> than this character&amp;rsquo;s attack and defense levels. More formally, a character &lt;code>i&lt;/code> is said to be &lt;strong>weak&lt;/strong> if there exists another character &lt;code>j&lt;/code> where attack&lt;sub>j&lt;/sub> attack&lt;sub>i&lt;/sub> and defense&lt;sub>j&lt;/sub> &amp;gt; defense&lt;sub>i&lt;/sub>.&lt;/p></description></item><item><title>[Leetcode] Construct String from Binary Tree(Easy)</title><link>http://localhost:58072/leetcodes/leetcode606/</link><pubDate>Wed, 07 Sep 2022 10:12:28 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode606/</guid><description>&lt;h2 id="leetcode-606---construct-string-from-binary-tree">LeetCode 606 - Construct String from Binary Tree
&lt;a class="header-anchor" href="#leetcode-606---construct-string-from-binary-tree">&lt;/a>
&lt;/h2>&lt;p>Given the &lt;code>root&lt;/code> of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.&lt;/p>
&lt;p>Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [1,2,3,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: &amp;#34;1(2(4))(3)&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Originally, it needs to be &amp;#34;1(2(4)())(3()())&amp;#34;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &amp;#34;1(2(4))(3)&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: root = [1,2,3,null,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: &amp;#34;1(2()(4))(3)&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題就是要讓我們講以&lt;code>string&lt;/code>的方式輸出&lt;strong>Binary Tree&lt;/strong>。只要注意他的規則就可以解決這題。&lt;/p></description></item><item><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><link>http://localhost:58072/leetcodes/leetcode442/</link><pubDate>Tue, 06 Sep 2022 22:02:11 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode442/</guid><description>&lt;h2 id="leetcode-442---find-all-duplicates-in-an-array">LeetCode 442 - Find All Duplicates in an Array
&lt;a class="header-anchor" href="#leetcode-442---find-all-duplicates-in-an-array">&lt;/a>
&lt;/h2>&lt;p>Given an integer array &lt;code>nums&lt;/code> of length &lt;code>n&lt;/code> where all the integers of &lt;code>nums&lt;/code> are in the range &lt;code>[1, n]&lt;/code> and each integer appears &lt;strong>once&lt;/strong> or &lt;strong>twice&lt;/strong>, return an array of all the integers that appears &lt;strong>twice&lt;/strong>.&lt;/p>
&lt;p>You must write an algorithm that runs in &lt;code>O(n)&lt;/code> time and uses only constant extra space.
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [4,3,2,7,8,2,3,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [2,3]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題要我們找出所有在Array裡重複出現2次的數字。解法也很簡單, 因為題目也說了數字會出現1次或者2次,哪我們可以透過&lt;code>Map&lt;/code>來計數,但當前數字已經出現過1次,也就代表當前數字是重複了2次,加入到結果即可。&lt;/p></description></item><item><title>[Leetcode] Create Binary Tree From Descriptions(Medium)</title><link>http://localhost:58072/leetcodes/leetcode2196/</link><pubDate>Tue, 06 Sep 2022 21:45:02 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode2196/</guid><description>&lt;h2 id="leetcode-2196---create-binary-tree-from-descriptions">LeetCode 2196 - Create Binary Tree From Descriptions
&lt;a class="header-anchor" href="#leetcode-2196---create-binary-tree-from-descriptions">&lt;/a>
&lt;/h2>&lt;p>You are given a 2D integer array &lt;code>descriptions&lt;/code> where &lt;code>descriptions[i] = [parenti, childi, isLefti]&lt;/code> indicates that parenti is the &lt;strong>parent&lt;/strong> of childi in a &lt;strong>binary&lt;/strong> tree of &lt;strong>unique&lt;/strong> values. Furthermore,&lt;/p>
&lt;ul>
&lt;li>If &lt;code>isLefti == 1&lt;/code>, then &lt;strong>child&lt;sub>i&lt;/sub>&lt;/strong> is the left child of &lt;strong>parent&lt;sub>i&lt;/sub>&lt;/strong>.&lt;/li>
&lt;li>If &lt;code>isLefti == 0&lt;/code>, then &lt;strong>child&lt;sub>i&lt;/sub>&lt;/strong> is the right child of &lt;strong>parent&lt;sub>i&lt;/sub>&lt;/strong>.
Construct the binary tree described by &lt;code>descriptions&lt;/code> and return &lt;em>its &lt;strong>root&lt;/strong>&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>The test cases will be generated such that the binary tree is &lt;strong>valid&lt;/strong>.
example&lt;/p></description></item><item><title>[Leetcode] Kth Largest Element in an Array(Medium)</title><link>http://localhost:58072/leetcodes/leetcodes215/</link><pubDate>Wed, 22 Jun 2022 22:55:53 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcodes215/</guid><description>&lt;h2 id="leetcode-1268---search-suggestions-system">LeetCode 1268 - Search Suggestions System
&lt;a class="header-anchor" href="#leetcode-1268---search-suggestions-system">&lt;/a>
&lt;/h2>&lt;p>Given an integer array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return the &lt;code>kth&lt;/code> &lt;em>largest element in the array&lt;/em>.&lt;/p>
&lt;p>Note that it is the &lt;code>kth&lt;/code> largest element in the sorted order, not the &lt;code>kth&lt;/code> distinct element.&lt;/p>
&lt;p>example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,2,1,5,6,4], k = 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題要我們解決的問題是回傳在&lt;code>sorted array&lt;/code>(&lt;em>Input Array沒有排序&lt;/em>)中第&lt;code>kth&lt;/code>大的元素。最簡單的解法是直接排序,然後回傳&lt;code>kth&lt;/code>元素即可。但是, 這裡我們也可以使用&lt;code>Priority Queue(Heap)&lt;/code>來幫我們解決這個問題。因為&lt;code>Priority Queue&lt;/code>的特性,越大的值(&lt;code>MaxHeap&lt;/code>)/越小的值(&lt;code>MinHeap&lt;/code>)會越接近&lt;code>root&lt;/code>,也就是說最大值(&lt;code>MaxHeap&lt;/code>)/最小值(&lt;code>MinHeap&lt;/code>)會在&lt;code>root&lt;/code>。所以我們可以運用&lt;code>MinHeap&lt;/code>來幫助的我們解決這個問題,只要&lt;code>Priority Queue&lt;/code>裡面的元素多於&lt;code>K&lt;/code>個我們就會把&lt;code>top&lt;/code>的值移除，因更小的值會在前面,每次&lt;code>pop&lt;/code>的值都會是當前最小的值,直到最後，省下來的值的&lt;code>root&lt;/code>/&lt;code>top&lt;/code>就會是我們的第&lt;code>K&lt;/code>個最大的值，而&lt;code>priority queue&lt;/code>中最後一個值便會是&lt;code>Input&lt;/code>中最大的值。&lt;/p></description></item><item><title>[Leetcode] Furthest Building You Can Reach(Medium)</title><link>http://localhost:58072/leetcodes/leetcodes1642/</link><pubDate>Tue, 21 Jun 2022 22:55:43 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcodes1642/</guid><description>&lt;h2 id="leetcode-1642---furthest-building-you-can-reach">LeetCode 1642 - Furthest Building You Can Reach
&lt;a class="header-anchor" href="#leetcode-1642---furthest-building-you-can-reach">&lt;/a>
&lt;/h2>&lt;p>You are given an integer array &lt;code>heights&lt;/code> representing the heights of buildings, some &lt;code>bricks&lt;/code>, and some &lt;code>ladders&lt;/code>.&lt;/p>
&lt;p>You start your journey from building &lt;code>0&lt;/code> and move to the next building by possibly using bricks or ladders.&lt;/p>
&lt;p>While moving from building &lt;code>i&lt;/code> to building &lt;code>i+1&lt;/code> (&lt;strong>0-indexed&lt;/strong>),&lt;/p>
&lt;ul>
&lt;li>If the current building&amp;rsquo;s height is &lt;strong>greater than or equal&lt;/strong> to the next building&amp;rsquo;s height, you do not need a ladder or bricks.&lt;/li>
&lt;li>If the current building&amp;rsquo;s height is &lt;strong>less than&lt;/strong> the next building&amp;rsquo;s height, you can either use one ladder or &lt;code>(h[i+1] - h[i])&lt;/code> bricks.
&lt;em>Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>example:&lt;/p></description></item><item><title>[Leetcode] Short Encoding of Words(Medium)</title><link>http://localhost:58072/leetcodes/leetcode802/</link><pubDate>Mon, 20 Jun 2022 12:45:05 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode802/</guid><description>&lt;h2 id="820---short-encoding-of-words">820 - Short Encoding of Words
&lt;a class="header-anchor" href="#820---short-encoding-of-words">&lt;/a>
&lt;/h2>&lt;p>A &lt;strong>valid encoding&lt;/strong> of an array of &lt;code>words&lt;/code> is any reference string s and array of indices indices such that:&lt;/p>
&lt;ul>
&lt;li>&lt;code>words.length&lt;/code> == &lt;code>indices.length&lt;/code>&lt;/li>
&lt;li>The reference string &lt;code>s&lt;/code> ends with the &lt;code>'#'&lt;/code> character.&lt;/li>
&lt;li>For each index indices[i], the &lt;strong>substring&lt;/strong> of s starting from &lt;code>indices[i]&lt;/code> and up to (but not including) the next &lt;code>'#'&lt;/code> character is equal to &lt;code>words[i]&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Given an array of &lt;code>words&lt;/code>, return the length of the shortest reference string &lt;code>s&lt;/code> possible of any valid encoding of &lt;code>words&lt;/code>.&lt;/p></description></item><item><title>[Leetcode] Combination Sum III(Medium)</title><link>http://localhost:58072/leetcodes/leetcode216/</link><pubDate>Tue, 10 May 2022 11:41:43 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode216/</guid><description>&lt;h2 id="leetcode-216---combination-sum-iii">LeetCode 216 - Combination Sum III
&lt;a class="header-anchor" href="#leetcode-216---combination-sum-iii">&lt;/a>
&lt;/h2>&lt;p>Find all valid combinations of &lt;code>k&lt;/code> numbers that sum up to &lt;code>n&lt;/code> such that the following conditions are true:&lt;/p>
&lt;ul>
&lt;li>Only numbers 1 through 9 are used.&lt;/li>
&lt;li>Each number is used &lt;strong>at most once&lt;/strong>.
Return a &lt;em>list of all possible valid combinations&lt;/em>. The list must not contain the same combination twice, and the combinations may be returned in any order.&lt;/li>
&lt;/ul>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: k = 3, n = 7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[1,2,4]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 + 2 + 4 = 7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There are no other valid combinations.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: k = 3, n = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[1,2,6],[1,3,5],[2,3,4]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 + 2 + 6 = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 + 3 + 5 = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 + 3 + 4 = 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There are no other valid combinations.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: k = 4, n = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: There are no valid combinations.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &amp;gt; 1, there are no valid combination.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題主要關注的點是數字範圍為&lt;code>[1,9]&lt;/code>，每個結果中，數字只能使用一次，而且數字必須是順序排列。例如:&lt;code>2,3,4&lt;/code>,&lt;code>1,2,5&lt;/code>。解決這題我們可以用&lt;strong>back-traking&lt;/strong>大法。只要我們當前的&lt;code>Sum&lt;/code>大於&lt;code>n&lt;/code>我們就直接退回back track回上一步,因為數值只會越來越大，並不是我們想要的。如果&lt;em>Ans&lt;/em>我們所需的&lt;code>k&lt;/code>個就直接判斷是否等於&lt;code>n&lt;/code>，如果是就直接加入到我們的&lt;em>result&lt;/em>即可。&lt;/p></description></item><item><title>[Leetcode] 132 Pattern(Medium)</title><link>http://localhost:58072/leetcodes/leetcode456/</link><pubDate>Sat, 07 May 2022 06:30:23 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode456/</guid><description>&lt;h2 id="leetcode-456---132-pattern">LeetCode 456 - 132 Pattern
&lt;a class="header-anchor" href="#leetcode-456---132-pattern">&lt;/a>
&lt;/h2>&lt;p>Given an array of &lt;code>n&lt;/code> integers nums, a &lt;strong>132 pattern&lt;/strong> is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j].&lt;/p>
&lt;p>Return true &lt;em>if there is a 132 pattern in nums, otherwise, return false&lt;/em>.
example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,2,3,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: There is no 132 pattern in the sequence.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,1,4,2]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [-1,3,2,0]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題就是要我們找出&lt;code>List&lt;/code>有沒有符合&lt;code>132 Pattern&lt;/code>。那怎麼才算是&lt;code>132 Pattern&lt;/code>呢。從題目定義可以看出在&lt;code>List&lt;/code>中任意的&lt;code>nums[i] &amp;lt; nums[k] &amp;lt; nums[j]，也就是說&lt;/code>nums[k]&lt;code>為最大,&lt;/code>nums[j]&lt;code>為第二大,&lt;/code>nums[i]`為第三大。&lt;/p></description></item><item><title>[Leetcode] Max Number of K-Sum Pairs(Medium)</title><link>http://localhost:58072/leetcodes/leetcode1679/</link><pubDate>Wed, 04 May 2022 20:11:43 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1679/</guid><description>&lt;h2 id="leetcode-1679---max-number-of-k-sum-pairs">LeetCode 1679 - Max Number of K-Sum Pairs
&lt;a class="header-anchor" href="#leetcode-1679---max-number-of-k-sum-pairs">&lt;/a>
&lt;/h2>&lt;p>You are given an integer array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>.&lt;/p>
&lt;p>In one operation, you can pick two numbers from the array whose sum equals &lt;code>k&lt;/code> and remove them from the array.&lt;/p>
&lt;p>Return &lt;code>the maximum number of operations you can perform on the array&lt;/code>.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,2,3,4], k = 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Starting with nums = [1,2,3,4]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Remove numbers 1 and 4, then nums = [2,3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Remove numbers 2 and 3, then nums = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There are no more pairs that sum up to 5, hence a total of 2 operations.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,1,3,4,3], k = 6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: Starting with nums = [3,1,3,4,3]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- Remove the first two 3&amp;#39;s, then nums = [1,4,3]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There are no more pairs that sum up to 6, hence a total of 1 operation.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題就是要移除&lt;code>Array&lt;/code>中2個elements加起來等於&lt;code>k&lt;/code>的操作有幾次。&lt;br>
第一個解法，我們可以使用&lt;code>sorting&lt;/code>以及&lt;code>two-pointer approach&lt;/code>來解決。先將&lt;code>array&lt;/code>排序，然後設置&lt;code>i&lt;/code>為0,&lt;code>j&lt;/code>為&lt;code>n-1&lt;/code>,直接使用iteration找出&lt;code>nums[i]+nums[j] = k&lt;/code>的數，然後&lt;code>answer+1&lt;/code>即可。&lt;/p></description></item><item><title>[Leetcode] Shortest Unsorted Continuous Subarray(Medium)</title><link>http://localhost:58072/leetcodes/leetcode581/</link><pubDate>Tue, 03 May 2022 18:27:24 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode581/</guid><description>&lt;h2 id="leetcode-581---shortest-unsorted-continuous-subarray">LeetCode 581 - Shortest Unsorted Continuous Subarray
&lt;a class="header-anchor" href="#leetcode-581---shortest-unsorted-continuous-subarray">&lt;/a>
&lt;/h2>&lt;p>Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.&lt;/p>
&lt;p>Return &lt;code>the shortest such subarray and output its length&lt;/code>.&lt;/p>
&lt;p>example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [2,6,4,8,10,9,15]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,2,3,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題比較難懂一點點，這裡先做一下題目的解釋。這題主要先問的是在輸入的&lt;code>Array&lt;/code>裡面找到一個最小需要排序的&lt;code>Sub-array&lt;/code>。&lt;br>
從例子&lt;code>[2,6,4,8,10,9,15]&lt;/code>中，我們可以很明顯的看到&lt;code>[6,4,8,10,9]&lt;/code>並不是ascending order(順序),而這個&lt;code>sub-array&lt;/code>要進行排序的話，所有elements都需要進行排序，所以，他的length是&lt;code>5&lt;/code>。&lt;br>
再舉另外一個例子&lt;code>[1,3,2,3,3]&lt;/code>，這個&lt;code>Array&lt;/code>我們可以看到&lt;code>[3,2,3,3]&lt;/code>並不是順序的，但是在這個&lt;code>sub-array&lt;/code>裡面,只有&lt;code>[3,2]&lt;/code>需要排序,所以，他的結果會是&lt;code>2&lt;/code>。&lt;/p></description></item><item><title>[Leetcode] Sort Array By Parity(Easy)</title><link>http://localhost:58072/leetcodes/leetcode905/</link><pubDate>Mon, 02 May 2022 18:19:41 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode905/</guid><description>&lt;h2 id="leetcode-905---sort-array-by-parity">LeetCode 905 - Sort Array By Parity
&lt;a class="header-anchor" href="#leetcode-905---sort-array-by-parity">&lt;/a>
&lt;/h2>&lt;p>Given an integer array &lt;code>nums&lt;/code>, move all the even integers at the beginning of the array followed by all the odd integers.&lt;/p>
&lt;p>Return &lt;strong>any array&lt;/strong> that satisfies this condition.&lt;/p>
&lt;p>example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [3,1,2,4]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [2,4,3,1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [0]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [0]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這個問題很簡單，就是把偶數移動到Array的前面，基數移動到後面。我們這裡可以使用&lt;code>Two-pointer approach&lt;/code>, &lt;code>i&lt;/code>為尋找前面的基數，而&lt;code>j&lt;/code> 為尋找後面的偶數，只要&lt;code>nums[i]&lt;/code>為基數,&lt;code>nums[j]&lt;/code>為偶數就進行交換。&lt;/p></description></item><item><title>[Leetcode] Shift 2D Grid(Easy)</title><link>http://localhost:58072/leetcodes/leetcode1260/</link><pubDate>Wed, 13 Apr 2022 19:14:44 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode1260/</guid><description>&lt;h2 id="leetcode-1260----shift-2d-grid">LeetCode 1260 - Shift 2D Grid
&lt;a class="header-anchor" href="#leetcode-1260----shift-2d-grid">&lt;/a>
&lt;/h2>&lt;p>Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.&lt;/p>
&lt;p>In one shift operation:&lt;/p>
&lt;ul>
&lt;li>Element at grid[i][j] moves to grid[i][j + 1].&lt;/li>
&lt;li>Element at grid[i][n - 1] moves to grid[i + 1][0].&lt;/li>
&lt;li>Element at grid[m - 1][n - 1] moves to grid[0][0].&lt;/li>
&lt;/ul>
&lt;p>Return the 2D grid after applying shift operation k times.&lt;/p>
&lt;p>example&lt;/p></description></item><item><title>[Leetcode] Spiral Matrix II(Medium)</title><link>http://localhost:58072/leetcodes/leetcode59/</link><pubDate>Wed, 13 Apr 2022 14:26:29 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode59/</guid><description>&lt;h2 id="leetcode-59----spiral-matrix-ii">LeetCode 59 - Spiral Matrix II
&lt;a class="header-anchor" href="#leetcode-59----spiral-matrix-ii">&lt;/a>
&lt;/h2>&lt;p>Given a positive integer n, generate an n x n matrix filled with elements from 1 to n&lt;sup>2&lt;/sup> in spiral order.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: n = 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[1,2,3],[8,9,4],[7,6,5]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: n = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [[1]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這題跟&lt;code>Spiral Matrix&lt;/code>做法差不多，我們不難發現他的移動模式就是(&lt;em>右→下↓左←上&lt;/em>)，我們只需要通過幾個變數來限制移動的步數。另外，這題需要我們返回一個n&lt;sup>2&lt;/sup>的array，所以，需要額外定義一個counter來記錄每次插入的數值為多少，因此，只要counter 到達n&lt;sup>2&lt;/sup>的大小就知道是否完成插入所需的值。&lt;/p></description></item><item><title>[Leetcode] Game of Life(Medium)</title><link>http://localhost:58072/leetcodes/leetcode289/</link><pubDate>Tue, 12 Apr 2022 19:15:53 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode289/</guid><description>&lt;h2 id="leetcode-289----game-of-life">LeetCode 289 - Game of Life
&lt;a class="header-anchor" href="#leetcode-289----game-of-life">&lt;/a>
&lt;/h2>&lt;p>According to Wikipedia&amp;rsquo;s article: &amp;ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;rdquo;&lt;/p>
&lt;p>The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):&lt;/p></description></item><item><title>[Leetcode] Baseball Game(Easy)</title><link>http://localhost:58072/leetcodes/leetcode682/</link><pubDate>Sun, 10 Apr 2022 19:15:31 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode682/</guid><description>&lt;h2 id="leetcode-682---baseball-game">LeetCode 682 - Baseball Game
&lt;a class="header-anchor" href="#leetcode-682---baseball-game">&lt;/a>
&lt;/h2>&lt;p>You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&amp;rsquo; scores.&lt;/p>
&lt;p>At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:&lt;/p></description></item><item><title>[Leetcode] Top K Frequent Elements(Medium)</title><link>http://localhost:58072/leetcodes/leetcode347/</link><pubDate>Sat, 09 Apr 2022 06:22:34 +0800</pubDate><guid>http://localhost:58072/leetcodes/leetcode347/</guid><description>&lt;h2 id="leetcode-347---top-k-frequent-elements">LeetCode 347 - Top K Frequent Elements
&lt;a class="header-anchor" href="#leetcode-347---top-k-frequent-elements">&lt;/a>
&lt;/h2>&lt;p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&lt;/p>
&lt;p>example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1,1,1,2,2,3], k = 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1,2]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Input: nums = [1], k = 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Output: [1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="how-can-we-solve-this-problem">How can we solve this problem?
&lt;a class="header-anchor" href="#how-can-we-solve-this-problem">&lt;/a>
&lt;/h2>&lt;p>這一題需要我們返回K個數量最多的element。所以，我們可以使用&lt;code>map&lt;/code>記錄我們array中element的個數，然後在把他們以&lt;code>&amp;lt;frequency,element&amp;gt;&lt;/code>存到&lt;code>priority queue/max queue&lt;/code>，最後只要返回&lt;code>priority queue&lt;/code>中的&lt;code>k&lt;/code>個element即可。&lt;/p></description></item></channel></rss>